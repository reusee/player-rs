/* automatically generated by rust-bindgen */
#![allow(dead_code, non_camel_case_types)]

use libc::*;
pub type __int128_t = c_void;
pub type __uint128_t = c_void;
pub type __builtin_va_list = [__va_list_tag, ..1u];
pub type int8_t = c_schar;
pub type int16_t = c_short;
pub type int32_t = c_int;
pub type int64_t = c_long;
pub type uint8_t = c_uchar;
pub type uint16_t = c_ushort;
pub type uint32_t = c_uint;
pub type uint64_t = c_ulong;
pub type int_least8_t = c_schar;
pub type int_least16_t = c_short;
pub type int_least32_t = c_int;
pub type int_least64_t = c_long;
pub type uint_least8_t = c_uchar;
pub type uint_least16_t = c_ushort;
pub type uint_least32_t = c_uint;
pub type uint_least64_t = c_ulong;
pub type int_fast8_t = c_schar;
pub type int_fast16_t = c_long;
pub type int_fast32_t = c_long;
pub type int_fast64_t = c_long;
pub type uint_fast8_t = c_uchar;
pub type uint_fast16_t = c_ulong;
pub type uint_fast32_t = c_ulong;
pub type uint_fast64_t = c_ulong;
pub type intptr_t = c_long;
pub type uintptr_t = c_ulong;
pub type intmax_t = c_long;
pub type uintmax_t = c_ulong;
pub type Enum_AVMediaType = c_int;
pub static AVMEDIA_TYPE_UNKNOWN: c_int = -1;
pub static AVMEDIA_TYPE_VIDEO: c_int = 0;
pub static AVMEDIA_TYPE_AUDIO: c_int = 1;
pub static AVMEDIA_TYPE_DATA: c_int = 2;
pub static AVMEDIA_TYPE_SUBTITLE: c_int = 3;
pub static AVMEDIA_TYPE_ATTACHMENT: c_int = 4;
pub static AVMEDIA_TYPE_NB: c_int = 5;
pub type Enum_AVPictureType = c_uint;
pub static AV_PICTURE_TYPE_NONE: c_uint = 0;
pub static AV_PICTURE_TYPE_I: c_uint = 1;
pub static AV_PICTURE_TYPE_P: c_uint = 2;
pub static AV_PICTURE_TYPE_B: c_uint = 3;
pub static AV_PICTURE_TYPE_S: c_uint = 4;
pub static AV_PICTURE_TYPE_SI: c_uint = 5;
pub static AV_PICTURE_TYPE_SP: c_uint = 6;
pub static AV_PICTURE_TYPE_BI: c_uint = 7;
pub type __gwchar_t = c_int;
pub struct imaxdiv_t {
    pub quot: c_long,
    pub rem: c_long,
}
pub type float_t = c_float;
pub type double_t = c_double;
pub type Enum_Unnamed1 = c_uint;
pub static FP_NAN: c_uint = 0;
pub static FP_INFINITE: c_uint = 1;
pub static FP_ZERO: c_uint = 2;
pub static FP_SUBNORMAL: c_uint = 3;
pub static FP_NORMAL: c_uint = 4;
pub type _LIB_VERSION_TYPE = c_int;
pub static _IEEE_: c_int = -1;
pub static _SVID_: c_int = 0;
pub static _XOPEN_: c_int = 1;
pub static _POSIX_: c_int = 2;
pub static _ISOC_: c_int = 3;
pub struct Struct_exception {
    pub _type: c_int,
    pub name: *mut c_schar,
    pub arg1: c_double,
    pub arg2: c_double,
    pub retval: c_double,
}
pub type ptrdiff_t = c_long;
pub type size_t = c_ulong;
pub type wchar_t = c_int;
pub type __u_char = c_uchar;
pub type __u_short = c_ushort;
pub type __u_int = c_uint;
pub type __u_long = c_ulong;
pub type __int8_t = c_schar;
pub type __uint8_t = c_uchar;
pub type __int16_t = c_short;
pub type __uint16_t = c_ushort;
pub type __int32_t = c_int;
pub type __uint32_t = c_uint;
pub type __int64_t = c_long;
pub type __uint64_t = c_ulong;
pub type __quad_t = c_long;
pub type __u_quad_t = c_ulong;
pub type __dev_t = c_ulong;
pub type __uid_t = c_uint;
pub type __gid_t = c_uint;
pub type __ino_t = c_ulong;
pub type __ino64_t = c_ulong;
pub type __mode_t = c_uint;
pub type __nlink_t = c_ulong;
pub type __off_t = c_long;
pub type __off64_t = c_long;
pub type __pid_t = c_int;
pub struct __fsid_t {
    pub __val: [c_int, ..2u],
}
pub type __clock_t = c_long;
pub type __rlim_t = c_ulong;
pub type __rlim64_t = c_ulong;
pub type __id_t = c_uint;
pub type __time_t = c_long;
pub type __useconds_t = c_uint;
pub type __suseconds_t = c_long;
pub type __daddr_t = c_int;
pub type __key_t = c_int;
pub type __clockid_t = c_int;
pub type __timer_t = *mut c_void;
pub type __blksize_t = c_long;
pub type __blkcnt_t = c_long;
pub type __blkcnt64_t = c_long;
pub type __fsblkcnt_t = c_ulong;
pub type __fsblkcnt64_t = c_ulong;
pub type __fsfilcnt_t = c_ulong;
pub type __fsfilcnt64_t = c_ulong;
pub type __fsword_t = c_long;
pub type __ssize_t = c_long;
pub type __syscall_slong_t = c_long;
pub type __syscall_ulong_t = c_ulong;
pub type __loff_t = __off64_t;
pub type __qaddr_t = *mut __quad_t;
pub type __caddr_t = *mut c_schar;
pub type __intptr_t = c_long;
pub type __socklen_t = c_uint;
pub type FILE = Struct__IO_FILE;
pub type __FILE = Struct__IO_FILE;
pub struct Union_Unnamed2 {
    pub data: [u32, ..1u],
}
impl Union_Unnamed2 {
    pub fn __wch(&mut self) -> *mut c_uint {
        unsafe { ::std::cast::transmute(self) }
    }
    pub fn __wchb(&mut self) -> *mut [c_schar, ..4u] {
        unsafe { ::std::cast::transmute(self) }
    }
}
pub struct __mbstate_t {
    pub __count: c_int,
    pub __value: Union_Unnamed2,
}
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub type Struct__IO_jump_t = c_void;
pub type _IO_lock_t = c_void;
pub struct Struct__IO_marker {
    pub _next: *mut Struct__IO_marker,
    pub _sbuf: *mut Struct__IO_FILE,
    pub _pos: c_int,
}
pub type Enum___codecvt_result = c_uint;
pub static __codecvt_ok: c_uint = 0;
pub static __codecvt_partial: c_uint = 1;
pub static __codecvt_error: c_uint = 2;
pub static __codecvt_noconv: c_uint = 3;
pub struct Struct__IO_FILE {
    pub _flags: c_int,
    pub _IO_read_ptr: *mut c_schar,
    pub _IO_read_end: *mut c_schar,
    pub _IO_read_base: *mut c_schar,
    pub _IO_write_base: *mut c_schar,
    pub _IO_write_ptr: *mut c_schar,
    pub _IO_write_end: *mut c_schar,
    pub _IO_buf_base: *mut c_schar,
    pub _IO_buf_end: *mut c_schar,
    pub _IO_save_base: *mut c_schar,
    pub _IO_backup_base: *mut c_schar,
    pub _IO_save_end: *mut c_schar,
    pub _markers: *mut Struct__IO_marker,
    pub _chain: *mut Struct__IO_FILE,
    pub _fileno: c_int,
    pub _flags2: c_int,
    pub _old_offset: __off_t,
    pub _cur_column: c_ushort,
    pub _vtable_offset: c_schar,
    pub _shortbuf: [c_schar, ..1u],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub __pad1: *mut c_void,
    pub __pad2: *mut c_void,
    pub __pad3: *mut c_void,
    pub __pad4: *mut c_void,
    pub __pad5: size_t,
    pub _mode: c_int,
    pub _unused2: [c_schar, ..20u],
}
pub type _IO_FILE = Struct__IO_FILE;
pub type Struct__IO_FILE_plus = c_void;
pub type __io_read_fn = c_void;
pub type __io_write_fn = c_void;
pub type __io_seek_fn = c_void;
pub type __io_close_fn = c_void;
pub type off_t = __off_t;
pub type ssize_t = __ssize_t;
pub type fpos_t = _G_fpos_t;
pub struct Union_wait {
    pub data: [u32, ..1u],
}
impl Union_wait {
    pub fn w_status(&mut self) -> *mut c_int {
        unsafe { ::std::cast::transmute(self) }
    }
    pub fn __wait_terminated(&mut self) -> *mut Struct_Unnamed3 {
        unsafe { ::std::cast::transmute(self) }
    }
    pub fn __wait_stopped(&mut self) -> *mut Struct_Unnamed4 {
        unsafe { ::std::cast::transmute(self) }
    }
}
pub struct Struct_Unnamed3 {
    pub __w_termsig: c_uint,
    pub __w_coredump: c_uint,
    pub __w_retcode: c_uint,
    pub unnamed_field1: c_uint,
}
pub struct Struct_Unnamed4 {
    pub __w_stopval: c_uint,
    pub __w_stopsig: c_uint,
    pub unnamed_field1: c_uint,
}
pub struct __WAIT_STATUS {
    pub data: [u64, ..1u],
}
impl __WAIT_STATUS {
    pub fn __uptr(&mut self) -> *mut *mut Union_wait {
        unsafe { ::std::cast::transmute(self) }
    }
    pub fn __iptr(&mut self) -> *mut *mut c_int {
        unsafe { ::std::cast::transmute(self) }
    }
}
pub struct div_t {
    pub quot: c_int,
    pub rem: c_int,
}
pub struct ldiv_t {
    pub quot: c_long,
    pub rem: c_long,
}
pub struct lldiv_t {
    pub quot: c_longlong,
    pub rem: c_longlong,
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type time_t = __time_t;
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
pub type ulong = c_ulong;
pub type ushort = c_ushort;
pub type _uint = c_uint;
pub type u_int8_t = c_uchar;
pub type u_int16_t = c_ushort;
pub type u_int32_t = c_uint;
pub type u_int64_t = c_ulong;
pub type register_t = c_long;
pub type __sig_atomic_t = c_int;
pub struct __sigset_t {
    pub __val: [c_ulong, ..16u],
}
pub type sigset_t = __sigset_t;
pub struct Struct_timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
pub struct Struct_timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = c_long;
pub struct fd_set {
    pub __fds_bits: [__fd_mask, ..16u],
}
pub type fd_mask = __fd_mask;
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type pthread_t = c_ulong;
pub struct Union_pthread_attr_t {
    pub data: [u64, ..7u],
}
impl Union_pthread_attr_t {
    pub fn __size(&mut self) -> *mut [c_schar, ..56u] {
        unsafe { ::std::cast::transmute(self) }
    }
    pub fn __align(&mut self) -> *mut c_long {
        unsafe { ::std::cast::transmute(self) }
    }
}
pub type pthread_attr_t = Union_pthread_attr_t;
pub struct Struct___pthread_internal_list {
    pub __prev: *mut Struct___pthread_internal_list,
    pub __next: *mut Struct___pthread_internal_list,
}
pub type __pthread_list_t = Struct___pthread_internal_list;
pub struct Struct___pthread_mutex_s {
    pub __lock: c_int,
    pub __count: c_uint,
    pub __owner: c_int,
    pub __nusers: c_uint,
    pub __kind: c_int,
    pub __spins: c_short,
    pub __elision: c_short,
    pub __list: __pthread_list_t,
}
pub struct pthread_mutex_t {
    pub data: [u64, ..5u],
}
impl pthread_mutex_t {
    pub fn __data(&mut self) -> *mut Struct___pthread_mutex_s {
        unsafe { ::std::cast::transmute(self) }
    }
    pub fn __size(&mut self) -> *mut [c_schar, ..40u] {
        unsafe { ::std::cast::transmute(self) }
    }
    pub fn __align(&mut self) -> *mut c_long {
        unsafe { ::std::cast::transmute(self) }
    }
}
pub struct pthread_mutexattr_t {
    pub data: [u32, ..1u],
}
impl pthread_mutexattr_t {
    pub fn __size(&mut self) -> *mut [c_schar, ..4u] {
        unsafe { ::std::cast::transmute(self) }
    }
    pub fn __align(&mut self) -> *mut c_int {
        unsafe { ::std::cast::transmute(self) }
    }
}
pub struct Struct_Unnamed5 {
    pub __lock: c_int,
    pub __futex: c_uint,
    pub __total_seq: c_ulonglong,
    pub __wakeup_seq: c_ulonglong,
    pub __woken_seq: c_ulonglong,
    pub __mutex: *mut c_void,
    pub __nwaiters: c_uint,
    pub __broadcast_seq: c_uint,
}
pub struct pthread_cond_t {
    pub data: [u64, ..6u],
}
impl pthread_cond_t {
    pub fn __data(&mut self) -> *mut Struct_Unnamed5 {
        unsafe { ::std::cast::transmute(self) }
    }
    pub fn __size(&mut self) -> *mut [c_schar, ..48u] {
        unsafe { ::std::cast::transmute(self) }
    }
    pub fn __align(&mut self) -> *mut c_longlong {
        unsafe { ::std::cast::transmute(self) }
    }
}
pub struct pthread_condattr_t {
    pub data: [u32, ..1u],
}
impl pthread_condattr_t {
    pub fn __size(&mut self) -> *mut [c_schar, ..4u] {
        unsafe { ::std::cast::transmute(self) }
    }
    pub fn __align(&mut self) -> *mut c_int {
        unsafe { ::std::cast::transmute(self) }
    }
}
pub type pthread_key_t = c_uint;
pub type pthread_once_t = c_int;
pub struct Struct_Unnamed6 {
    pub __lock: c_int,
    pub __nr_readers: c_uint,
    pub __readers_wakeup: c_uint,
    pub __writer_wakeup: c_uint,
    pub __nr_readers_queued: c_uint,
    pub __nr_writers_queued: c_uint,
    pub __writer: c_int,
    pub __shared: c_int,
    pub __pad1: c_ulong,
    pub __pad2: c_ulong,
    pub __flags: c_uint,
}
pub struct pthread_rwlock_t {
    pub data: [u64, ..7u],
}
impl pthread_rwlock_t {
    pub fn __data(&mut self) -> *mut Struct_Unnamed6 {
        unsafe { ::std::cast::transmute(self) }
    }
    pub fn __size(&mut self) -> *mut [c_schar, ..56u] {
        unsafe { ::std::cast::transmute(self) }
    }
    pub fn __align(&mut self) -> *mut c_long {
        unsafe { ::std::cast::transmute(self) }
    }
}
pub struct pthread_rwlockattr_t {
    pub data: [u64, ..1u],
}
impl pthread_rwlockattr_t {
    pub fn __size(&mut self) -> *mut [c_schar, ..8u] {
        unsafe { ::std::cast::transmute(self) }
    }
    pub fn __align(&mut self) -> *mut c_long {
        unsafe { ::std::cast::transmute(self) }
    }
}
pub type pthread_spinlock_t = c_int;
pub struct pthread_barrier_t {
    pub data: [u64, ..4u],
}
impl pthread_barrier_t {
    pub fn __size(&mut self) -> *mut [c_schar, ..32u] {
        unsafe { ::std::cast::transmute(self) }
    }
    pub fn __align(&mut self) -> *mut c_long {
        unsafe { ::std::cast::transmute(self) }
    }
}
pub struct pthread_barrierattr_t {
    pub data: [u32, ..1u],
}
impl pthread_barrierattr_t {
    pub fn __size(&mut self) -> *mut [c_schar, ..4u] {
        unsafe { ::std::cast::transmute(self) }
    }
    pub fn __align(&mut self) -> *mut c_int {
        unsafe { ::std::cast::transmute(self) }
    }
}
pub struct Struct_random_data {
    pub fptr: *mut int32_t,
    pub rptr: *mut int32_t,
    pub state: *mut int32_t,
    pub rand_type: c_int,
    pub rand_deg: c_int,
    pub rand_sep: c_int,
    pub end_ptr: *mut int32_t,
}
pub struct Struct_drand48_data {
    pub __x: [c_ushort, ..3u],
    pub __old_x: [c_ushort, ..3u],
    pub __c: c_ushort,
    pub __init: c_ushort,
    pub __a: c_ulonglong,
}
pub type __compar_fn_t =
    ::std::option::Option<extern "C" fn(arg1: *c_void, arg2: *c_void)
                              -> c_int>;
pub struct Struct___locale_struct {
    pub __locales: [*mut Struct___locale_data, ..13u],
    pub __ctype_b: *c_ushort,
    pub __ctype_tolower: *c_int,
    pub __ctype_toupper: *c_int,
    pub __names: [*c_schar, ..13u],
}
pub type Struct___locale_data = c_void;
pub type __locale_t = *mut Struct___locale_struct;
pub type locale_t = __locale_t;
pub struct Struct_AVRational {
    pub num: c_int,
    pub den: c_int,
}
pub type AVRational = Struct_AVRational;
pub struct Union_av_intfloat32 {
    pub data: [u32, ..1u],
}
impl Union_av_intfloat32 {
    pub fn i(&mut self) -> *mut uint32_t {
        unsafe { ::std::cast::transmute(self) }
    }
    pub fn f(&mut self) -> *mut c_float {
        unsafe { ::std::cast::transmute(self) }
    }
}
pub struct Union_av_intfloat64 {
    pub data: [u64, ..1u],
}
impl Union_av_intfloat64 {
    pub fn i(&mut self) -> *mut uint64_t {
        unsafe { ::std::cast::transmute(self) }
    }
    pub fn f(&mut self) -> *mut c_double {
        unsafe { ::std::cast::transmute(self) }
    }
}
pub type Enum_AVRounding = c_uint;
pub static AV_ROUND_ZERO: c_uint = 0;
pub static AV_ROUND_INF: c_uint = 1;
pub static AV_ROUND_DOWN: c_uint = 2;
pub static AV_ROUND_UP: c_uint = 3;
pub static AV_ROUND_NEAR_INF: c_uint = 5;
pub static AV_ROUND_PASS_MINMAX: c_uint = 8192;
pub type AVClassCategory = c_uint;
pub static AV_CLASS_CATEGORY_NA: c_uint = 0;
pub static AV_CLASS_CATEGORY_INPUT: c_uint = 1;
pub static AV_CLASS_CATEGORY_OUTPUT: c_uint = 2;
pub static AV_CLASS_CATEGORY_MUXER: c_uint = 3;
pub static AV_CLASS_CATEGORY_DEMUXER: c_uint = 4;
pub static AV_CLASS_CATEGORY_ENCODER: c_uint = 5;
pub static AV_CLASS_CATEGORY_DECODER: c_uint = 6;
pub static AV_CLASS_CATEGORY_FILTER: c_uint = 7;
pub static AV_CLASS_CATEGORY_BITSTREAM_FILTER: c_uint = 8;
pub static AV_CLASS_CATEGORY_SWSCALER: c_uint = 9;
pub static AV_CLASS_CATEGORY_SWRESAMPLER: c_uint = 10;
pub static AV_CLASS_CATEGORY_NB: c_uint = 11;
pub type Struct_AVOptionRanges = c_void;
pub struct Struct_AVClass {
    pub class_name: *c_schar,
    pub item_name: ::std::option::Option<extern "C" fn(arg1: *mut c_void)
                                             -> *c_schar>,
    pub option: *Struct_AVOption,
    pub version: c_int,
    pub log_level_offset_offset: c_int,
    pub parent_log_context_offset: c_int,
    pub child_next: ::std::option::Option<extern "C" fn
                                              (arg1: *mut c_void,
                                               arg2: *mut c_void)
                                              -> *mut c_void>,
    pub child_class_next: ::std::option::Option<extern "C" fn
                                                    (arg1: *Struct_AVClass)
                                                    -> *Struct_AVClass>,
    pub category: AVClassCategory,
    pub get_category: ::std::option::Option<extern "C" fn(arg1: *mut c_void)
                                                -> AVClassCategory>,
    pub query_ranges: ::std::option::Option<extern "C" fn
                                                (arg1:
                                                     *mut *mut Struct_AVOptionRanges,
                                                 arg2: *mut c_void,
                                                 arg3: *c_schar, arg4: c_int)
                                                -> c_int>,
}
pub type Struct_AVOption = c_void;
pub type AVClass = Struct_AVClass;
pub type Enum_AVPixelFormat = c_int;
pub static AV_PIX_FMT_NONE: c_int = -1;
pub static AV_PIX_FMT_YUV420P: c_int = 0;
pub static AV_PIX_FMT_YUYV422: c_int = 1;
pub static AV_PIX_FMT_RGB24: c_int = 2;
pub static AV_PIX_FMT_BGR24: c_int = 3;
pub static AV_PIX_FMT_YUV422P: c_int = 4;
pub static AV_PIX_FMT_YUV444P: c_int = 5;
pub static AV_PIX_FMT_YUV410P: c_int = 6;
pub static AV_PIX_FMT_YUV411P: c_int = 7;
pub static AV_PIX_FMT_GRAY8: c_int = 8;
pub static AV_PIX_FMT_MONOWHITE: c_int = 9;
pub static AV_PIX_FMT_MONOBLACK: c_int = 10;
pub static AV_PIX_FMT_PAL8: c_int = 11;
pub static AV_PIX_FMT_YUVJ420P: c_int = 12;
pub static AV_PIX_FMT_YUVJ422P: c_int = 13;
pub static AV_PIX_FMT_YUVJ444P: c_int = 14;
pub static AV_PIX_FMT_XVMC_MPEG2_MC: c_int = 15;
pub static AV_PIX_FMT_XVMC_MPEG2_IDCT: c_int = 16;
pub static AV_PIX_FMT_UYVY422: c_int = 17;
pub static AV_PIX_FMT_UYYVYY411: c_int = 18;
pub static AV_PIX_FMT_BGR8: c_int = 19;
pub static AV_PIX_FMT_BGR4: c_int = 20;
pub static AV_PIX_FMT_BGR4_BYTE: c_int = 21;
pub static AV_PIX_FMT_RGB8: c_int = 22;
pub static AV_PIX_FMT_RGB4: c_int = 23;
pub static AV_PIX_FMT_RGB4_BYTE: c_int = 24;
pub static AV_PIX_FMT_NV12: c_int = 25;
pub static AV_PIX_FMT_NV21: c_int = 26;
pub static AV_PIX_FMT_ARGB: c_int = 27;
pub static AV_PIX_FMT_RGBA: c_int = 28;
pub static AV_PIX_FMT_ABGR: c_int = 29;
pub static AV_PIX_FMT_BGRA: c_int = 30;
pub static AV_PIX_FMT_GRAY16BE: c_int = 31;
pub static AV_PIX_FMT_GRAY16LE: c_int = 32;
pub static AV_PIX_FMT_YUV440P: c_int = 33;
pub static AV_PIX_FMT_YUVJ440P: c_int = 34;
pub static AV_PIX_FMT_YUVA420P: c_int = 35;
pub static AV_PIX_FMT_VDPAU_H264: c_int = 36;
pub static AV_PIX_FMT_VDPAU_MPEG1: c_int = 37;
pub static AV_PIX_FMT_VDPAU_MPEG2: c_int = 38;
pub static AV_PIX_FMT_VDPAU_WMV3: c_int = 39;
pub static AV_PIX_FMT_VDPAU_VC1: c_int = 40;
pub static AV_PIX_FMT_RGB48BE: c_int = 41;
pub static AV_PIX_FMT_RGB48LE: c_int = 42;
pub static AV_PIX_FMT_RGB565BE: c_int = 43;
pub static AV_PIX_FMT_RGB565LE: c_int = 44;
pub static AV_PIX_FMT_RGB555BE: c_int = 45;
pub static AV_PIX_FMT_RGB555LE: c_int = 46;
pub static AV_PIX_FMT_BGR565BE: c_int = 47;
pub static AV_PIX_FMT_BGR565LE: c_int = 48;
pub static AV_PIX_FMT_BGR555BE: c_int = 49;
pub static AV_PIX_FMT_BGR555LE: c_int = 50;
pub static AV_PIX_FMT_VAAPI_MOCO: c_int = 51;
pub static AV_PIX_FMT_VAAPI_IDCT: c_int = 52;
pub static AV_PIX_FMT_VAAPI_VLD: c_int = 53;
pub static AV_PIX_FMT_YUV420P16LE: c_int = 54;
pub static AV_PIX_FMT_YUV420P16BE: c_int = 55;
pub static AV_PIX_FMT_YUV422P16LE: c_int = 56;
pub static AV_PIX_FMT_YUV422P16BE: c_int = 57;
pub static AV_PIX_FMT_YUV444P16LE: c_int = 58;
pub static AV_PIX_FMT_YUV444P16BE: c_int = 59;
pub static AV_PIX_FMT_VDPAU_MPEG4: c_int = 60;
pub static AV_PIX_FMT_DXVA2_VLD: c_int = 61;
pub static AV_PIX_FMT_RGB444LE: c_int = 62;
pub static AV_PIX_FMT_RGB444BE: c_int = 63;
pub static AV_PIX_FMT_BGR444LE: c_int = 64;
pub static AV_PIX_FMT_BGR444BE: c_int = 65;
pub static AV_PIX_FMT_GRAY8A: c_int = 66;
pub static AV_PIX_FMT_BGR48BE: c_int = 67;
pub static AV_PIX_FMT_BGR48LE: c_int = 68;
pub static AV_PIX_FMT_YUV420P9BE: c_int = 69;
pub static AV_PIX_FMT_YUV420P9LE: c_int = 70;
pub static AV_PIX_FMT_YUV420P10BE: c_int = 71;
pub static AV_PIX_FMT_YUV420P10LE: c_int = 72;
pub static AV_PIX_FMT_YUV422P10BE: c_int = 73;
pub static AV_PIX_FMT_YUV422P10LE: c_int = 74;
pub static AV_PIX_FMT_YUV444P9BE: c_int = 75;
pub static AV_PIX_FMT_YUV444P9LE: c_int = 76;
pub static AV_PIX_FMT_YUV444P10BE: c_int = 77;
pub static AV_PIX_FMT_YUV444P10LE: c_int = 78;
pub static AV_PIX_FMT_YUV422P9BE: c_int = 79;
pub static AV_PIX_FMT_YUV422P9LE: c_int = 80;
pub static AV_PIX_FMT_VDA_VLD: c_int = 81;
pub static AV_PIX_FMT_GBRP: c_int = 82;
pub static AV_PIX_FMT_GBRP9BE: c_int = 83;
pub static AV_PIX_FMT_GBRP9LE: c_int = 84;
pub static AV_PIX_FMT_GBRP10BE: c_int = 85;
pub static AV_PIX_FMT_GBRP10LE: c_int = 86;
pub static AV_PIX_FMT_GBRP16BE: c_int = 87;
pub static AV_PIX_FMT_GBRP16LE: c_int = 88;
pub static AV_PIX_FMT_YUVA422P_LIBAV: c_int = 89;
pub static AV_PIX_FMT_YUVA444P_LIBAV: c_int = 90;
pub static AV_PIX_FMT_YUVA420P9BE: c_int = 91;
pub static AV_PIX_FMT_YUVA420P9LE: c_int = 92;
pub static AV_PIX_FMT_YUVA422P9BE: c_int = 93;
pub static AV_PIX_FMT_YUVA422P9LE: c_int = 94;
pub static AV_PIX_FMT_YUVA444P9BE: c_int = 95;
pub static AV_PIX_FMT_YUVA444P9LE: c_int = 96;
pub static AV_PIX_FMT_YUVA420P10BE: c_int = 97;
pub static AV_PIX_FMT_YUVA420P10LE: c_int = 98;
pub static AV_PIX_FMT_YUVA422P10BE: c_int = 99;
pub static AV_PIX_FMT_YUVA422P10LE: c_int = 100;
pub static AV_PIX_FMT_YUVA444P10BE: c_int = 101;
pub static AV_PIX_FMT_YUVA444P10LE: c_int = 102;
pub static AV_PIX_FMT_YUVA420P16BE: c_int = 103;
pub static AV_PIX_FMT_YUVA420P16LE: c_int = 104;
pub static AV_PIX_FMT_YUVA422P16BE: c_int = 105;
pub static AV_PIX_FMT_YUVA422P16LE: c_int = 106;
pub static AV_PIX_FMT_YUVA444P16BE: c_int = 107;
pub static AV_PIX_FMT_YUVA444P16LE: c_int = 108;
pub static AV_PIX_FMT_VDPAU: c_int = 109;
pub static AV_PIX_FMT_XYZ12LE: c_int = 110;
pub static AV_PIX_FMT_XYZ12BE: c_int = 111;
pub static AV_PIX_FMT_NV16: c_int = 112;
pub static AV_PIX_FMT_NV20LE: c_int = 113;
pub static AV_PIX_FMT_NV20BE: c_int = 114;
pub static AV_PIX_FMT_RGBA64BE: c_int = 291;
pub static AV_PIX_FMT_RGBA64LE: c_int = 292;
pub static AV_PIX_FMT_BGRA64BE: c_int = 293;
pub static AV_PIX_FMT_BGRA64LE: c_int = 294;
pub static AV_PIX_FMT_0RGB: c_int = 295;
pub static AV_PIX_FMT_RGB0: c_int = 296;
pub static AV_PIX_FMT_0BGR: c_int = 297;
pub static AV_PIX_FMT_BGR0: c_int = 298;
pub static AV_PIX_FMT_YUVA444P: c_int = 299;
pub static AV_PIX_FMT_YUVA422P: c_int = 300;
pub static AV_PIX_FMT_YUV420P12BE: c_int = 301;
pub static AV_PIX_FMT_YUV420P12LE: c_int = 302;
pub static AV_PIX_FMT_YUV420P14BE: c_int = 303;
pub static AV_PIX_FMT_YUV420P14LE: c_int = 304;
pub static AV_PIX_FMT_YUV422P12BE: c_int = 305;
pub static AV_PIX_FMT_YUV422P12LE: c_int = 306;
pub static AV_PIX_FMT_YUV422P14BE: c_int = 307;
pub static AV_PIX_FMT_YUV422P14LE: c_int = 308;
pub static AV_PIX_FMT_YUV444P12BE: c_int = 309;
pub static AV_PIX_FMT_YUV444P12LE: c_int = 310;
pub static AV_PIX_FMT_YUV444P14BE: c_int = 311;
pub static AV_PIX_FMT_YUV444P14LE: c_int = 312;
pub static AV_PIX_FMT_GBRP12BE: c_int = 313;
pub static AV_PIX_FMT_GBRP12LE: c_int = 314;
pub static AV_PIX_FMT_GBRP14BE: c_int = 315;
pub static AV_PIX_FMT_GBRP14LE: c_int = 316;
pub static AV_PIX_FMT_GBRAP: c_int = 317;
pub static AV_PIX_FMT_GBRAP16BE: c_int = 318;
pub static AV_PIX_FMT_GBRAP16LE: c_int = 319;
pub static AV_PIX_FMT_YUVJ411P: c_int = 320;
pub static AV_PIX_FMT_BAYER_BGGR8: c_int = 321;
pub static AV_PIX_FMT_BAYER_RGGB8: c_int = 322;
pub static AV_PIX_FMT_BAYER_GBRG8: c_int = 323;
pub static AV_PIX_FMT_BAYER_GRBG8: c_int = 324;
pub static AV_PIX_FMT_BAYER_BGGR16LE: c_int = 325;
pub static AV_PIX_FMT_BAYER_BGGR16BE: c_int = 326;
pub static AV_PIX_FMT_BAYER_RGGB16LE: c_int = 327;
pub static AV_PIX_FMT_BAYER_RGGB16BE: c_int = 328;
pub static AV_PIX_FMT_BAYER_GBRG16LE: c_int = 329;
pub static AV_PIX_FMT_BAYER_GBRG16BE: c_int = 330;
pub static AV_PIX_FMT_BAYER_GRBG16LE: c_int = 331;
pub static AV_PIX_FMT_BAYER_GRBG16BE: c_int = 332;
pub static AV_PIX_FMT_NB: c_int = 333;
pub static PIX_FMT_NONE: c_int = -1;
pub static PIX_FMT_YUV420P: c_int = 0;
pub static PIX_FMT_YUYV422: c_int = 1;
pub static PIX_FMT_RGB24: c_int = 2;
pub static PIX_FMT_BGR24: c_int = 3;
pub static PIX_FMT_YUV422P: c_int = 4;
pub static PIX_FMT_YUV444P: c_int = 5;
pub static PIX_FMT_YUV410P: c_int = 6;
pub static PIX_FMT_YUV411P: c_int = 7;
pub static PIX_FMT_GRAY8: c_int = 8;
pub static PIX_FMT_MONOWHITE: c_int = 9;
pub static PIX_FMT_MONOBLACK: c_int = 10;
pub static PIX_FMT_PAL8: c_int = 11;
pub static PIX_FMT_YUVJ420P: c_int = 12;
pub static PIX_FMT_YUVJ422P: c_int = 13;
pub static PIX_FMT_YUVJ444P: c_int = 14;
pub static PIX_FMT_XVMC_MPEG2_MC: c_int = 15;
pub static PIX_FMT_XVMC_MPEG2_IDCT: c_int = 16;
pub static PIX_FMT_UYVY422: c_int = 17;
pub static PIX_FMT_UYYVYY411: c_int = 18;
pub static PIX_FMT_BGR8: c_int = 19;
pub static PIX_FMT_BGR4: c_int = 20;
pub static PIX_FMT_BGR4_BYTE: c_int = 21;
pub static PIX_FMT_RGB8: c_int = 22;
pub static PIX_FMT_RGB4: c_int = 23;
pub static PIX_FMT_RGB4_BYTE: c_int = 24;
pub static PIX_FMT_NV12: c_int = 25;
pub static PIX_FMT_NV21: c_int = 26;
pub static PIX_FMT_ARGB: c_int = 27;
pub static PIX_FMT_RGBA: c_int = 28;
pub static PIX_FMT_ABGR: c_int = 29;
pub static PIX_FMT_BGRA: c_int = 30;
pub static PIX_FMT_GRAY16BE: c_int = 31;
pub static PIX_FMT_GRAY16LE: c_int = 32;
pub static PIX_FMT_YUV440P: c_int = 33;
pub static PIX_FMT_YUVJ440P: c_int = 34;
pub static PIX_FMT_YUVA420P: c_int = 35;
pub static PIX_FMT_VDPAU_H264: c_int = 36;
pub static PIX_FMT_VDPAU_MPEG1: c_int = 37;
pub static PIX_FMT_VDPAU_MPEG2: c_int = 38;
pub static PIX_FMT_VDPAU_WMV3: c_int = 39;
pub static PIX_FMT_VDPAU_VC1: c_int = 40;
pub static PIX_FMT_RGB48BE: c_int = 41;
pub static PIX_FMT_RGB48LE: c_int = 42;
pub static PIX_FMT_RGB565BE: c_int = 43;
pub static PIX_FMT_RGB565LE: c_int = 44;
pub static PIX_FMT_RGB555BE: c_int = 45;
pub static PIX_FMT_RGB555LE: c_int = 46;
pub static PIX_FMT_BGR565BE: c_int = 47;
pub static PIX_FMT_BGR565LE: c_int = 48;
pub static PIX_FMT_BGR555BE: c_int = 49;
pub static PIX_FMT_BGR555LE: c_int = 50;
pub static PIX_FMT_VAAPI_MOCO: c_int = 51;
pub static PIX_FMT_VAAPI_IDCT: c_int = 52;
pub static PIX_FMT_VAAPI_VLD: c_int = 53;
pub static PIX_FMT_YUV420P16LE: c_int = 54;
pub static PIX_FMT_YUV420P16BE: c_int = 55;
pub static PIX_FMT_YUV422P16LE: c_int = 56;
pub static PIX_FMT_YUV422P16BE: c_int = 57;
pub static PIX_FMT_YUV444P16LE: c_int = 58;
pub static PIX_FMT_YUV444P16BE: c_int = 59;
pub static PIX_FMT_VDPAU_MPEG4: c_int = 60;
pub static PIX_FMT_DXVA2_VLD: c_int = 61;
pub static PIX_FMT_RGB444LE: c_int = 62;
pub static PIX_FMT_RGB444BE: c_int = 63;
pub static PIX_FMT_BGR444LE: c_int = 64;
pub static PIX_FMT_BGR444BE: c_int = 65;
pub static PIX_FMT_GRAY8A: c_int = 66;
pub static PIX_FMT_BGR48BE: c_int = 67;
pub static PIX_FMT_BGR48LE: c_int = 68;
pub static PIX_FMT_YUV420P9BE: c_int = 69;
pub static PIX_FMT_YUV420P9LE: c_int = 70;
pub static PIX_FMT_YUV420P10BE: c_int = 71;
pub static PIX_FMT_YUV420P10LE: c_int = 72;
pub static PIX_FMT_YUV422P10BE: c_int = 73;
pub static PIX_FMT_YUV422P10LE: c_int = 74;
pub static PIX_FMT_YUV444P9BE: c_int = 75;
pub static PIX_FMT_YUV444P9LE: c_int = 76;
pub static PIX_FMT_YUV444P10BE: c_int = 77;
pub static PIX_FMT_YUV444P10LE: c_int = 78;
pub static PIX_FMT_YUV422P9BE: c_int = 79;
pub static PIX_FMT_YUV422P9LE: c_int = 80;
pub static PIX_FMT_VDA_VLD: c_int = 81;
pub static PIX_FMT_GBRP: c_int = 82;
pub static PIX_FMT_GBRP9BE: c_int = 83;
pub static PIX_FMT_GBRP9LE: c_int = 84;
pub static PIX_FMT_GBRP10BE: c_int = 85;
pub static PIX_FMT_GBRP10LE: c_int = 86;
pub static PIX_FMT_GBRP16BE: c_int = 87;
pub static PIX_FMT_GBRP16LE: c_int = 88;
pub static PIX_FMT_RGBA64BE: c_int = 291;
pub static PIX_FMT_RGBA64LE: c_int = 292;
pub static PIX_FMT_BGRA64BE: c_int = 293;
pub static PIX_FMT_BGRA64LE: c_int = 294;
pub static PIX_FMT_0RGB: c_int = 295;
pub static PIX_FMT_RGB0: c_int = 296;
pub static PIX_FMT_0BGR: c_int = 297;
pub static PIX_FMT_BGR0: c_int = 298;
pub static PIX_FMT_YUVA444P: c_int = 299;
pub static PIX_FMT_YUVA422P: c_int = 300;
pub static PIX_FMT_YUV420P12BE: c_int = 301;
pub static PIX_FMT_YUV420P12LE: c_int = 302;
pub static PIX_FMT_YUV420P14BE: c_int = 303;
pub static PIX_FMT_YUV420P14LE: c_int = 304;
pub static PIX_FMT_YUV422P12BE: c_int = 305;
pub static PIX_FMT_YUV422P12LE: c_int = 306;
pub static PIX_FMT_YUV422P14BE: c_int = 307;
pub static PIX_FMT_YUV422P14LE: c_int = 308;
pub static PIX_FMT_YUV444P12BE: c_int = 309;
pub static PIX_FMT_YUV444P12LE: c_int = 310;
pub static PIX_FMT_YUV444P14BE: c_int = 311;
pub static PIX_FMT_YUV444P14LE: c_int = 312;
pub static PIX_FMT_GBRP12BE: c_int = 313;
pub static PIX_FMT_GBRP12LE: c_int = 314;
pub static PIX_FMT_GBRP14BE: c_int = 315;
pub static PIX_FMT_GBRP14LE: c_int = 316;
pub static PIX_FMT_NB: c_int = 317;
pub type Enum_AVSampleFormat = c_int;
pub static AV_SAMPLE_FMT_NONE: c_int = -1;
pub static AV_SAMPLE_FMT_U8: c_int = 0;
pub static AV_SAMPLE_FMT_S16: c_int = 1;
pub static AV_SAMPLE_FMT_S32: c_int = 2;
pub static AV_SAMPLE_FMT_FLT: c_int = 3;
pub static AV_SAMPLE_FMT_DBL: c_int = 4;
pub static AV_SAMPLE_FMT_U8P: c_int = 5;
pub static AV_SAMPLE_FMT_S16P: c_int = 6;
pub static AV_SAMPLE_FMT_S32P: c_int = 7;
pub static AV_SAMPLE_FMT_FLTP: c_int = 8;
pub static AV_SAMPLE_FMT_DBLP: c_int = 9;
pub static AV_SAMPLE_FMT_NB: c_int = 10;
pub type Struct_AVBuffer = c_void;
pub type AVBuffer = Struct_AVBuffer;
pub struct Struct_AVBufferRef {
    pub buffer: *mut AVBuffer,
    pub data: *mut uint8_t,
    pub size: c_int,
}
pub type AVBufferRef = Struct_AVBufferRef;
pub type Struct_AVBufferPool = c_void;
pub type AVBufferPool = Struct_AVBufferPool;
pub type Enum_AVMatrixEncoding = c_uint;
pub static AV_MATRIX_ENCODING_NONE: c_uint = 0;
pub static AV_MATRIX_ENCODING_DOLBY: c_uint = 1;
pub static AV_MATRIX_ENCODING_DPLII: c_uint = 2;
pub static AV_MATRIX_ENCODING_DPLIIX: c_uint = 3;
pub static AV_MATRIX_ENCODING_DPLIIZ: c_uint = 4;
pub static AV_MATRIX_ENCODING_DOLBYEX: c_uint = 5;
pub static AV_MATRIX_ENCODING_DOLBYHEADPHONE: c_uint = 6;
pub static AV_MATRIX_ENCODING_NB: c_uint = 7;
pub type Struct_AVBPrint = c_void;
pub struct Struct_AVDictionaryEntry {
    pub key: *mut c_schar,
    pub value: *mut c_schar,
}
pub type AVDictionaryEntry = Struct_AVDictionaryEntry;
pub type Struct_AVDictionary = c_void;
pub type AVDictionary = Struct_AVDictionary;
pub type Enum_AVColorSpace = c_uint;
pub static AVCOL_SPC_RGB: c_uint = 0;
pub static AVCOL_SPC_BT709: c_uint = 1;
pub static AVCOL_SPC_UNSPECIFIED: c_uint = 2;
pub static AVCOL_SPC_FCC: c_uint = 4;
pub static AVCOL_SPC_BT470BG: c_uint = 5;
pub static AVCOL_SPC_SMPTE170M: c_uint = 6;
pub static AVCOL_SPC_SMPTE240M: c_uint = 7;
pub static AVCOL_SPC_YCOCG: c_uint = 8;
pub static AVCOL_SPC_BT2020_NCL: c_uint = 9;
pub static AVCOL_SPC_BT2020_CL: c_uint = 10;
pub static AVCOL_SPC_NB: c_uint = 11;
pub type Enum_AVColorRange = c_uint;
pub static AVCOL_RANGE_UNSPECIFIED: c_uint = 0;
pub static AVCOL_RANGE_MPEG: c_uint = 1;
pub static AVCOL_RANGE_JPEG: c_uint = 2;
pub static AVCOL_RANGE_NB: c_uint = 3;
pub type Enum_AVFrameSideDataType = c_uint;
pub static AV_FRAME_DATA_PANSCAN: c_uint = 0;
pub static AV_FRAME_DATA_A53_CC: c_uint = 1;
pub static AV_FRAME_DATA_STEREO3D: c_uint = 2;
pub static AV_FRAME_DATA_MATRIXENCODING: c_uint = 3;
pub static AV_FRAME_DATA_DOWNMIX_INFO: c_uint = 4;
pub struct Struct_AVFrameSideData {
    pub _type: Enum_AVFrameSideDataType,
    pub data: *mut uint8_t,
    pub size: c_int,
    pub metadata: *mut AVDictionary,
}
pub type AVFrameSideData = Struct_AVFrameSideData;
pub struct Struct_AVFrame {
    pub data: [*mut uint8_t, ..8u],
    pub linesize: [c_int, ..8u],
    pub extended_data: *mut *mut uint8_t,
    pub width: c_int,
    pub height: c_int,
    pub nb_samples: c_int,
    pub format: c_int,
    pub key_frame: c_int,
    pub pict_type: Enum_AVPictureType,
    pub base: [*mut uint8_t, ..8u],
    pub sample_aspect_ratio: AVRational,
    pub pts: int64_t,
    pub pkt_pts: int64_t,
    pub pkt_dts: int64_t,
    pub coded_picture_number: c_int,
    pub display_picture_number: c_int,
    pub quality: c_int,
    pub reference: c_int,
    pub qscale_table: *mut int8_t,
    pub qstride: c_int,
    pub qscale_type: c_int,
    pub mbskip_table: *mut uint8_t,
    pub motion_val: [*mut c_void, ..2u],
    pub mb_type: *mut uint32_t,
    pub dct_coeff: *mut c_short,
    pub ref_index: [*mut int8_t, ..2u],
    pub opaque: *mut c_void,
    pub error: [uint64_t, ..8u],
    pub _type: c_int,
    pub repeat_pict: c_int,
    pub interlaced_frame: c_int,
    pub top_field_first: c_int,
    pub palette_has_changed: c_int,
    pub buffer_hints: c_int,
    pub pan_scan: *mut Struct_AVPanScan,
    pub reordered_opaque: int64_t,
    pub hwaccel_picture_private: *mut c_void,
    pub owner: *mut Struct_AVCodecContext,
    pub thread_opaque: *mut c_void,
    pub motion_subsample_log2: uint8_t,
    pub sample_rate: c_int,
    pub channel_layout: uint64_t,
    pub buf: [*mut AVBufferRef, ..8u],
    pub extended_buf: *mut *mut AVBufferRef,
    pub nb_extended_buf: c_int,
    pub side_data: *mut *mut AVFrameSideData,
    pub nb_side_data: c_int,
    pub flags: c_int,
    pub best_effort_timestamp: int64_t,
    pub pkt_pos: int64_t,
    pub pkt_duration: int64_t,
    pub metadata: *mut AVDictionary,
    pub decode_error_flags: c_int,
    pub channels: c_int,
    pub pkt_size: c_int,
    pub colorspace: Enum_AVColorSpace,
    pub color_range: Enum_AVColorRange,
    pub qp_table_buf: *mut AVBufferRef,
}
pub type AVFrame = Struct_AVFrame;
pub type Enum_AVCodecID = c_uint;
pub static AV_CODEC_ID_NONE: c_uint = 0;
pub static AV_CODEC_ID_MPEG1VIDEO: c_uint = 1;
pub static AV_CODEC_ID_MPEG2VIDEO: c_uint = 2;
pub static AV_CODEC_ID_MPEG2VIDEO_XVMC: c_uint = 3;
pub static AV_CODEC_ID_H261: c_uint = 4;
pub static AV_CODEC_ID_H263: c_uint = 5;
pub static AV_CODEC_ID_RV10: c_uint = 6;
pub static AV_CODEC_ID_RV20: c_uint = 7;
pub static AV_CODEC_ID_MJPEG: c_uint = 8;
pub static AV_CODEC_ID_MJPEGB: c_uint = 9;
pub static AV_CODEC_ID_LJPEG: c_uint = 10;
pub static AV_CODEC_ID_SP5X: c_uint = 11;
pub static AV_CODEC_ID_JPEGLS: c_uint = 12;
pub static AV_CODEC_ID_MPEG4: c_uint = 13;
pub static AV_CODEC_ID_RAWVIDEO: c_uint = 14;
pub static AV_CODEC_ID_MSMPEG4V1: c_uint = 15;
pub static AV_CODEC_ID_MSMPEG4V2: c_uint = 16;
pub static AV_CODEC_ID_MSMPEG4V3: c_uint = 17;
pub static AV_CODEC_ID_WMV1: c_uint = 18;
pub static AV_CODEC_ID_WMV2: c_uint = 19;
pub static AV_CODEC_ID_H263P: c_uint = 20;
pub static AV_CODEC_ID_H263I: c_uint = 21;
pub static AV_CODEC_ID_FLV1: c_uint = 22;
pub static AV_CODEC_ID_SVQ1: c_uint = 23;
pub static AV_CODEC_ID_SVQ3: c_uint = 24;
pub static AV_CODEC_ID_DVVIDEO: c_uint = 25;
pub static AV_CODEC_ID_HUFFYUV: c_uint = 26;
pub static AV_CODEC_ID_CYUV: c_uint = 27;
pub static AV_CODEC_ID_H264: c_uint = 28;
pub static AV_CODEC_ID_INDEO3: c_uint = 29;
pub static AV_CODEC_ID_VP3: c_uint = 30;
pub static AV_CODEC_ID_THEORA: c_uint = 31;
pub static AV_CODEC_ID_ASV1: c_uint = 32;
pub static AV_CODEC_ID_ASV2: c_uint = 33;
pub static AV_CODEC_ID_FFV1: c_uint = 34;
pub static AV_CODEC_ID_4XM: c_uint = 35;
pub static AV_CODEC_ID_VCR1: c_uint = 36;
pub static AV_CODEC_ID_CLJR: c_uint = 37;
pub static AV_CODEC_ID_MDEC: c_uint = 38;
pub static AV_CODEC_ID_ROQ: c_uint = 39;
pub static AV_CODEC_ID_INTERPLAY_VIDEO: c_uint = 40;
pub static AV_CODEC_ID_XAN_WC3: c_uint = 41;
pub static AV_CODEC_ID_XAN_WC4: c_uint = 42;
pub static AV_CODEC_ID_RPZA: c_uint = 43;
pub static AV_CODEC_ID_CINEPAK: c_uint = 44;
pub static AV_CODEC_ID_WS_VQA: c_uint = 45;
pub static AV_CODEC_ID_MSRLE: c_uint = 46;
pub static AV_CODEC_ID_MSVIDEO1: c_uint = 47;
pub static AV_CODEC_ID_IDCIN: c_uint = 48;
pub static AV_CODEC_ID_8BPS: c_uint = 49;
pub static AV_CODEC_ID_SMC: c_uint = 50;
pub static AV_CODEC_ID_FLIC: c_uint = 51;
pub static AV_CODEC_ID_TRUEMOTION1: c_uint = 52;
pub static AV_CODEC_ID_VMDVIDEO: c_uint = 53;
pub static AV_CODEC_ID_MSZH: c_uint = 54;
pub static AV_CODEC_ID_ZLIB: c_uint = 55;
pub static AV_CODEC_ID_QTRLE: c_uint = 56;
pub static AV_CODEC_ID_TSCC: c_uint = 57;
pub static AV_CODEC_ID_ULTI: c_uint = 58;
pub static AV_CODEC_ID_QDRAW: c_uint = 59;
pub static AV_CODEC_ID_VIXL: c_uint = 60;
pub static AV_CODEC_ID_QPEG: c_uint = 61;
pub static AV_CODEC_ID_PNG: c_uint = 62;
pub static AV_CODEC_ID_PPM: c_uint = 63;
pub static AV_CODEC_ID_PBM: c_uint = 64;
pub static AV_CODEC_ID_PGM: c_uint = 65;
pub static AV_CODEC_ID_PGMYUV: c_uint = 66;
pub static AV_CODEC_ID_PAM: c_uint = 67;
pub static AV_CODEC_ID_FFVHUFF: c_uint = 68;
pub static AV_CODEC_ID_RV30: c_uint = 69;
pub static AV_CODEC_ID_RV40: c_uint = 70;
pub static AV_CODEC_ID_VC1: c_uint = 71;
pub static AV_CODEC_ID_WMV3: c_uint = 72;
pub static AV_CODEC_ID_LOCO: c_uint = 73;
pub static AV_CODEC_ID_WNV1: c_uint = 74;
pub static AV_CODEC_ID_AASC: c_uint = 75;
pub static AV_CODEC_ID_INDEO2: c_uint = 76;
pub static AV_CODEC_ID_FRAPS: c_uint = 77;
pub static AV_CODEC_ID_TRUEMOTION2: c_uint = 78;
pub static AV_CODEC_ID_BMP: c_uint = 79;
pub static AV_CODEC_ID_CSCD: c_uint = 80;
pub static AV_CODEC_ID_MMVIDEO: c_uint = 81;
pub static AV_CODEC_ID_ZMBV: c_uint = 82;
pub static AV_CODEC_ID_AVS: c_uint = 83;
pub static AV_CODEC_ID_SMACKVIDEO: c_uint = 84;
pub static AV_CODEC_ID_NUV: c_uint = 85;
pub static AV_CODEC_ID_KMVC: c_uint = 86;
pub static AV_CODEC_ID_FLASHSV: c_uint = 87;
pub static AV_CODEC_ID_CAVS: c_uint = 88;
pub static AV_CODEC_ID_JPEG2000: c_uint = 89;
pub static AV_CODEC_ID_VMNC: c_uint = 90;
pub static AV_CODEC_ID_VP5: c_uint = 91;
pub static AV_CODEC_ID_VP6: c_uint = 92;
pub static AV_CODEC_ID_VP6F: c_uint = 93;
pub static AV_CODEC_ID_TARGA: c_uint = 94;
pub static AV_CODEC_ID_DSICINVIDEO: c_uint = 95;
pub static AV_CODEC_ID_TIERTEXSEQVIDEO: c_uint = 96;
pub static AV_CODEC_ID_TIFF: c_uint = 97;
pub static AV_CODEC_ID_GIF: c_uint = 98;
pub static AV_CODEC_ID_DXA: c_uint = 99;
pub static AV_CODEC_ID_DNXHD: c_uint = 100;
pub static AV_CODEC_ID_THP: c_uint = 101;
pub static AV_CODEC_ID_SGI: c_uint = 102;
pub static AV_CODEC_ID_C93: c_uint = 103;
pub static AV_CODEC_ID_BETHSOFTVID: c_uint = 104;
pub static AV_CODEC_ID_PTX: c_uint = 105;
pub static AV_CODEC_ID_TXD: c_uint = 106;
pub static AV_CODEC_ID_VP6A: c_uint = 107;
pub static AV_CODEC_ID_AMV: c_uint = 108;
pub static AV_CODEC_ID_VB: c_uint = 109;
pub static AV_CODEC_ID_PCX: c_uint = 110;
pub static AV_CODEC_ID_SUNRAST: c_uint = 111;
pub static AV_CODEC_ID_INDEO4: c_uint = 112;
pub static AV_CODEC_ID_INDEO5: c_uint = 113;
pub static AV_CODEC_ID_MIMIC: c_uint = 114;
pub static AV_CODEC_ID_RL2: c_uint = 115;
pub static AV_CODEC_ID_ESCAPE124: c_uint = 116;
pub static AV_CODEC_ID_DIRAC: c_uint = 117;
pub static AV_CODEC_ID_BFI: c_uint = 118;
pub static AV_CODEC_ID_CMV: c_uint = 119;
pub static AV_CODEC_ID_MOTIONPIXELS: c_uint = 120;
pub static AV_CODEC_ID_TGV: c_uint = 121;
pub static AV_CODEC_ID_TGQ: c_uint = 122;
pub static AV_CODEC_ID_TQI: c_uint = 123;
pub static AV_CODEC_ID_AURA: c_uint = 124;
pub static AV_CODEC_ID_AURA2: c_uint = 125;
pub static AV_CODEC_ID_V210X: c_uint = 126;
pub static AV_CODEC_ID_TMV: c_uint = 127;
pub static AV_CODEC_ID_V210: c_uint = 128;
pub static AV_CODEC_ID_DPX: c_uint = 129;
pub static AV_CODEC_ID_MAD: c_uint = 130;
pub static AV_CODEC_ID_FRWU: c_uint = 131;
pub static AV_CODEC_ID_FLASHSV2: c_uint = 132;
pub static AV_CODEC_ID_CDGRAPHICS: c_uint = 133;
pub static AV_CODEC_ID_R210: c_uint = 134;
pub static AV_CODEC_ID_ANM: c_uint = 135;
pub static AV_CODEC_ID_BINKVIDEO: c_uint = 136;
pub static AV_CODEC_ID_IFF_ILBM: c_uint = 137;
pub static AV_CODEC_ID_IFF_BYTERUN1: c_uint = 138;
pub static AV_CODEC_ID_KGV1: c_uint = 139;
pub static AV_CODEC_ID_YOP: c_uint = 140;
pub static AV_CODEC_ID_VP8: c_uint = 141;
pub static AV_CODEC_ID_PICTOR: c_uint = 142;
pub static AV_CODEC_ID_ANSI: c_uint = 143;
pub static AV_CODEC_ID_A64_MULTI: c_uint = 144;
pub static AV_CODEC_ID_A64_MULTI5: c_uint = 145;
pub static AV_CODEC_ID_R10K: c_uint = 146;
pub static AV_CODEC_ID_MXPEG: c_uint = 147;
pub static AV_CODEC_ID_LAGARITH: c_uint = 148;
pub static AV_CODEC_ID_PRORES: c_uint = 149;
pub static AV_CODEC_ID_JV: c_uint = 150;
pub static AV_CODEC_ID_DFA: c_uint = 151;
pub static AV_CODEC_ID_WMV3IMAGE: c_uint = 152;
pub static AV_CODEC_ID_VC1IMAGE: c_uint = 153;
pub static AV_CODEC_ID_UTVIDEO: c_uint = 154;
pub static AV_CODEC_ID_BMV_VIDEO: c_uint = 155;
pub static AV_CODEC_ID_VBLE: c_uint = 156;
pub static AV_CODEC_ID_DXTORY: c_uint = 157;
pub static AV_CODEC_ID_V410: c_uint = 158;
pub static AV_CODEC_ID_XWD: c_uint = 159;
pub static AV_CODEC_ID_CDXL: c_uint = 160;
pub static AV_CODEC_ID_XBM: c_uint = 161;
pub static AV_CODEC_ID_ZEROCODEC: c_uint = 162;
pub static AV_CODEC_ID_MSS1: c_uint = 163;
pub static AV_CODEC_ID_MSA1: c_uint = 164;
pub static AV_CODEC_ID_TSCC2: c_uint = 165;
pub static AV_CODEC_ID_MTS2: c_uint = 166;
pub static AV_CODEC_ID_CLLC: c_uint = 167;
pub static AV_CODEC_ID_MSS2: c_uint = 168;
pub static AV_CODEC_ID_VP9: c_uint = 169;
pub static AV_CODEC_ID_AIC: c_uint = 170;
pub static AV_CODEC_ID_ESCAPE130_DEPRECATED: c_uint = 171;
pub static AV_CODEC_ID_G2M_DEPRECATED: c_uint = 172;
pub static AV_CODEC_ID_WEBP_DEPRECATED: c_uint = 173;
pub static AV_CODEC_ID_HNM4_VIDEO: c_uint = 174;
pub static AV_CODEC_ID_HEVC_DEPRECATED: c_uint = 175;
pub static AV_CODEC_ID_FIC: c_uint = 176;
pub static AV_CODEC_ID_BRENDER_PIX: c_uint = 1112557912;
pub static AV_CODEC_ID_Y41P: c_uint = 1496592720;
pub static AV_CODEC_ID_ESCAPE130: c_uint = 1160852272;
pub static AV_CODEC_ID_EXR: c_uint = 809850962;
pub static AV_CODEC_ID_AVRP: c_uint = 1096176208;
pub static AV_CODEC_ID_012V: c_uint = 808530518;
pub static AV_CODEC_ID_G2M: c_uint = 4665933;
pub static AV_CODEC_ID_AVUI: c_uint = 1096176969;
pub static AV_CODEC_ID_AYUV: c_uint = 1096373590;
pub static AV_CODEC_ID_TARGA_Y216: c_uint = 1412575542;
pub static AV_CODEC_ID_V308: c_uint = 1446195256;
pub static AV_CODEC_ID_V408: c_uint = 1446260792;
pub static AV_CODEC_ID_YUV4: c_uint = 1498764852;
pub static AV_CODEC_ID_SANM: c_uint = 1396788813;
pub static AV_CODEC_ID_PAF_VIDEO: c_uint = 1346455126;
pub static AV_CODEC_ID_AVRN: c_uint = 1096176238;
pub static AV_CODEC_ID_CPIA: c_uint = 1129335105;
pub static AV_CODEC_ID_XFACE: c_uint = 1480999235;
pub static AV_CODEC_ID_SGIRLE: c_uint = 1397180754;
pub static AV_CODEC_ID_MVC1: c_uint = 1297498929;
pub static AV_CODEC_ID_MVC2: c_uint = 1297498930;
pub static AV_CODEC_ID_SNOW: c_uint = 1397641047;
pub static AV_CODEC_ID_WEBP: c_uint = 1464156752;
pub static AV_CODEC_ID_SMVJPEG: c_uint = 1397577290;
pub static AV_CODEC_ID_HEVC: c_uint = 1211250229;
pub static AV_CODEC_ID_FIRST_AUDIO: c_uint = 65536;
pub static AV_CODEC_ID_PCM_S16LE: c_uint = 65536;
pub static AV_CODEC_ID_PCM_S16BE: c_uint = 65537;
pub static AV_CODEC_ID_PCM_U16LE: c_uint = 65538;
pub static AV_CODEC_ID_PCM_U16BE: c_uint = 65539;
pub static AV_CODEC_ID_PCM_S8: c_uint = 65540;
pub static AV_CODEC_ID_PCM_U8: c_uint = 65541;
pub static AV_CODEC_ID_PCM_MULAW: c_uint = 65542;
pub static AV_CODEC_ID_PCM_ALAW: c_uint = 65543;
pub static AV_CODEC_ID_PCM_S32LE: c_uint = 65544;
pub static AV_CODEC_ID_PCM_S32BE: c_uint = 65545;
pub static AV_CODEC_ID_PCM_U32LE: c_uint = 65546;
pub static AV_CODEC_ID_PCM_U32BE: c_uint = 65547;
pub static AV_CODEC_ID_PCM_S24LE: c_uint = 65548;
pub static AV_CODEC_ID_PCM_S24BE: c_uint = 65549;
pub static AV_CODEC_ID_PCM_U24LE: c_uint = 65550;
pub static AV_CODEC_ID_PCM_U24BE: c_uint = 65551;
pub static AV_CODEC_ID_PCM_S24DAUD: c_uint = 65552;
pub static AV_CODEC_ID_PCM_ZORK: c_uint = 65553;
pub static AV_CODEC_ID_PCM_S16LE_PLANAR: c_uint = 65554;
pub static AV_CODEC_ID_PCM_DVD: c_uint = 65555;
pub static AV_CODEC_ID_PCM_F32BE: c_uint = 65556;
pub static AV_CODEC_ID_PCM_F32LE: c_uint = 65557;
pub static AV_CODEC_ID_PCM_F64BE: c_uint = 65558;
pub static AV_CODEC_ID_PCM_F64LE: c_uint = 65559;
pub static AV_CODEC_ID_PCM_BLURAY: c_uint = 65560;
pub static AV_CODEC_ID_PCM_LXF: c_uint = 65561;
pub static AV_CODEC_ID_S302M: c_uint = 65562;
pub static AV_CODEC_ID_PCM_S8_PLANAR: c_uint = 65563;
pub static AV_CODEC_ID_PCM_S24LE_PLANAR_DEPRECATED: c_uint = 65564;
pub static AV_CODEC_ID_PCM_S32LE_PLANAR_DEPRECATED: c_uint = 65565;
pub static AV_CODEC_ID_PCM_S24LE_PLANAR: c_uint = 407917392;
pub static AV_CODEC_ID_PCM_S32LE_PLANAR: c_uint = 542135120;
pub static AV_CODEC_ID_PCM_S16BE_PLANAR: c_uint = 1347637264;
pub static AV_CODEC_ID_ADPCM_IMA_QT: c_uint = 69632;
pub static AV_CODEC_ID_ADPCM_IMA_WAV: c_uint = 69633;
pub static AV_CODEC_ID_ADPCM_IMA_DK3: c_uint = 69634;
pub static AV_CODEC_ID_ADPCM_IMA_DK4: c_uint = 69635;
pub static AV_CODEC_ID_ADPCM_IMA_WS: c_uint = 69636;
pub static AV_CODEC_ID_ADPCM_IMA_SMJPEG: c_uint = 69637;
pub static AV_CODEC_ID_ADPCM_MS: c_uint = 69638;
pub static AV_CODEC_ID_ADPCM_4XM: c_uint = 69639;
pub static AV_CODEC_ID_ADPCM_XA: c_uint = 69640;
pub static AV_CODEC_ID_ADPCM_ADX: c_uint = 69641;
pub static AV_CODEC_ID_ADPCM_EA: c_uint = 69642;
pub static AV_CODEC_ID_ADPCM_G726: c_uint = 69643;
pub static AV_CODEC_ID_ADPCM_CT: c_uint = 69644;
pub static AV_CODEC_ID_ADPCM_SWF: c_uint = 69645;
pub static AV_CODEC_ID_ADPCM_YAMAHA: c_uint = 69646;
pub static AV_CODEC_ID_ADPCM_SBPRO_4: c_uint = 69647;
pub static AV_CODEC_ID_ADPCM_SBPRO_3: c_uint = 69648;
pub static AV_CODEC_ID_ADPCM_SBPRO_2: c_uint = 69649;
pub static AV_CODEC_ID_ADPCM_THP: c_uint = 69650;
pub static AV_CODEC_ID_ADPCM_IMA_AMV: c_uint = 69651;
pub static AV_CODEC_ID_ADPCM_EA_R1: c_uint = 69652;
pub static AV_CODEC_ID_ADPCM_EA_R3: c_uint = 69653;
pub static AV_CODEC_ID_ADPCM_EA_R2: c_uint = 69654;
pub static AV_CODEC_ID_ADPCM_IMA_EA_SEAD: c_uint = 69655;
pub static AV_CODEC_ID_ADPCM_IMA_EA_EACS: c_uint = 69656;
pub static AV_CODEC_ID_ADPCM_EA_XAS: c_uint = 69657;
pub static AV_CODEC_ID_ADPCM_EA_MAXIS_XA: c_uint = 69658;
pub static AV_CODEC_ID_ADPCM_IMA_ISS: c_uint = 69659;
pub static AV_CODEC_ID_ADPCM_G722: c_uint = 69660;
pub static AV_CODEC_ID_ADPCM_IMA_APC: c_uint = 69661;
pub static AV_CODEC_ID_VIMA: c_uint = 1447644481;
pub static AV_CODEC_ID_ADPCM_AFC: c_uint = 1095123744;
pub static AV_CODEC_ID_ADPCM_IMA_OKI: c_uint = 1330333984;
pub static AV_CODEC_ID_ADPCM_DTK: c_uint = 1146374944;
pub static AV_CODEC_ID_ADPCM_IMA_RAD: c_uint = 1380008992;
pub static AV_CODEC_ID_ADPCM_G726LE: c_uint = 909260615;
pub static AV_CODEC_ID_AMR_NB: c_uint = 73728;
pub static AV_CODEC_ID_AMR_WB: c_uint = 73729;
pub static AV_CODEC_ID_RA_144: c_uint = 77824;
pub static AV_CODEC_ID_RA_288: c_uint = 77825;
pub static AV_CODEC_ID_ROQ_DPCM: c_uint = 81920;
pub static AV_CODEC_ID_INTERPLAY_DPCM: c_uint = 81921;
pub static AV_CODEC_ID_XAN_DPCM: c_uint = 81922;
pub static AV_CODEC_ID_SOL_DPCM: c_uint = 81923;
pub static AV_CODEC_ID_MP2: c_uint = 86016;
pub static AV_CODEC_ID_MP3: c_uint = 86017;
pub static AV_CODEC_ID_AAC: c_uint = 86018;
pub static AV_CODEC_ID_AC3: c_uint = 86019;
pub static AV_CODEC_ID_DTS: c_uint = 86020;
pub static AV_CODEC_ID_VORBIS: c_uint = 86021;
pub static AV_CODEC_ID_DVAUDIO: c_uint = 86022;
pub static AV_CODEC_ID_WMAV1: c_uint = 86023;
pub static AV_CODEC_ID_WMAV2: c_uint = 86024;
pub static AV_CODEC_ID_MACE3: c_uint = 86025;
pub static AV_CODEC_ID_MACE6: c_uint = 86026;
pub static AV_CODEC_ID_VMDAUDIO: c_uint = 86027;
pub static AV_CODEC_ID_FLAC: c_uint = 86028;
pub static AV_CODEC_ID_MP3ADU: c_uint = 86029;
pub static AV_CODEC_ID_MP3ON4: c_uint = 86030;
pub static AV_CODEC_ID_SHORTEN: c_uint = 86031;
pub static AV_CODEC_ID_ALAC: c_uint = 86032;
pub static AV_CODEC_ID_WESTWOOD_SND1: c_uint = 86033;
pub static AV_CODEC_ID_GSM: c_uint = 86034;
pub static AV_CODEC_ID_QDM2: c_uint = 86035;
pub static AV_CODEC_ID_COOK: c_uint = 86036;
pub static AV_CODEC_ID_TRUESPEECH: c_uint = 86037;
pub static AV_CODEC_ID_TTA: c_uint = 86038;
pub static AV_CODEC_ID_SMACKAUDIO: c_uint = 86039;
pub static AV_CODEC_ID_QCELP: c_uint = 86040;
pub static AV_CODEC_ID_WAVPACK: c_uint = 86041;
pub static AV_CODEC_ID_DSICINAUDIO: c_uint = 86042;
pub static AV_CODEC_ID_IMC: c_uint = 86043;
pub static AV_CODEC_ID_MUSEPACK7: c_uint = 86044;
pub static AV_CODEC_ID_MLP: c_uint = 86045;
pub static AV_CODEC_ID_GSM_MS: c_uint = 86046;
pub static AV_CODEC_ID_ATRAC3: c_uint = 86047;
pub static AV_CODEC_ID_VOXWARE: c_uint = 86048;
pub static AV_CODEC_ID_APE: c_uint = 86049;
pub static AV_CODEC_ID_NELLYMOSER: c_uint = 86050;
pub static AV_CODEC_ID_MUSEPACK8: c_uint = 86051;
pub static AV_CODEC_ID_SPEEX: c_uint = 86052;
pub static AV_CODEC_ID_WMAVOICE: c_uint = 86053;
pub static AV_CODEC_ID_WMAPRO: c_uint = 86054;
pub static AV_CODEC_ID_WMALOSSLESS: c_uint = 86055;
pub static AV_CODEC_ID_ATRAC3P: c_uint = 86056;
pub static AV_CODEC_ID_EAC3: c_uint = 86057;
pub static AV_CODEC_ID_SIPR: c_uint = 86058;
pub static AV_CODEC_ID_MP1: c_uint = 86059;
pub static AV_CODEC_ID_TWINVQ: c_uint = 86060;
pub static AV_CODEC_ID_TRUEHD: c_uint = 86061;
pub static AV_CODEC_ID_MP4ALS: c_uint = 86062;
pub static AV_CODEC_ID_ATRAC1: c_uint = 86063;
pub static AV_CODEC_ID_BINKAUDIO_RDFT: c_uint = 86064;
pub static AV_CODEC_ID_BINKAUDIO_DCT: c_uint = 86065;
pub static AV_CODEC_ID_AAC_LATM: c_uint = 86066;
pub static AV_CODEC_ID_QDMC: c_uint = 86067;
pub static AV_CODEC_ID_CELT: c_uint = 86068;
pub static AV_CODEC_ID_G723_1: c_uint = 86069;
pub static AV_CODEC_ID_G729: c_uint = 86070;
pub static AV_CODEC_ID_8SVX_EXP: c_uint = 86071;
pub static AV_CODEC_ID_8SVX_FIB: c_uint = 86072;
pub static AV_CODEC_ID_BMV_AUDIO: c_uint = 86073;
pub static AV_CODEC_ID_RALF: c_uint = 86074;
pub static AV_CODEC_ID_IAC: c_uint = 86075;
pub static AV_CODEC_ID_ILBC: c_uint = 86076;
pub static AV_CODEC_ID_OPUS_DEPRECATED: c_uint = 86077;
pub static AV_CODEC_ID_COMFORT_NOISE: c_uint = 86078;
pub static AV_CODEC_ID_TAK_DEPRECATED: c_uint = 86079;
pub static AV_CODEC_ID_METASOUND: c_uint = 86080;
pub static AV_CODEC_ID_FFWAVESYNTH: c_uint = 1179014995;
pub static AV_CODEC_ID_SONIC: c_uint = 1397706307;
pub static AV_CODEC_ID_SONIC_LS: c_uint = 1397706316;
pub static AV_CODEC_ID_PAF_AUDIO: c_uint = 1346455105;
pub static AV_CODEC_ID_OPUS: c_uint = 1330664787;
pub static AV_CODEC_ID_TAK: c_uint = 1950507339;
pub static AV_CODEC_ID_EVRC: c_uint = 1936029283;
pub static AV_CODEC_ID_SMV: c_uint = 1936944502;
pub static AV_CODEC_ID_FIRST_SUBTITLE: c_uint = 94208;
pub static AV_CODEC_ID_DVD_SUBTITLE: c_uint = 94208;
pub static AV_CODEC_ID_DVB_SUBTITLE: c_uint = 94209;
pub static AV_CODEC_ID_TEXT: c_uint = 94210;
pub static AV_CODEC_ID_XSUB: c_uint = 94211;
pub static AV_CODEC_ID_SSA: c_uint = 94212;
pub static AV_CODEC_ID_MOV_TEXT: c_uint = 94213;
pub static AV_CODEC_ID_HDMV_PGS_SUBTITLE: c_uint = 94214;
pub static AV_CODEC_ID_DVB_TELETEXT: c_uint = 94215;
pub static AV_CODEC_ID_SRT: c_uint = 94216;
pub static AV_CODEC_ID_MICRODVD: c_uint = 1833195076;
pub static AV_CODEC_ID_EIA_608: c_uint = 1664495672;
pub static AV_CODEC_ID_JACOSUB: c_uint = 1246975298;
pub static AV_CODEC_ID_SAMI: c_uint = 1396788553;
pub static AV_CODEC_ID_REALTEXT: c_uint = 1381259348;
pub static AV_CODEC_ID_SUBVIEWER1: c_uint = 1398953521;
pub static AV_CODEC_ID_SUBVIEWER: c_uint = 1400201814;
pub static AV_CODEC_ID_SUBRIP: c_uint = 1397909872;
pub static AV_CODEC_ID_WEBVTT: c_uint = 1465275476;
pub static AV_CODEC_ID_MPL2: c_uint = 1297108018;
pub static AV_CODEC_ID_VPLAYER: c_uint = 1448111218;
pub static AV_CODEC_ID_PJS: c_uint = 1349012051;
pub static AV_CODEC_ID_ASS: c_uint = 1095979808;
pub static AV_CODEC_ID_FIRST_UNKNOWN: c_uint = 98304;
pub static AV_CODEC_ID_TTF: c_uint = 98304;
pub static AV_CODEC_ID_BINTEXT: c_uint = 1112823892;
pub static AV_CODEC_ID_XBIN: c_uint = 1480739150;
pub static AV_CODEC_ID_IDF: c_uint = 4801606;
pub static AV_CODEC_ID_OTF: c_uint = 5198918;
pub static AV_CODEC_ID_SMPTE_KLV: c_uint = 1263294017;
pub static AV_CODEC_ID_DVD_NAV: c_uint = 1145979222;
pub static AV_CODEC_ID_TIMED_ID3: c_uint = 1414087731;
pub static AV_CODEC_ID_PROBE: c_uint = 102400;
pub static AV_CODEC_ID_MPEG2TS: c_uint = 131072;
pub static AV_CODEC_ID_MPEG4SYSTEMS: c_uint = 131073;
pub static AV_CODEC_ID_FFMETADATA: c_uint = 135168;
pub static CODEC_ID_NONE: c_uint = 0;
pub static CODEC_ID_MPEG1VIDEO: c_uint = 1;
pub static CODEC_ID_MPEG2VIDEO: c_uint = 2;
pub static CODEC_ID_MPEG2VIDEO_XVMC: c_uint = 3;
pub static CODEC_ID_H261: c_uint = 4;
pub static CODEC_ID_H263: c_uint = 5;
pub static CODEC_ID_RV10: c_uint = 6;
pub static CODEC_ID_RV20: c_uint = 7;
pub static CODEC_ID_MJPEG: c_uint = 8;
pub static CODEC_ID_MJPEGB: c_uint = 9;
pub static CODEC_ID_LJPEG: c_uint = 10;
pub static CODEC_ID_SP5X: c_uint = 11;
pub static CODEC_ID_JPEGLS: c_uint = 12;
pub static CODEC_ID_MPEG4: c_uint = 13;
pub static CODEC_ID_RAWVIDEO: c_uint = 14;
pub static CODEC_ID_MSMPEG4V1: c_uint = 15;
pub static CODEC_ID_MSMPEG4V2: c_uint = 16;
pub static CODEC_ID_MSMPEG4V3: c_uint = 17;
pub static CODEC_ID_WMV1: c_uint = 18;
pub static CODEC_ID_WMV2: c_uint = 19;
pub static CODEC_ID_H263P: c_uint = 20;
pub static CODEC_ID_H263I: c_uint = 21;
pub static CODEC_ID_FLV1: c_uint = 22;
pub static CODEC_ID_SVQ1: c_uint = 23;
pub static CODEC_ID_SVQ3: c_uint = 24;
pub static CODEC_ID_DVVIDEO: c_uint = 25;
pub static CODEC_ID_HUFFYUV: c_uint = 26;
pub static CODEC_ID_CYUV: c_uint = 27;
pub static CODEC_ID_H264: c_uint = 28;
pub static CODEC_ID_INDEO3: c_uint = 29;
pub static CODEC_ID_VP3: c_uint = 30;
pub static CODEC_ID_THEORA: c_uint = 31;
pub static CODEC_ID_ASV1: c_uint = 32;
pub static CODEC_ID_ASV2: c_uint = 33;
pub static CODEC_ID_FFV1: c_uint = 34;
pub static CODEC_ID_4XM: c_uint = 35;
pub static CODEC_ID_VCR1: c_uint = 36;
pub static CODEC_ID_CLJR: c_uint = 37;
pub static CODEC_ID_MDEC: c_uint = 38;
pub static CODEC_ID_ROQ: c_uint = 39;
pub static CODEC_ID_INTERPLAY_VIDEO: c_uint = 40;
pub static CODEC_ID_XAN_WC3: c_uint = 41;
pub static CODEC_ID_XAN_WC4: c_uint = 42;
pub static CODEC_ID_RPZA: c_uint = 43;
pub static CODEC_ID_CINEPAK: c_uint = 44;
pub static CODEC_ID_WS_VQA: c_uint = 45;
pub static CODEC_ID_MSRLE: c_uint = 46;
pub static CODEC_ID_MSVIDEO1: c_uint = 47;
pub static CODEC_ID_IDCIN: c_uint = 48;
pub static CODEC_ID_8BPS: c_uint = 49;
pub static CODEC_ID_SMC: c_uint = 50;
pub static CODEC_ID_FLIC: c_uint = 51;
pub static CODEC_ID_TRUEMOTION1: c_uint = 52;
pub static CODEC_ID_VMDVIDEO: c_uint = 53;
pub static CODEC_ID_MSZH: c_uint = 54;
pub static CODEC_ID_ZLIB: c_uint = 55;
pub static CODEC_ID_QTRLE: c_uint = 56;
pub static CODEC_ID_TSCC: c_uint = 57;
pub static CODEC_ID_ULTI: c_uint = 58;
pub static CODEC_ID_QDRAW: c_uint = 59;
pub static CODEC_ID_VIXL: c_uint = 60;
pub static CODEC_ID_QPEG: c_uint = 61;
pub static CODEC_ID_PNG: c_uint = 62;
pub static CODEC_ID_PPM: c_uint = 63;
pub static CODEC_ID_PBM: c_uint = 64;
pub static CODEC_ID_PGM: c_uint = 65;
pub static CODEC_ID_PGMYUV: c_uint = 66;
pub static CODEC_ID_PAM: c_uint = 67;
pub static CODEC_ID_FFVHUFF: c_uint = 68;
pub static CODEC_ID_RV30: c_uint = 69;
pub static CODEC_ID_RV40: c_uint = 70;
pub static CODEC_ID_VC1: c_uint = 71;
pub static CODEC_ID_WMV3: c_uint = 72;
pub static CODEC_ID_LOCO: c_uint = 73;
pub static CODEC_ID_WNV1: c_uint = 74;
pub static CODEC_ID_AASC: c_uint = 75;
pub static CODEC_ID_INDEO2: c_uint = 76;
pub static CODEC_ID_FRAPS: c_uint = 77;
pub static CODEC_ID_TRUEMOTION2: c_uint = 78;
pub static CODEC_ID_BMP: c_uint = 79;
pub static CODEC_ID_CSCD: c_uint = 80;
pub static CODEC_ID_MMVIDEO: c_uint = 81;
pub static CODEC_ID_ZMBV: c_uint = 82;
pub static CODEC_ID_AVS: c_uint = 83;
pub static CODEC_ID_SMACKVIDEO: c_uint = 84;
pub static CODEC_ID_NUV: c_uint = 85;
pub static CODEC_ID_KMVC: c_uint = 86;
pub static CODEC_ID_FLASHSV: c_uint = 87;
pub static CODEC_ID_CAVS: c_uint = 88;
pub static CODEC_ID_JPEG2000: c_uint = 89;
pub static CODEC_ID_VMNC: c_uint = 90;
pub static CODEC_ID_VP5: c_uint = 91;
pub static CODEC_ID_VP6: c_uint = 92;
pub static CODEC_ID_VP6F: c_uint = 93;
pub static CODEC_ID_TARGA: c_uint = 94;
pub static CODEC_ID_DSICINVIDEO: c_uint = 95;
pub static CODEC_ID_TIERTEXSEQVIDEO: c_uint = 96;
pub static CODEC_ID_TIFF: c_uint = 97;
pub static CODEC_ID_GIF: c_uint = 98;
pub static CODEC_ID_DXA: c_uint = 99;
pub static CODEC_ID_DNXHD: c_uint = 100;
pub static CODEC_ID_THP: c_uint = 101;
pub static CODEC_ID_SGI: c_uint = 102;
pub static CODEC_ID_C93: c_uint = 103;
pub static CODEC_ID_BETHSOFTVID: c_uint = 104;
pub static CODEC_ID_PTX: c_uint = 105;
pub static CODEC_ID_TXD: c_uint = 106;
pub static CODEC_ID_VP6A: c_uint = 107;
pub static CODEC_ID_AMV: c_uint = 108;
pub static CODEC_ID_VB: c_uint = 109;
pub static CODEC_ID_PCX: c_uint = 110;
pub static CODEC_ID_SUNRAST: c_uint = 111;
pub static CODEC_ID_INDEO4: c_uint = 112;
pub static CODEC_ID_INDEO5: c_uint = 113;
pub static CODEC_ID_MIMIC: c_uint = 114;
pub static CODEC_ID_RL2: c_uint = 115;
pub static CODEC_ID_ESCAPE124: c_uint = 116;
pub static CODEC_ID_DIRAC: c_uint = 117;
pub static CODEC_ID_BFI: c_uint = 118;
pub static CODEC_ID_CMV: c_uint = 119;
pub static CODEC_ID_MOTIONPIXELS: c_uint = 120;
pub static CODEC_ID_TGV: c_uint = 121;
pub static CODEC_ID_TGQ: c_uint = 122;
pub static CODEC_ID_TQI: c_uint = 123;
pub static CODEC_ID_AURA: c_uint = 124;
pub static CODEC_ID_AURA2: c_uint = 125;
pub static CODEC_ID_V210X: c_uint = 126;
pub static CODEC_ID_TMV: c_uint = 127;
pub static CODEC_ID_V210: c_uint = 128;
pub static CODEC_ID_DPX: c_uint = 129;
pub static CODEC_ID_MAD: c_uint = 130;
pub static CODEC_ID_FRWU: c_uint = 131;
pub static CODEC_ID_FLASHSV2: c_uint = 132;
pub static CODEC_ID_CDGRAPHICS: c_uint = 133;
pub static CODEC_ID_R210: c_uint = 134;
pub static CODEC_ID_ANM: c_uint = 135;
pub static CODEC_ID_BINKVIDEO: c_uint = 136;
pub static CODEC_ID_IFF_ILBM: c_uint = 137;
pub static CODEC_ID_IFF_BYTERUN1: c_uint = 138;
pub static CODEC_ID_KGV1: c_uint = 139;
pub static CODEC_ID_YOP: c_uint = 140;
pub static CODEC_ID_VP8: c_uint = 141;
pub static CODEC_ID_PICTOR: c_uint = 142;
pub static CODEC_ID_ANSI: c_uint = 143;
pub static CODEC_ID_A64_MULTI: c_uint = 144;
pub static CODEC_ID_A64_MULTI5: c_uint = 145;
pub static CODEC_ID_R10K: c_uint = 146;
pub static CODEC_ID_MXPEG: c_uint = 147;
pub static CODEC_ID_LAGARITH: c_uint = 148;
pub static CODEC_ID_PRORES: c_uint = 149;
pub static CODEC_ID_JV: c_uint = 150;
pub static CODEC_ID_DFA: c_uint = 151;
pub static CODEC_ID_WMV3IMAGE: c_uint = 152;
pub static CODEC_ID_VC1IMAGE: c_uint = 153;
pub static CODEC_ID_UTVIDEO: c_uint = 154;
pub static CODEC_ID_BMV_VIDEO: c_uint = 155;
pub static CODEC_ID_VBLE: c_uint = 156;
pub static CODEC_ID_DXTORY: c_uint = 157;
pub static CODEC_ID_V410: c_uint = 158;
pub static CODEC_ID_XWD: c_uint = 159;
pub static CODEC_ID_CDXL: c_uint = 160;
pub static CODEC_ID_XBM: c_uint = 161;
pub static CODEC_ID_ZEROCODEC: c_uint = 162;
pub static CODEC_ID_MSS1: c_uint = 163;
pub static CODEC_ID_MSA1: c_uint = 164;
pub static CODEC_ID_TSCC2: c_uint = 165;
pub static CODEC_ID_MTS2: c_uint = 166;
pub static CODEC_ID_CLLC: c_uint = 167;
pub static CODEC_ID_Y41P: c_uint = 1496592720;
pub static CODEC_ID_ESCAPE130: c_uint = 1160852272;
pub static CODEC_ID_EXR: c_uint = 809850962;
pub static CODEC_ID_AVRP: c_uint = 1096176208;
pub static CODEC_ID_G2M: c_uint = 4665933;
pub static CODEC_ID_AVUI: c_uint = 1096176969;
pub static CODEC_ID_AYUV: c_uint = 1096373590;
pub static CODEC_ID_V308: c_uint = 1446195256;
pub static CODEC_ID_V408: c_uint = 1446260792;
pub static CODEC_ID_YUV4: c_uint = 1498764852;
pub static CODEC_ID_SANM: c_uint = 1396788813;
pub static CODEC_ID_PAF_VIDEO: c_uint = 1346455126;
pub static CODEC_ID_SNOW: c_uint = 1397641047;
pub static CODEC_ID_FIRST_AUDIO: c_uint = 65536;
pub static CODEC_ID_PCM_S16LE: c_uint = 65536;
pub static CODEC_ID_PCM_S16BE: c_uint = 65537;
pub static CODEC_ID_PCM_U16LE: c_uint = 65538;
pub static CODEC_ID_PCM_U16BE: c_uint = 65539;
pub static CODEC_ID_PCM_S8: c_uint = 65540;
pub static CODEC_ID_PCM_U8: c_uint = 65541;
pub static CODEC_ID_PCM_MULAW: c_uint = 65542;
pub static CODEC_ID_PCM_ALAW: c_uint = 65543;
pub static CODEC_ID_PCM_S32LE: c_uint = 65544;
pub static CODEC_ID_PCM_S32BE: c_uint = 65545;
pub static CODEC_ID_PCM_U32LE: c_uint = 65546;
pub static CODEC_ID_PCM_U32BE: c_uint = 65547;
pub static CODEC_ID_PCM_S24LE: c_uint = 65548;
pub static CODEC_ID_PCM_S24BE: c_uint = 65549;
pub static CODEC_ID_PCM_U24LE: c_uint = 65550;
pub static CODEC_ID_PCM_U24BE: c_uint = 65551;
pub static CODEC_ID_PCM_S24DAUD: c_uint = 65552;
pub static CODEC_ID_PCM_ZORK: c_uint = 65553;
pub static CODEC_ID_PCM_S16LE_PLANAR: c_uint = 65554;
pub static CODEC_ID_PCM_DVD: c_uint = 65555;
pub static CODEC_ID_PCM_F32BE: c_uint = 65556;
pub static CODEC_ID_PCM_F32LE: c_uint = 65557;
pub static CODEC_ID_PCM_F64BE: c_uint = 65558;
pub static CODEC_ID_PCM_F64LE: c_uint = 65559;
pub static CODEC_ID_PCM_BLURAY: c_uint = 65560;
pub static CODEC_ID_PCM_LXF: c_uint = 65561;
pub static CODEC_ID_S302M: c_uint = 65562;
pub static CODEC_ID_PCM_S8_PLANAR: c_uint = 65563;
pub static CODEC_ID_ADPCM_IMA_QT: c_uint = 69632;
pub static CODEC_ID_ADPCM_IMA_WAV: c_uint = 69633;
pub static CODEC_ID_ADPCM_IMA_DK3: c_uint = 69634;
pub static CODEC_ID_ADPCM_IMA_DK4: c_uint = 69635;
pub static CODEC_ID_ADPCM_IMA_WS: c_uint = 69636;
pub static CODEC_ID_ADPCM_IMA_SMJPEG: c_uint = 69637;
pub static CODEC_ID_ADPCM_MS: c_uint = 69638;
pub static CODEC_ID_ADPCM_4XM: c_uint = 69639;
pub static CODEC_ID_ADPCM_XA: c_uint = 69640;
pub static CODEC_ID_ADPCM_ADX: c_uint = 69641;
pub static CODEC_ID_ADPCM_EA: c_uint = 69642;
pub static CODEC_ID_ADPCM_G726: c_uint = 69643;
pub static CODEC_ID_ADPCM_CT: c_uint = 69644;
pub static CODEC_ID_ADPCM_SWF: c_uint = 69645;
pub static CODEC_ID_ADPCM_YAMAHA: c_uint = 69646;
pub static CODEC_ID_ADPCM_SBPRO_4: c_uint = 69647;
pub static CODEC_ID_ADPCM_SBPRO_3: c_uint = 69648;
pub static CODEC_ID_ADPCM_SBPRO_2: c_uint = 69649;
pub static CODEC_ID_ADPCM_THP: c_uint = 69650;
pub static CODEC_ID_ADPCM_IMA_AMV: c_uint = 69651;
pub static CODEC_ID_ADPCM_EA_R1: c_uint = 69652;
pub static CODEC_ID_ADPCM_EA_R3: c_uint = 69653;
pub static CODEC_ID_ADPCM_EA_R2: c_uint = 69654;
pub static CODEC_ID_ADPCM_IMA_EA_SEAD: c_uint = 69655;
pub static CODEC_ID_ADPCM_IMA_EA_EACS: c_uint = 69656;
pub static CODEC_ID_ADPCM_EA_XAS: c_uint = 69657;
pub static CODEC_ID_ADPCM_EA_MAXIS_XA: c_uint = 69658;
pub static CODEC_ID_ADPCM_IMA_ISS: c_uint = 69659;
pub static CODEC_ID_ADPCM_G722: c_uint = 69660;
pub static CODEC_ID_ADPCM_IMA_APC: c_uint = 69661;
pub static CODEC_ID_VIMA: c_uint = 1447644481;
pub static CODEC_ID_AMR_NB: c_uint = 73728;
pub static CODEC_ID_AMR_WB: c_uint = 73729;
pub static CODEC_ID_RA_144: c_uint = 77824;
pub static CODEC_ID_RA_288: c_uint = 77825;
pub static CODEC_ID_ROQ_DPCM: c_uint = 81920;
pub static CODEC_ID_INTERPLAY_DPCM: c_uint = 81921;
pub static CODEC_ID_XAN_DPCM: c_uint = 81922;
pub static CODEC_ID_SOL_DPCM: c_uint = 81923;
pub static CODEC_ID_MP2: c_uint = 86016;
pub static CODEC_ID_MP3: c_uint = 86017;
pub static CODEC_ID_AAC: c_uint = 86018;
pub static CODEC_ID_AC3: c_uint = 86019;
pub static CODEC_ID_DTS: c_uint = 86020;
pub static CODEC_ID_VORBIS: c_uint = 86021;
pub static CODEC_ID_DVAUDIO: c_uint = 86022;
pub static CODEC_ID_WMAV1: c_uint = 86023;
pub static CODEC_ID_WMAV2: c_uint = 86024;
pub static CODEC_ID_MACE3: c_uint = 86025;
pub static CODEC_ID_MACE6: c_uint = 86026;
pub static CODEC_ID_VMDAUDIO: c_uint = 86027;
pub static CODEC_ID_FLAC: c_uint = 86028;
pub static CODEC_ID_MP3ADU: c_uint = 86029;
pub static CODEC_ID_MP3ON4: c_uint = 86030;
pub static CODEC_ID_SHORTEN: c_uint = 86031;
pub static CODEC_ID_ALAC: c_uint = 86032;
pub static CODEC_ID_WESTWOOD_SND1: c_uint = 86033;
pub static CODEC_ID_GSM: c_uint = 86034;
pub static CODEC_ID_QDM2: c_uint = 86035;
pub static CODEC_ID_COOK: c_uint = 86036;
pub static CODEC_ID_TRUESPEECH: c_uint = 86037;
pub static CODEC_ID_TTA: c_uint = 86038;
pub static CODEC_ID_SMACKAUDIO: c_uint = 86039;
pub static CODEC_ID_QCELP: c_uint = 86040;
pub static CODEC_ID_WAVPACK: c_uint = 86041;
pub static CODEC_ID_DSICINAUDIO: c_uint = 86042;
pub static CODEC_ID_IMC: c_uint = 86043;
pub static CODEC_ID_MUSEPACK7: c_uint = 86044;
pub static CODEC_ID_MLP: c_uint = 86045;
pub static CODEC_ID_GSM_MS: c_uint = 86046;
pub static CODEC_ID_ATRAC3: c_uint = 86047;
pub static CODEC_ID_VOXWARE: c_uint = 86048;
pub static CODEC_ID_APE: c_uint = 86049;
pub static CODEC_ID_NELLYMOSER: c_uint = 86050;
pub static CODEC_ID_MUSEPACK8: c_uint = 86051;
pub static CODEC_ID_SPEEX: c_uint = 86052;
pub static CODEC_ID_WMAVOICE: c_uint = 86053;
pub static CODEC_ID_WMAPRO: c_uint = 86054;
pub static CODEC_ID_WMALOSSLESS: c_uint = 86055;
pub static CODEC_ID_ATRAC3P: c_uint = 86056;
pub static CODEC_ID_EAC3: c_uint = 86057;
pub static CODEC_ID_SIPR: c_uint = 86058;
pub static CODEC_ID_MP1: c_uint = 86059;
pub static CODEC_ID_TWINVQ: c_uint = 86060;
pub static CODEC_ID_TRUEHD: c_uint = 86061;
pub static CODEC_ID_MP4ALS: c_uint = 86062;
pub static CODEC_ID_ATRAC1: c_uint = 86063;
pub static CODEC_ID_BINKAUDIO_RDFT: c_uint = 86064;
pub static CODEC_ID_BINKAUDIO_DCT: c_uint = 86065;
pub static CODEC_ID_AAC_LATM: c_uint = 86066;
pub static CODEC_ID_QDMC: c_uint = 86067;
pub static CODEC_ID_CELT: c_uint = 86068;
pub static CODEC_ID_G723_1: c_uint = 86069;
pub static CODEC_ID_G729: c_uint = 86070;
pub static CODEC_ID_8SVX_EXP: c_uint = 86071;
pub static CODEC_ID_8SVX_FIB: c_uint = 86072;
pub static CODEC_ID_BMV_AUDIO: c_uint = 86073;
pub static CODEC_ID_RALF: c_uint = 86074;
pub static CODEC_ID_IAC: c_uint = 86075;
pub static CODEC_ID_ILBC: c_uint = 86076;
pub static CODEC_ID_FFWAVESYNTH: c_uint = 1179014995;
pub static CODEC_ID_SONIC: c_uint = 1397706307;
pub static CODEC_ID_SONIC_LS: c_uint = 1397706316;
pub static CODEC_ID_PAF_AUDIO: c_uint = 1346455105;
pub static CODEC_ID_OPUS: c_uint = 1330664787;
pub static CODEC_ID_FIRST_SUBTITLE: c_uint = 94208;
pub static CODEC_ID_DVD_SUBTITLE: c_uint = 94208;
pub static CODEC_ID_DVB_SUBTITLE: c_uint = 94209;
pub static CODEC_ID_TEXT: c_uint = 94210;
pub static CODEC_ID_XSUB: c_uint = 94211;
pub static CODEC_ID_SSA: c_uint = 94212;
pub static CODEC_ID_MOV_TEXT: c_uint = 94213;
pub static CODEC_ID_HDMV_PGS_SUBTITLE: c_uint = 94214;
pub static CODEC_ID_DVB_TELETEXT: c_uint = 94215;
pub static CODEC_ID_SRT: c_uint = 94216;
pub static CODEC_ID_MICRODVD: c_uint = 1833195076;
pub static CODEC_ID_EIA_608: c_uint = 1664495672;
pub static CODEC_ID_JACOSUB: c_uint = 1246975298;
pub static CODEC_ID_SAMI: c_uint = 1396788553;
pub static CODEC_ID_REALTEXT: c_uint = 1381259348;
pub static CODEC_ID_SUBVIEWER: c_uint = 1400201814;
pub static CODEC_ID_FIRST_UNKNOWN: c_uint = 98304;
pub static CODEC_ID_TTF: c_uint = 98304;
pub static CODEC_ID_BINTEXT: c_uint = 1112823892;
pub static CODEC_ID_XBIN: c_uint = 1480739150;
pub static CODEC_ID_IDF: c_uint = 4801606;
pub static CODEC_ID_OTF: c_uint = 5198918;
pub static CODEC_ID_PROBE: c_uint = 102400;
pub static CODEC_ID_MPEG2TS: c_uint = 131072;
pub static CODEC_ID_MPEG4SYSTEMS: c_uint = 131073;
pub static CODEC_ID_FFMETADATA: c_uint = 135168;
pub struct Struct_AVCodecDescriptor {
    pub id: Enum_AVCodecID,
    pub _type: Enum_AVMediaType,
    pub name: *c_schar,
    pub long_name: *c_schar,
    pub props: c_int,
}
pub type AVCodecDescriptor = Struct_AVCodecDescriptor;
pub type Enum_Motion_Est_ID = c_uint;
pub static ME_ZERO: c_uint = 1;
pub static ME_FULL: c_uint = 2;
pub static ME_LOG: c_uint = 3;
pub static ME_PHODS: c_uint = 4;
pub static ME_EPZS: c_uint = 5;
pub static ME_X1: c_uint = 6;
pub static ME_HEX: c_uint = 7;
pub static ME_UMH: c_uint = 8;
pub static ME_TESA: c_uint = 9;
pub static ME_ITER: c_uint = 50;
pub type Enum_AVDiscard = c_int;
pub static AVDISCARD_NONE: c_int = -16;
pub static AVDISCARD_DEFAULT: c_int = 0;
pub static AVDISCARD_NONREF: c_int = 8;
pub static AVDISCARD_BIDIR: c_int = 16;
pub static AVDISCARD_NONKEY: c_int = 32;
pub static AVDISCARD_ALL: c_int = 48;
pub type Enum_AVColorPrimaries = c_uint;
pub static AVCOL_PRI_BT709: c_uint = 1;
pub static AVCOL_PRI_UNSPECIFIED: c_uint = 2;
pub static AVCOL_PRI_BT470M: c_uint = 4;
pub static AVCOL_PRI_BT470BG: c_uint = 5;
pub static AVCOL_PRI_SMPTE170M: c_uint = 6;
pub static AVCOL_PRI_SMPTE240M: c_uint = 7;
pub static AVCOL_PRI_FILM: c_uint = 8;
pub static AVCOL_PRI_BT2020: c_uint = 9;
pub static AVCOL_PRI_NB: c_uint = 10;
pub type Enum_AVColorTransferCharacteristic = c_uint;
pub static AVCOL_TRC_BT709: c_uint = 1;
pub static AVCOL_TRC_UNSPECIFIED: c_uint = 2;
pub static AVCOL_TRC_GAMMA22: c_uint = 4;
pub static AVCOL_TRC_GAMMA28: c_uint = 5;
pub static AVCOL_TRC_SMPTE170M: c_uint = 6;
pub static AVCOL_TRC_SMPTE240M: c_uint = 7;
pub static AVCOL_TRC_LINEAR: c_uint = 8;
pub static AVCOL_TRC_LOG: c_uint = 9;
pub static AVCOL_TRC_LOG_SQRT: c_uint = 10;
pub static AVCOL_TRC_IEC61966_2_4: c_uint = 11;
pub static AVCOL_TRC_BT1361_ECG: c_uint = 12;
pub static AVCOL_TRC_IEC61966_2_1: c_uint = 13;
pub static AVCOL_TRC_BT2020_10: c_uint = 14;
pub static AVCOL_TRC_BT2020_12: c_uint = 15;
pub static AVCOL_TRC_NB: c_uint = 16;
pub type Enum_AVChromaLocation = c_uint;
pub static AVCHROMA_LOC_UNSPECIFIED: c_uint = 0;
pub static AVCHROMA_LOC_LEFT: c_uint = 1;
pub static AVCHROMA_LOC_CENTER: c_uint = 2;
pub static AVCHROMA_LOC_TOPLEFT: c_uint = 3;
pub static AVCHROMA_LOC_TOP: c_uint = 4;
pub static AVCHROMA_LOC_BOTTOMLEFT: c_uint = 5;
pub static AVCHROMA_LOC_BOTTOM: c_uint = 6;
pub static AVCHROMA_LOC_NB: c_uint = 7;
pub type Enum_AVAudioServiceType = c_uint;
pub static AV_AUDIO_SERVICE_TYPE_MAIN: c_uint = 0;
pub static AV_AUDIO_SERVICE_TYPE_EFFECTS: c_uint = 1;
pub static AV_AUDIO_SERVICE_TYPE_VISUALLY_IMPAIRED: c_uint = 2;
pub static AV_AUDIO_SERVICE_TYPE_HEARING_IMPAIRED: c_uint = 3;
pub static AV_AUDIO_SERVICE_TYPE_DIALOGUE: c_uint = 4;
pub static AV_AUDIO_SERVICE_TYPE_COMMENTARY: c_uint = 5;
pub static AV_AUDIO_SERVICE_TYPE_EMERGENCY: c_uint = 6;
pub static AV_AUDIO_SERVICE_TYPE_VOICE_OVER: c_uint = 7;
pub static AV_AUDIO_SERVICE_TYPE_KARAOKE: c_uint = 8;
pub static AV_AUDIO_SERVICE_TYPE_NB: c_uint = 9;
pub struct Struct_RcOverride {
    pub start_frame: c_int,
    pub end_frame: c_int,
    pub qscale: c_int,
    pub quality_factor: c_float,
}
pub type RcOverride = Struct_RcOverride;
pub struct Struct_AVPanScan {
    pub id: c_int,
    pub width: c_int,
    pub height: c_int,
    pub position: [[int16_t, ..2u], ..3u],
}
pub type AVPanScan = Struct_AVPanScan;
pub type Enum_AVPacketSideDataType = c_uint;
pub static AV_PKT_DATA_PALETTE: c_uint = 0;
pub static AV_PKT_DATA_NEW_EXTRADATA: c_uint = 1;
pub static AV_PKT_DATA_PARAM_CHANGE: c_uint = 2;
pub static AV_PKT_DATA_H263_MB_INFO: c_uint = 3;
pub static AV_PKT_DATA_SKIP_SAMPLES: c_uint = 70;
pub static AV_PKT_DATA_JP_DUALMONO: c_uint = 71;
pub static AV_PKT_DATA_STRINGS_METADATA: c_uint = 72;
pub static AV_PKT_DATA_SUBTITLE_POSITION: c_uint = 73;
pub static AV_PKT_DATA_MATROSKA_BLOCKADDITIONAL: c_uint = 74;
pub static AV_PKT_DATA_WEBVTT_IDENTIFIER: c_uint = 75;
pub static AV_PKT_DATA_WEBVTT_SETTINGS: c_uint = 76;
pub static AV_PKT_DATA_METADATA_UPDATE: c_uint = 77;
pub struct Struct_AVPacket {
    pub buf: *mut AVBufferRef,
    pub pts: int64_t,
    pub dts: int64_t,
    pub data: *mut uint8_t,
    pub size: c_int,
    pub stream_index: c_int,
    pub flags: c_int,
    pub side_data: *mut Struct_Unnamed7,
    pub side_data_elems: c_int,
    pub duration: c_int,
    pub destruct: ::std::option::Option<extern "C" fn
                                            (arg1: *mut Struct_AVPacket)>,
    pub _priv: *mut c_void,
    pub pos: int64_t,
    pub convergence_duration: int64_t,
}
pub struct Struct_Unnamed7 {
    pub data: *mut uint8_t,
    pub size: c_int,
    pub _type: Enum_AVPacketSideDataType,
}
pub type AVPacket = Struct_AVPacket;
pub type Enum_AVSideDataParamChangeFlags = c_uint;
pub static AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_COUNT: c_uint = 1;
pub static AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_LAYOUT: c_uint = 2;
pub static AV_SIDE_DATA_PARAM_CHANGE_SAMPLE_RATE: c_uint = 4;
pub static AV_SIDE_DATA_PARAM_CHANGE_DIMENSIONS: c_uint = 8;
pub type Struct_AVCodecInternal = c_void;
pub type Enum_AVFieldOrder = c_uint;
pub static AV_FIELD_UNKNOWN: c_uint = 0;
pub static AV_FIELD_PROGRESSIVE: c_uint = 1;
pub static AV_FIELD_TT: c_uint = 2;
pub static AV_FIELD_BB: c_uint = 3;
pub static AV_FIELD_TB: c_uint = 4;
pub static AV_FIELD_BT: c_uint = 5;
pub struct Struct_AVCodecContext {
    pub av_class: *AVClass,
    pub log_level_offset: c_int,
    pub codec_type: Enum_AVMediaType,
    pub codec: *Struct_AVCodec,
    pub codec_name: [c_schar, ..32u],
    pub codec_id: Enum_AVCodecID,
    pub codec_tag: c_uint,
    pub stream_codec_tag: c_uint,
    pub priv_data: *mut c_void,
    pub internal: *mut Struct_AVCodecInternal,
    pub opaque: *mut c_void,
    pub bit_rate: c_int,
    pub bit_rate_tolerance: c_int,
    pub global_quality: c_int,
    pub compression_level: c_int,
    pub flags: c_int,
    pub flags2: c_int,
    pub extradata: *mut uint8_t,
    pub extradata_size: c_int,
    pub time_base: AVRational,
    pub ticks_per_frame: c_int,
    pub delay: c_int,
    pub width: c_int,
    pub height: c_int,
    pub coded_width: c_int,
    pub coded_height: c_int,
    pub gop_size: c_int,
    pub pix_fmt: Enum_AVPixelFormat,
    pub me_method: c_int,
    pub draw_horiz_band: ::std::option::Option<extern "C" fn
                                                   (arg1:
                                                        *mut Struct_AVCodecContext,
                                                    arg2: *AVFrame,
                                                    arg3: [c_int, ..8u],
                                                    arg4: c_int, arg5: c_int,
                                                    arg6: c_int)>,
    pub get_format: ::std::option::Option<extern "C" fn
                                              (arg1:
                                                   *mut Struct_AVCodecContext,
                                               arg2: *Enum_AVPixelFormat)
                                              -> Enum_AVPixelFormat>,
    pub max_b_frames: c_int,
    pub b_quant_factor: c_float,
    pub rc_strategy: c_int,
    pub b_frame_strategy: c_int,
    pub b_quant_offset: c_float,
    pub has_b_frames: c_int,
    pub mpeg_quant: c_int,
    pub i_quant_factor: c_float,
    pub i_quant_offset: c_float,
    pub lumi_masking: c_float,
    pub temporal_cplx_masking: c_float,
    pub spatial_cplx_masking: c_float,
    pub p_masking: c_float,
    pub dark_masking: c_float,
    pub slice_count: c_int,
    pub prediction_method: c_int,
    pub slice_offset: *mut c_int,
    pub sample_aspect_ratio: AVRational,
    pub me_cmp: c_int,
    pub me_sub_cmp: c_int,
    pub mb_cmp: c_int,
    pub ildct_cmp: c_int,
    pub dia_size: c_int,
    pub last_predictor_count: c_int,
    pub pre_me: c_int,
    pub me_pre_cmp: c_int,
    pub pre_dia_size: c_int,
    pub me_subpel_quality: c_int,
    pub dtg_active_format: c_int,
    pub me_range: c_int,
    pub intra_quant_bias: c_int,
    pub inter_quant_bias: c_int,
    pub slice_flags: c_int,
    pub xvmc_acceleration: c_int,
    pub mb_decision: c_int,
    pub intra_matrix: *mut uint16_t,
    pub inter_matrix: *mut uint16_t,
    pub scenechange_threshold: c_int,
    pub noise_reduction: c_int,
    pub me_threshold: c_int,
    pub mb_threshold: c_int,
    pub intra_dc_precision: c_int,
    pub skip_top: c_int,
    pub skip_bottom: c_int,
    pub border_masking: c_float,
    pub mb_lmin: c_int,
    pub mb_lmax: c_int,
    pub me_penalty_compensation: c_int,
    pub bidir_refine: c_int,
    pub brd_scale: c_int,
    pub keyint_min: c_int,
    pub refs: c_int,
    pub chromaoffset: c_int,
    pub scenechange_factor: c_int,
    pub mv0_threshold: c_int,
    pub b_sensitivity: c_int,
    pub color_primaries: Enum_AVColorPrimaries,
    pub color_trc: Enum_AVColorTransferCharacteristic,
    pub colorspace: Enum_AVColorSpace,
    pub color_range: Enum_AVColorRange,
    pub chroma_sample_location: Enum_AVChromaLocation,
    pub slices: c_int,
    pub field_order: Enum_AVFieldOrder,
    pub sample_rate: c_int,
    pub channels: c_int,
    pub sample_fmt: Enum_AVSampleFormat,
    pub frame_size: c_int,
    pub frame_number: c_int,
    pub block_align: c_int,
    pub cutoff: c_int,
    pub request_channels: c_int,
    pub channel_layout: uint64_t,
    pub request_channel_layout: uint64_t,
    pub audio_service_type: Enum_AVAudioServiceType,
    pub request_sample_fmt: Enum_AVSampleFormat,
    pub get_buffer: ::std::option::Option<extern "C" fn
                                              (arg1:
                                                   *mut Struct_AVCodecContext,
                                               arg2: *mut AVFrame) -> c_int>,
    pub release_buffer: ::std::option::Option<extern "C" fn
                                                  (arg1:
                                                       *mut Struct_AVCodecContext,
                                                   arg2: *mut AVFrame)>,
    pub reget_buffer: ::std::option::Option<extern "C" fn
                                                (arg1:
                                                     *mut Struct_AVCodecContext,
                                                 arg2: *mut AVFrame)
                                                -> c_int>,
    pub get_buffer2: ::std::option::Option<extern "C" fn
                                               (arg1:
                                                    *mut Struct_AVCodecContext,
                                                arg2: *mut AVFrame,
                                                arg3: c_int) -> c_int>,
    pub refcounted_frames: c_int,
    pub qcompress: c_float,
    pub qblur: c_float,
    pub qmin: c_int,
    pub qmax: c_int,
    pub max_qdiff: c_int,
    pub rc_qsquish: c_float,
    pub rc_qmod_amp: c_float,
    pub rc_qmod_freq: c_int,
    pub rc_buffer_size: c_int,
    pub rc_override_count: c_int,
    pub rc_override: *mut RcOverride,
    pub rc_eq: *c_schar,
    pub rc_max_rate: c_int,
    pub rc_min_rate: c_int,
    pub rc_buffer_aggressivity: c_float,
    pub rc_initial_cplx: c_float,
    pub rc_max_available_vbv_use: c_float,
    pub rc_min_vbv_overflow_use: c_float,
    pub rc_initial_buffer_occupancy: c_int,
    pub coder_type: c_int,
    pub context_model: c_int,
    pub lmin: c_int,
    pub lmax: c_int,
    pub frame_skip_threshold: c_int,
    pub frame_skip_factor: c_int,
    pub frame_skip_exp: c_int,
    pub frame_skip_cmp: c_int,
    pub trellis: c_int,
    pub min_prediction_order: c_int,
    pub max_prediction_order: c_int,
    pub timecode_frame_start: int64_t,
    pub rtp_callback: ::std::option::Option<extern "C" fn
                                                (arg1:
                                                     *mut Struct_AVCodecContext,
                                                 arg2: *mut c_void,
                                                 arg3: c_int, arg4: c_int)>,
    pub rtp_payload_size: c_int,
    pub mv_bits: c_int,
    pub header_bits: c_int,
    pub i_tex_bits: c_int,
    pub p_tex_bits: c_int,
    pub i_count: c_int,
    pub p_count: c_int,
    pub skip_count: c_int,
    pub misc_bits: c_int,
    pub frame_bits: c_int,
    pub stats_out: *mut c_schar,
    pub stats_in: *mut c_schar,
    pub workaround_bugs: c_int,
    pub strict_std_compliance: c_int,
    pub error_concealment: c_int,
    pub debug: c_int,
    pub debug_mv: c_int,
    pub err_recognition: c_int,
    pub reordered_opaque: int64_t,
    pub hwaccel: *mut Struct_AVHWAccel,
    pub hwaccel_context: *mut c_void,
    pub error: [uint64_t, ..8u],
    pub dct_algo: c_int,
    pub idct_algo: c_int,
    pub bits_per_coded_sample: c_int,
    pub bits_per_raw_sample: c_int,
    pub lowres: c_int,
    pub coded_frame: *mut AVFrame,
    pub thread_count: c_int,
    pub thread_type: c_int,
    pub active_thread_type: c_int,
    pub thread_safe_callbacks: c_int,
    pub execute: ::std::option::Option<extern "C" fn
                                           (arg1: *mut Struct_AVCodecContext,
                                            arg2:
                                                ::std::option::Option<extern "C" fn
                                                                          (arg1:
                                                                               *mut Struct_AVCodecContext,
                                                                           arg2:
                                                                               *mut c_void)
                                                                          ->
                                                                              c_int>,
                                            arg3: *mut c_void,
                                            arg4: *mut c_int, arg5: c_int,
                                            arg6: c_int) -> c_int>,
    pub execute2: ::std::option::Option<extern "C" fn
                                            (arg1: *mut Struct_AVCodecContext,
                                             arg2:
                                                 ::std::option::Option<extern "C" fn
                                                                           (arg1:
                                                                                *mut Struct_AVCodecContext,
                                                                            arg2:
                                                                                *mut c_void,
                                                                            arg3:
                                                                                c_int,
                                                                            arg4:
                                                                                c_int)
                                                                           ->
                                                                               c_int>,
                                             arg3: *mut c_void,
                                             arg4: *mut c_int, arg5: c_int)
                                            -> c_int>,
    pub thread_opaque: *mut c_void,
    pub nsse_weight: c_int,
    pub profile: c_int,
    pub level: c_int,
    pub skip_loop_filter: Enum_AVDiscard,
    pub skip_idct: Enum_AVDiscard,
    pub skip_frame: Enum_AVDiscard,
    pub subtitle_header: *mut uint8_t,
    pub subtitle_header_size: c_int,
    pub error_rate: c_int,
    pub pkt: *mut AVPacket,
    pub vbv_delay: uint64_t,
    pub pkt_timebase: AVRational,
    pub codec_descriptor: *AVCodecDescriptor,
    pub pts_correction_num_faulty_pts: int64_t,
    pub pts_correction_num_faulty_dts: int64_t,
    pub pts_correction_last_pts: int64_t,
    pub pts_correction_last_dts: int64_t,
    pub sub_charenc: *mut c_schar,
    pub sub_charenc_mode: c_int,
    pub skip_alpha: c_int,
    pub seek_preroll: c_int,
    pub chroma_intra_matrix: *mut uint16_t,
}
pub type AVCodecContext = Struct_AVCodecContext;
pub struct Struct_AVProfile {
    pub profile: c_int,
    pub name: *c_schar,
}
pub type AVProfile = Struct_AVProfile;
pub type Struct_AVCodecDefault = c_void;
pub type AVCodecDefault = Struct_AVCodecDefault;
pub struct Struct_AVCodec {
    pub name: *c_schar,
    pub long_name: *c_schar,
    pub _type: Enum_AVMediaType,
    pub id: Enum_AVCodecID,
    pub capabilities: c_int,
    pub supported_framerates: *AVRational,
    pub pix_fmts: *Enum_AVPixelFormat,
    pub supported_samplerates: *c_int,
    pub sample_fmts: *Enum_AVSampleFormat,
    pub channel_layouts: *uint64_t,
    pub max_lowres: uint8_t,
    pub priv_class: *AVClass,
    pub profiles: *AVProfile,
    pub priv_data_size: c_int,
    pub next: *mut Struct_AVCodec,
    pub init_thread_copy: ::std::option::Option<extern "C" fn
                                                    (arg1:
                                                         *mut AVCodecContext)
                                                    -> c_int>,
    pub update_thread_context: ::std::option::Option<extern "C" fn
                                                         (arg1:
                                                              *mut AVCodecContext,
                                                          arg2:
                                                              *AVCodecContext)
                                                         -> c_int>,
    pub defaults: *AVCodecDefault,
    pub init_static_data: ::std::option::Option<extern "C" fn
                                                    (arg1:
                                                         *mut Struct_AVCodec)>,
    pub init: ::std::option::Option<extern "C" fn(arg1: *mut AVCodecContext)
                                        -> c_int>,
    pub encode_sub: ::std::option::Option<extern "C" fn
                                              (arg1: *mut AVCodecContext,
                                               arg2: *mut uint8_t,
                                               arg3: c_int,
                                               arg4: *Struct_AVSubtitle)
                                              -> c_int>,
    pub encode2: ::std::option::Option<extern "C" fn
                                           (arg1: *mut AVCodecContext,
                                            arg2: *mut AVPacket,
                                            arg3: *AVFrame, arg4: *mut c_int)
                                           -> c_int>,
    pub decode: ::std::option::Option<extern "C" fn
                                          (arg1: *mut AVCodecContext,
                                           arg2: *mut c_void,
                                           arg3: *mut c_int,
                                           arg4: *mut AVPacket) -> c_int>,
    pub close: ::std::option::Option<extern "C" fn(arg1: *mut AVCodecContext)
                                         -> c_int>,
    pub flush: ::std::option::Option<extern "C" fn
                                         (arg1: *mut AVCodecContext)>,
}
pub type AVCodec = Struct_AVCodec;
pub type Struct_MpegEncContext = c_void;
pub struct Struct_AVHWAccel {
    pub name: *c_schar,
    pub _type: Enum_AVMediaType,
    pub id: Enum_AVCodecID,
    pub pix_fmt: Enum_AVPixelFormat,
    pub capabilities: c_int,
    pub next: *mut Struct_AVHWAccel,
    pub start_frame: ::std::option::Option<extern "C" fn
                                               (arg1: *mut AVCodecContext,
                                                arg2: *uint8_t,
                                                arg3: uint32_t) -> c_int>,
    pub decode_slice: ::std::option::Option<extern "C" fn
                                                (arg1: *mut AVCodecContext,
                                                 arg2: *uint8_t,
                                                 arg3: uint32_t) -> c_int>,
    pub end_frame: ::std::option::Option<extern "C" fn
                                             (arg1: *mut AVCodecContext)
                                             -> c_int>,
    pub priv_data_size: c_int,
    pub decode_mb: ::std::option::Option<extern "C" fn
                                             (arg1:
                                                  *mut Struct_MpegEncContext)>,
}
pub type AVHWAccel = Struct_AVHWAccel;
pub struct Struct_AVPicture {
    pub data: [*mut uint8_t, ..8u],
    pub linesize: [c_int, ..8u],
}
pub type AVPicture = Struct_AVPicture;
pub type Enum_AVSubtitleType = c_uint;
pub static SUBTITLE_NONE: c_uint = 0;
pub static SUBTITLE_BITMAP: c_uint = 1;
pub static SUBTITLE_TEXT: c_uint = 2;
pub static SUBTITLE_ASS: c_uint = 3;
pub struct Struct_AVSubtitleRect {
    pub x: c_int,
    pub y: c_int,
    pub w: c_int,
    pub h: c_int,
    pub nb_colors: c_int,
    pub pict: AVPicture,
    pub _type: Enum_AVSubtitleType,
    pub text: *mut c_schar,
    pub ass: *mut c_schar,
    pub flags: c_int,
}
pub type AVSubtitleRect = Struct_AVSubtitleRect;
pub struct Struct_AVSubtitle {
    pub format: uint16_t,
    pub start_display_time: uint32_t,
    pub end_display_time: uint32_t,
    pub num_rects: c_uint,
    pub rects: *mut *mut AVSubtitleRect,
    pub pts: int64_t,
}
pub type AVSubtitle = Struct_AVSubtitle;
pub type Enum_AVPictureStructure = c_uint;
pub static AV_PICTURE_STRUCTURE_UNKNOWN: c_uint = 0;
pub static AV_PICTURE_STRUCTURE_TOP_FIELD: c_uint = 1;
pub static AV_PICTURE_STRUCTURE_BOTTOM_FIELD: c_uint = 2;
pub static AV_PICTURE_STRUCTURE_FRAME: c_uint = 3;
pub struct Struct_AVCodecParserContext {
    pub priv_data: *mut c_void,
    pub parser: *mut Struct_AVCodecParser,
    pub frame_offset: int64_t,
    pub cur_offset: int64_t,
    pub next_frame_offset: int64_t,
    pub pict_type: c_int,
    pub repeat_pict: c_int,
    pub pts: int64_t,
    pub dts: int64_t,
    pub last_pts: int64_t,
    pub last_dts: int64_t,
    pub fetch_timestamp: c_int,
    pub cur_frame_start_index: c_int,
    pub cur_frame_offset: [int64_t, ..4u],
    pub cur_frame_pts: [int64_t, ..4u],
    pub cur_frame_dts: [int64_t, ..4u],
    pub flags: c_int,
    pub offset: int64_t,
    pub cur_frame_end: [int64_t, ..4u],
    pub key_frame: c_int,
    pub convergence_duration: int64_t,
    pub dts_sync_point: c_int,
    pub dts_ref_dts_delta: c_int,
    pub pts_dts_delta: c_int,
    pub cur_frame_pos: [int64_t, ..4u],
    pub pos: int64_t,
    pub last_pos: int64_t,
    pub duration: c_int,
    pub field_order: Enum_AVFieldOrder,
    pub picture_structure: Enum_AVPictureStructure,
    pub output_picture_number: c_int,
}
pub type AVCodecParserContext = Struct_AVCodecParserContext;
pub struct Struct_AVCodecParser {
    pub codec_ids: [c_int, ..5u],
    pub priv_data_size: c_int,
    pub parser_init: ::std::option::Option<extern "C" fn
                                               (arg1:
                                                    *mut AVCodecParserContext)
                                               -> c_int>,
    pub parser_parse: ::std::option::Option<extern "C" fn
                                                (arg1:
                                                     *mut AVCodecParserContext,
                                                 arg2: *mut AVCodecContext,
                                                 arg3: *mut *uint8_t,
                                                 arg4: *mut c_int,
                                                 arg5: *uint8_t, arg6: c_int)
                                                -> c_int>,
    pub parser_close: ::std::option::Option<extern "C" fn
                                                (arg1:
                                                     *mut AVCodecParserContext)>,
    pub split: ::std::option::Option<extern "C" fn
                                         (arg1: *mut AVCodecContext,
                                          arg2: *uint8_t, arg3: c_int)
                                         -> c_int>,
    pub next: *mut Struct_AVCodecParser,
}
pub type AVCodecParser = Struct_AVCodecParser;
pub type Struct_ReSampleContext = c_void;
pub type Struct_AVResampleContext = c_void;
pub type ReSampleContext = Struct_ReSampleContext;
pub struct Struct_AVBitStreamFilterContext {
    pub priv_data: *mut c_void,
    pub filter: *mut Struct_AVBitStreamFilter,
    pub parser: *mut AVCodecParserContext,
    pub next: *mut Struct_AVBitStreamFilterContext,
}
pub type AVBitStreamFilterContext = Struct_AVBitStreamFilterContext;
pub struct Struct_AVBitStreamFilter {
    pub name: *c_schar,
    pub priv_data_size: c_int,
    pub filter: ::std::option::Option<extern "C" fn
                                          (arg1:
                                               *mut AVBitStreamFilterContext,
                                           arg2: *mut AVCodecContext,
                                           arg3: *c_schar,
                                           arg4: *mut *mut uint8_t,
                                           arg5: *mut c_int, arg6: *uint8_t,
                                           arg7: c_int, arg8: c_int)
                                          -> c_int>,
    pub close: ::std::option::Option<extern "C" fn
                                         (arg1:
                                              *mut AVBitStreamFilterContext)>,
    pub next: *mut Struct_AVBitStreamFilter,
}
pub type AVBitStreamFilter = Struct_AVBitStreamFilter;
pub type Enum_AVLockOp = c_uint;
pub static AV_LOCK_CREATE: c_uint = 0;
pub static AV_LOCK_OBTAIN: c_uint = 1;
pub static AV_LOCK_RELEASE: c_uint = 2;
pub static AV_LOCK_DESTROY: c_uint = 3;
pub struct Struct_tm {
    pub tm_sec: c_int,
    pub tm_min: c_int,
    pub tm_hour: c_int,
    pub tm_mday: c_int,
    pub tm_mon: c_int,
    pub tm_year: c_int,
    pub tm_wday: c_int,
    pub tm_yday: c_int,
    pub tm_isdst: c_int,
    pub tm_gmtoff: c_long,
    pub tm_zone: *c_schar,
}
pub struct Struct_itimerspec {
    pub it_interval: Struct_timespec,
    pub it_value: Struct_timespec,
}
pub type Struct_sigevent = c_void;
pub struct Struct_AVIOInterruptCB {
    pub callback: ::std::option::Option<extern "C" fn(arg1: *mut c_void)
                                            -> c_int>,
    pub opaque: *mut c_void,
}
pub type AVIOInterruptCB = Struct_AVIOInterruptCB;
pub struct Struct_AVIOContext {
    pub av_class: *AVClass,
    pub buffer: *mut c_uchar,
    pub buffer_size: c_int,
    pub buf_ptr: *mut c_uchar,
    pub buf_end: *mut c_uchar,
    pub opaque: *mut c_void,
    pub read_packet: ::std::option::Option<extern "C" fn
                                               (arg1: *mut c_void,
                                                arg2: *mut uint8_t,
                                                arg3: c_int) -> c_int>,
    pub write_packet: ::std::option::Option<extern "C" fn
                                                (arg1: *mut c_void,
                                                 arg2: *mut uint8_t,
                                                 arg3: c_int) -> c_int>,
    pub seek: ::std::option::Option<extern "C" fn
                                        (arg1: *mut c_void, arg2: int64_t,
                                         arg3: c_int) -> int64_t>,
    pub pos: int64_t,
    pub must_flush: c_int,
    pub eof_reached: c_int,
    pub write_flag: c_int,
    pub max_packet_size: c_int,
    pub checksum: c_ulong,
    pub checksum_ptr: *mut c_uchar,
    pub update_checksum: ::std::option::Option<extern "C" fn
                                                   (arg1: c_ulong,
                                                    arg2: *uint8_t,
                                                    arg3: c_uint) -> c_ulong>,
    pub error: c_int,
    pub read_pause: ::std::option::Option<extern "C" fn
                                              (arg1: *mut c_void, arg2: c_int)
                                              -> c_int>,
    pub read_seek: ::std::option::Option<extern "C" fn
                                             (arg1: *mut c_void, arg2: c_int,
                                              arg3: int64_t, arg4: c_int)
                                             -> int64_t>,
    pub seekable: c_int,
    pub maxsize: int64_t,
    pub direct: c_int,
    pub bytes_read: int64_t,
    pub seek_count: c_int,
    pub writeout_count: c_int,
}
pub type AVIOContext = Struct_AVIOContext;
pub type Struct_AVDeviceInfoList = c_void;
pub struct Struct_AVFrac {
    pub val: int64_t,
    pub num: int64_t,
    pub den: int64_t,
}
pub type AVFrac = Struct_AVFrac;
pub type Struct_AVCodecTag = c_void;
pub struct Struct_AVProbeData {
    pub filename: *c_schar,
    pub buf: *mut c_uchar,
    pub buf_size: c_int,
}
pub type AVProbeData = Struct_AVProbeData;
pub struct Struct_AVOutputFormat {
    pub name: *c_schar,
    pub long_name: *c_schar,
    pub mime_type: *c_schar,
    pub extensions: *c_schar,
    pub audio_codec: Enum_AVCodecID,
    pub video_codec: Enum_AVCodecID,
    pub subtitle_codec: Enum_AVCodecID,
    pub flags: c_int,
    pub codec_tag: **Struct_AVCodecTag,
    pub priv_class: *AVClass,
    pub next: *mut Struct_AVOutputFormat,
    pub priv_data_size: c_int,
    pub write_header: ::std::option::Option<extern "C" fn
                                                (arg1:
                                                     *mut Struct_AVFormatContext)
                                                -> c_int>,
    pub write_packet: ::std::option::Option<extern "C" fn
                                                (arg1:
                                                     *mut Struct_AVFormatContext,
                                                 arg2: *mut AVPacket)
                                                -> c_int>,
    pub write_trailer: ::std::option::Option<extern "C" fn
                                                 (arg1:
                                                      *mut Struct_AVFormatContext)
                                                 -> c_int>,
    pub interleave_packet: ::std::option::Option<extern "C" fn
                                                     (arg1:
                                                          *mut Struct_AVFormatContext,
                                                      arg2: *mut AVPacket,
                                                      arg3: *mut AVPacket,
                                                      arg4: c_int) -> c_int>,
    pub query_codec: ::std::option::Option<extern "C" fn
                                               (arg1: Enum_AVCodecID,
                                                arg2: c_int) -> c_int>,
    pub get_output_timestamp: ::std::option::Option<extern "C" fn
                                                        (arg1:
                                                             *mut Struct_AVFormatContext,
                                                         arg2: c_int,
                                                         arg3: *mut int64_t,
                                                         arg4: *mut int64_t)>,
    pub control_message: ::std::option::Option<extern "C" fn
                                                   (arg1:
                                                        *mut Struct_AVFormatContext,
                                                    arg2: c_int,
                                                    arg3: *mut c_void,
                                                    arg4: size_t) -> c_int>,
    pub write_uncoded_frame: ::std::option::Option<extern "C" fn
                                                       (arg1:
                                                            *mut Struct_AVFormatContext,
                                                        arg2: c_int,
                                                        arg3:
                                                            *mut *mut AVFrame,
                                                        arg4: c_uint)
                                                       -> c_int>,
    pub get_device_list: ::std::option::Option<extern "C" fn
                                                   (arg1:
                                                        *mut Struct_AVFormatContext,
                                                    arg2:
                                                        *mut Struct_AVDeviceInfoList)
                                                   -> c_int>,
}
pub type AVOutputFormat = Struct_AVOutputFormat;
pub struct Struct_AVInputFormat {
    pub name: *c_schar,
    pub long_name: *c_schar,
    pub flags: c_int,
    pub extensions: *c_schar,
    pub codec_tag: **Struct_AVCodecTag,
    pub priv_class: *AVClass,
    pub next: *mut Struct_AVInputFormat,
    pub raw_codec_id: c_int,
    pub priv_data_size: c_int,
    pub read_probe: ::std::option::Option<extern "C" fn
                                              (arg1: *mut AVProbeData)
                                              -> c_int>,
    pub read_header: ::std::option::Option<extern "C" fn
                                               (arg1:
                                                    *mut Struct_AVFormatContext)
                                               -> c_int>,
    pub read_packet: ::std::option::Option<extern "C" fn
                                               (arg1:
                                                    *mut Struct_AVFormatContext,
                                                arg2: *mut AVPacket)
                                               -> c_int>,
    pub read_close: ::std::option::Option<extern "C" fn
                                              (arg1:
                                                   *mut Struct_AVFormatContext)
                                              -> c_int>,
    pub read_seek: ::std::option::Option<extern "C" fn
                                             (arg1:
                                                  *mut Struct_AVFormatContext,
                                              arg2: c_int, arg3: int64_t,
                                              arg4: c_int) -> c_int>,
    pub read_timestamp: ::std::option::Option<extern "C" fn
                                                  (arg1:
                                                       *mut Struct_AVFormatContext,
                                                   arg2: c_int,
                                                   arg3: *mut int64_t,
                                                   arg4: int64_t) -> int64_t>,
    pub read_play: ::std::option::Option<extern "C" fn
                                             (arg1:
                                                  *mut Struct_AVFormatContext)
                                             -> c_int>,
    pub read_pause: ::std::option::Option<extern "C" fn
                                              (arg1:
                                                   *mut Struct_AVFormatContext)
                                              -> c_int>,
    pub read_seek2: ::std::option::Option<extern "C" fn
                                              (arg1:
                                                   *mut Struct_AVFormatContext,
                                               arg2: c_int, arg3: int64_t,
                                               arg4: int64_t, arg5: int64_t,
                                               arg6: c_int) -> c_int>,
    pub get_device_list: ::std::option::Option<extern "C" fn
                                                   (arg1:
                                                        *mut Struct_AVFormatContext,
                                                    arg2:
                                                        *mut Struct_AVDeviceInfoList)
                                                   -> c_int>,
}
pub type AVInputFormat = Struct_AVInputFormat;
pub type Enum_AVStreamParseType = c_uint;
pub static AVSTREAM_PARSE_NONE: c_uint = 0;
pub static AVSTREAM_PARSE_FULL: c_uint = 1;
pub static AVSTREAM_PARSE_HEADERS: c_uint = 2;
pub static AVSTREAM_PARSE_TIMESTAMPS: c_uint = 3;
pub static AVSTREAM_PARSE_FULL_ONCE: c_uint = 4;
pub static AVSTREAM_PARSE_FULL_RAW: c_uint = 1463898624;
pub struct Struct_AVIndexEntry {
    pub pos: int64_t,
    pub timestamp: int64_t,
    pub flags: c_int,
    pub size: c_int,
    pub min_distance: c_int,
}
pub type AVIndexEntry = Struct_AVIndexEntry;
pub struct Struct_AVStream {
    pub index: c_int,
    pub id: c_int,
    pub codec: *mut AVCodecContext,
    pub priv_data: *mut c_void,
    pub pts: Struct_AVFrac,
    pub time_base: AVRational,
    pub start_time: int64_t,
    pub duration: int64_t,
    pub nb_frames: int64_t,
    pub disposition: c_int,
    pub discard: Enum_AVDiscard,
    pub sample_aspect_ratio: AVRational,
    pub metadata: *mut AVDictionary,
    pub avg_frame_rate: AVRational,
    pub attached_pic: AVPacket,
    pub info: *mut Struct_Unnamed8,
    pub pts_wrap_bits: c_int,
    pub do_not_use: int64_t,
    pub first_dts: int64_t,
    pub cur_dts: int64_t,
    pub last_IP_pts: int64_t,
    pub last_IP_duration: c_int,
    pub probe_packets: c_int,
    pub codec_info_nb_frames: c_int,
    pub need_parsing: Enum_AVStreamParseType,
    pub parser: *mut Struct_AVCodecParserContext,
    pub last_in_packet_buffer: *mut Struct_AVPacketList,
    pub probe_data: AVProbeData,
    pub pts_buffer: [int64_t, ..17u],
    pub index_entries: *mut AVIndexEntry,
    pub nb_index_entries: c_int,
    pub index_entries_allocated_size: c_uint,
    pub r_frame_rate: AVRational,
    pub stream_identifier: c_int,
    pub interleaver_chunk_size: int64_t,
    pub interleaver_chunk_duration: int64_t,
    pub request_probe: c_int,
    pub skip_to_keyframe: c_int,
    pub skip_samples: c_int,
    pub nb_decoded_frames: c_int,
    pub mux_ts_offset: int64_t,
    pub pts_wrap_reference: int64_t,
    pub pts_wrap_behavior: c_int,
    pub update_initial_durations_done: c_int,
    pub pts_reorder_error: [int64_t, ..17u],
    pub pts_reorder_error_count: [uint8_t, ..17u],
    pub last_dts_for_order_check: int64_t,
    pub dts_ordered: uint8_t,
    pub dts_misordered: uint8_t,
}
pub struct Struct_Unnamed8 {
    pub last_dts: int64_t,
    pub duration_gcd: int64_t,
    pub duration_count: c_int,
    pub rfps_duration_sum: int64_t,
    pub duration_error: *mut c_void,
    pub codec_info_duration: int64_t,
    pub codec_info_duration_fields: int64_t,
    pub found_decoder: c_int,
    pub last_duration: int64_t,
    pub fps_first_dts: int64_t,
    pub fps_first_dts_idx: c_int,
    pub fps_last_dts: int64_t,
    pub fps_last_dts_idx: c_int,
}
pub type AVStream = Struct_AVStream;
pub struct Struct_AVProgram {
    pub id: c_int,
    pub flags: c_int,
    pub discard: Enum_AVDiscard,
    pub stream_index: *mut c_uint,
    pub nb_stream_indexes: c_uint,
    pub metadata: *mut AVDictionary,
    pub program_num: c_int,
    pub pmt_pid: c_int,
    pub pcr_pid: c_int,
    pub start_time: int64_t,
    pub end_time: int64_t,
    pub pts_wrap_reference: int64_t,
    pub pts_wrap_behavior: c_int,
}
pub type AVProgram = Struct_AVProgram;
pub struct Struct_AVChapter {
    pub id: c_int,
    pub time_base: AVRational,
    pub start: int64_t,
    pub end: int64_t,
    pub metadata: *mut AVDictionary,
}
pub type AVChapter = Struct_AVChapter;
pub type av_format_control_message =
    ::std::option::Option<extern "C" fn
                              (arg1: *mut Struct_AVFormatContext, arg2: c_int,
                               arg3: *mut c_void, arg4: size_t) -> c_int>;
pub type Enum_AVDurationEstimationMethod = c_uint;
pub static AVFMT_DURATION_FROM_PTS: c_uint = 0;
pub static AVFMT_DURATION_FROM_STREAM: c_uint = 1;
pub static AVFMT_DURATION_FROM_BITRATE: c_uint = 2;
pub type Struct_AVFormatInternal = c_void;
pub type AVFormatInternal = Struct_AVFormatInternal;
pub struct Struct_AVFormatContext {
    pub av_class: *AVClass,
    pub iformat: *mut Struct_AVInputFormat,
    pub oformat: *mut Struct_AVOutputFormat,
    pub priv_data: *mut c_void,
    pub pb: *mut AVIOContext,
    pub ctx_flags: c_int,
    pub nb_streams: c_uint,
    pub streams: *mut *mut AVStream,
    pub filename: [c_schar, ..1024u],
    pub start_time: int64_t,
    pub duration: int64_t,
    pub bit_rate: c_int,
    pub packet_size: c_uint,
    pub max_delay: c_int,
    pub flags: c_int,
    pub probesize: c_uint,
    pub max_analyze_duration: c_int,
    pub key: *uint8_t,
    pub keylen: c_int,
    pub nb_programs: c_uint,
    pub programs: *mut *mut AVProgram,
    pub video_codec_id: Enum_AVCodecID,
    pub audio_codec_id: Enum_AVCodecID,
    pub subtitle_codec_id: Enum_AVCodecID,
    pub max_index_size: c_uint,
    pub max_picture_buffer: c_uint,
    pub nb_chapters: c_uint,
    pub chapters: *mut *mut AVChapter,
    pub metadata: *mut AVDictionary,
    pub start_time_realtime: int64_t,
    pub fps_probe_size: c_int,
    pub error_recognition: c_int,
    pub interrupt_callback: AVIOInterruptCB,
    pub debug: c_int,
    pub max_interleave_delta: int64_t,
    pub ts_id: c_int,
    pub audio_preload: c_int,
    pub max_chunk_duration: c_int,
    pub max_chunk_size: c_int,
    pub use_wallclock_as_timestamps: c_int,
    pub avoid_negative_ts: c_int,
    pub avio_flags: c_int,
    pub duration_estimation_method: Enum_AVDurationEstimationMethod,
    pub skip_initial_bytes: c_uint,
    pub correct_ts_overflow: c_uint,
    pub seek2any: c_int,
    pub flush_packets: c_int,
    pub probe_score: c_int,
    pub packet_buffer: *mut Struct_AVPacketList,
    pub packet_buffer_end: *mut Struct_AVPacketList,
    pub data_offset: int64_t,
    pub raw_packet_buffer: *mut Struct_AVPacketList,
    pub raw_packet_buffer_end: *mut Struct_AVPacketList,
    pub parse_queue: *mut Struct_AVPacketList,
    pub parse_queue_end: *mut Struct_AVPacketList,
    pub raw_packet_buffer_remaining_size: c_int,
    pub offset: int64_t,
    pub offset_timebase: AVRational,
    pub internal: *mut AVFormatInternal,
    pub io_repositioned: c_int,
    pub video_codec: *mut AVCodec,
    pub audio_codec: *mut AVCodec,
    pub subtitle_codec: *mut AVCodec,
    pub metadata_header_padding: c_int,
    pub opaque: *mut c_void,
    pub control_message_cb: av_format_control_message,
    pub output_ts_offset: int64_t,
}
pub type AVFormatContext = Struct_AVFormatContext;
pub struct Struct_AVPacketList {
    pub pkt: AVPacket,
    pub next: *mut Struct_AVPacketList,
}
pub type AVPacketList = Struct_AVPacketList;
pub struct Struct_SwsVector {
    pub coeff: *mut c_double,
    pub length: c_int,
}
pub type SwsVector = Struct_SwsVector;
pub struct Struct_SwsFilter {
    pub lumH: *mut SwsVector,
    pub lumV: *mut SwsVector,
    pub chrH: *mut SwsVector,
    pub chrV: *mut SwsVector,
}
pub type SwsFilter = Struct_SwsFilter;
pub type Struct_SwsContext = c_void;
pub type __va_list_tag = Struct___va_list_tag;
pub struct Struct___va_list_tag {
    pub gp_offset: c_uint,
    pub fp_offset: c_uint,
    pub overflow_arg_area: *mut c_void,
    pub reg_save_area: *mut c_void,
}
extern "C" {
    pub static mut signgam: c_int;
    pub static mut _LIB_VERSION: _LIB_VERSION_TYPE;
    pub static mut _IO_2_1_stdin_: Struct__IO_FILE_plus;
    pub static mut _IO_2_1_stdout_: Struct__IO_FILE_plus;
    pub static mut _IO_2_1_stderr_: Struct__IO_FILE_plus;
    pub static mut stdin: *mut Struct__IO_FILE;
    pub static mut stdout: *mut Struct__IO_FILE;
    pub static mut stderr: *mut Struct__IO_FILE;
    pub static mut sys_nerr: c_int;
    pub static mut sys_errlist: c_void;
    pub static mut av_reverse: [uint8_t, ..256u];
    pub static mut __tzname: [*mut c_schar, ..2u];
    pub static mut __daylight: c_int;
    pub static mut __timezone: c_long;
    pub static mut tzname: [*mut c_schar, ..2u];
    pub static mut daylight: c_int;
    pub static mut timezone: c_long;
    pub fn __errno_location() -> *mut c_int;
    pub fn avutil_version() -> c_uint;
    pub fn avutil_configuration() -> *c_schar;
    pub fn avutil_license() -> *c_schar;
    pub fn av_get_media_type_string(media_type: Enum_AVMediaType) -> *c_schar;
    pub fn av_get_picture_type_char(pict_type: Enum_AVPictureType) -> c_schar;
    pub fn imaxabs(__n: intmax_t) -> intmax_t;
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
    pub fn strtoimax(__nptr: *c_schar, __endptr: *mut *mut c_schar,
                     __base: c_int) -> intmax_t;
    pub fn strtoumax(__nptr: *c_schar, __endptr: *mut *mut c_schar,
                     __base: c_int) -> uintmax_t;
    pub fn wcstoimax(__nptr: *__gwchar_t, __endptr: *mut *mut __gwchar_t,
                     __base: c_int) -> intmax_t;
    pub fn wcstoumax(__nptr: *__gwchar_t, __endptr: *mut *mut __gwchar_t,
                     __base: c_int) -> uintmax_t;
    pub fn acos(__x: c_double) -> c_double;
    pub fn __acos(__x: c_double) -> c_double;
    pub fn asin(__x: c_double) -> c_double;
    pub fn __asin(__x: c_double) -> c_double;
    pub fn atan(__x: c_double) -> c_double;
    pub fn __atan(__x: c_double) -> c_double;
    pub fn atan2(__y: c_double, __x: c_double) -> c_double;
    pub fn __atan2(__y: c_double, __x: c_double) -> c_double;
    pub fn cos(__x: c_double) -> c_double;
    pub fn __cos(__x: c_double) -> c_double;
    pub fn sin(__x: c_double) -> c_double;
    pub fn __sin(__x: c_double) -> c_double;
    pub fn tan(__x: c_double) -> c_double;
    pub fn __tan(__x: c_double) -> c_double;
    pub fn cosh(__x: c_double) -> c_double;
    pub fn __cosh(__x: c_double) -> c_double;
    pub fn sinh(__x: c_double) -> c_double;
    pub fn __sinh(__x: c_double) -> c_double;
    pub fn tanh(__x: c_double) -> c_double;
    pub fn __tanh(__x: c_double) -> c_double;
    pub fn acosh(__x: c_double) -> c_double;
    pub fn __acosh(__x: c_double) -> c_double;
    pub fn asinh(__x: c_double) -> c_double;
    pub fn __asinh(__x: c_double) -> c_double;
    pub fn atanh(__x: c_double) -> c_double;
    pub fn __atanh(__x: c_double) -> c_double;
    pub fn exp(__x: c_double) -> c_double;
    pub fn __exp(__x: c_double) -> c_double;
    pub fn frexp(__x: c_double, __exponent: *mut c_int) -> c_double;
    pub fn __frexp(__x: c_double, __exponent: *mut c_int) -> c_double;
    pub fn ldexp(__x: c_double, __exponent: c_int) -> c_double;
    pub fn __ldexp(__x: c_double, __exponent: c_int) -> c_double;
    pub fn log(__x: c_double) -> c_double;
    pub fn __log(__x: c_double) -> c_double;
    pub fn log10(__x: c_double) -> c_double;
    pub fn __log10(__x: c_double) -> c_double;
    pub fn modf(__x: c_double, __iptr: *mut c_double) -> c_double;
    pub fn __modf(__x: c_double, __iptr: *mut c_double) -> c_double;
    pub fn expm1(__x: c_double) -> c_double;
    pub fn __expm1(__x: c_double) -> c_double;
    pub fn log1p(__x: c_double) -> c_double;
    pub fn __log1p(__x: c_double) -> c_double;
    pub fn logb(__x: c_double) -> c_double;
    pub fn __logb(__x: c_double) -> c_double;
    pub fn exp2(__x: c_double) -> c_double;
    pub fn __exp2(__x: c_double) -> c_double;
    pub fn log2(__x: c_double) -> c_double;
    pub fn __log2(__x: c_double) -> c_double;
    pub fn pow(__x: c_double, __y: c_double) -> c_double;
    pub fn __pow(__x: c_double, __y: c_double) -> c_double;
    pub fn sqrt(__x: c_double) -> c_double;
    pub fn __sqrt(__x: c_double) -> c_double;
    pub fn hypot(__x: c_double, __y: c_double) -> c_double;
    pub fn __hypot(__x: c_double, __y: c_double) -> c_double;
    pub fn cbrt(__x: c_double) -> c_double;
    pub fn __cbrt(__x: c_double) -> c_double;
    pub fn ceil(__x: c_double) -> c_double;
    pub fn __ceil(__x: c_double) -> c_double;
    pub fn fabs(__x: c_double) -> c_double;
    pub fn __fabs(__x: c_double) -> c_double;
    pub fn floor(__x: c_double) -> c_double;
    pub fn __floor(__x: c_double) -> c_double;
    pub fn fmod(__x: c_double, __y: c_double) -> c_double;
    pub fn __fmod(__x: c_double, __y: c_double) -> c_double;
    pub fn __isinf(__value: c_double) -> c_int;
    pub fn __finite(__value: c_double) -> c_int;
    pub fn isinf(__value: c_double) -> c_int;
    pub fn finite(__value: c_double) -> c_int;
    pub fn drem(__x: c_double, __y: c_double) -> c_double;
    pub fn __drem(__x: c_double, __y: c_double) -> c_double;
    pub fn significand(__x: c_double) -> c_double;
    pub fn __significand(__x: c_double) -> c_double;
    pub fn copysign(__x: c_double, __y: c_double) -> c_double;
    pub fn __copysign(__x: c_double, __y: c_double) -> c_double;
    pub fn nan(__tagb: *c_schar) -> c_double;
    pub fn __nan(__tagb: *c_schar) -> c_double;
    pub fn __isnan(__value: c_double) -> c_int;
    pub fn isnan(__value: c_double) -> c_int;
    pub fn j0(arg1: c_double) -> c_double;
    pub fn __j0(arg1: c_double) -> c_double;
    pub fn j1(arg1: c_double) -> c_double;
    pub fn __j1(arg1: c_double) -> c_double;
    pub fn jn(arg1: c_int, arg2: c_double) -> c_double;
    pub fn __jn(arg1: c_int, arg2: c_double) -> c_double;
    pub fn y0(arg1: c_double) -> c_double;
    pub fn __y0(arg1: c_double) -> c_double;
    pub fn y1(arg1: c_double) -> c_double;
    pub fn __y1(arg1: c_double) -> c_double;
    pub fn yn(arg1: c_int, arg2: c_double) -> c_double;
    pub fn __yn(arg1: c_int, arg2: c_double) -> c_double;
    pub fn erf(arg1: c_double) -> c_double;
    pub fn __erf(arg1: c_double) -> c_double;
    pub fn erfc(arg1: c_double) -> c_double;
    pub fn __erfc(arg1: c_double) -> c_double;
    pub fn lgamma(arg1: c_double) -> c_double;
    pub fn __lgamma(arg1: c_double) -> c_double;
    pub fn tgamma(arg1: c_double) -> c_double;
    pub fn __tgamma(arg1: c_double) -> c_double;
    pub fn gamma(arg1: c_double) -> c_double;
    pub fn __gamma(arg1: c_double) -> c_double;
    pub fn lgamma_r(arg1: c_double, __signgamp: *mut c_int) -> c_double;
    pub fn __lgamma_r(arg1: c_double, __signgamp: *mut c_int) -> c_double;
    pub fn rint(__x: c_double) -> c_double;
    pub fn __rint(__x: c_double) -> c_double;
    pub fn nextafter(__x: c_double, __y: c_double) -> c_double;
    pub fn __nextafter(__x: c_double, __y: c_double) -> c_double;
    pub fn nexttoward(__x: c_double, __y: c_double) -> c_double;
    pub fn __nexttoward(__x: c_double, __y: c_double) -> c_double;
    pub fn remainder(__x: c_double, __y: c_double) -> c_double;
    pub fn __remainder(__x: c_double, __y: c_double) -> c_double;
    pub fn scalbn(__x: c_double, __n: c_int) -> c_double;
    pub fn __scalbn(__x: c_double, __n: c_int) -> c_double;
    pub fn ilogb(__x: c_double) -> c_int;
    pub fn __ilogb(__x: c_double) -> c_int;
    pub fn scalbln(__x: c_double, __n: c_long) -> c_double;
    pub fn __scalbln(__x: c_double, __n: c_long) -> c_double;
    pub fn nearbyint(__x: c_double) -> c_double;
    pub fn __nearbyint(__x: c_double) -> c_double;
    pub fn round(__x: c_double) -> c_double;
    pub fn __round(__x: c_double) -> c_double;
    pub fn trunc(__x: c_double) -> c_double;
    pub fn __trunc(__x: c_double) -> c_double;
    pub fn remquo(__x: c_double, __y: c_double, __quo: *mut c_int) ->
     c_double;
    pub fn __remquo(__x: c_double, __y: c_double, __quo: *mut c_int) ->
     c_double;
    pub fn lrint(__x: c_double) -> c_long;
    pub fn __lrint(__x: c_double) -> c_long;
    pub fn llrint(__x: c_double) -> c_longlong;
    pub fn __llrint(__x: c_double) -> c_longlong;
    pub fn lround(__x: c_double) -> c_long;
    pub fn __lround(__x: c_double) -> c_long;
    pub fn llround(__x: c_double) -> c_longlong;
    pub fn __llround(__x: c_double) -> c_longlong;
    pub fn fdim(__x: c_double, __y: c_double) -> c_double;
    pub fn __fdim(__x: c_double, __y: c_double) -> c_double;
    pub fn fmax(__x: c_double, __y: c_double) -> c_double;
    pub fn __fmax(__x: c_double, __y: c_double) -> c_double;
    pub fn fmin(__x: c_double, __y: c_double) -> c_double;
    pub fn __fmin(__x: c_double, __y: c_double) -> c_double;
    pub fn __fpclassify(__value: c_double) -> c_int;
    pub fn __signbit(__value: c_double) -> c_int;
    pub fn fma(__x: c_double, __y: c_double, __z: c_double) -> c_double;
    pub fn __fma(__x: c_double, __y: c_double, __z: c_double) -> c_double;
    pub fn scalb(__x: c_double, __n: c_double) -> c_double;
    pub fn __scalb(__x: c_double, __n: c_double) -> c_double;
    pub fn acosf(__x: c_float) -> c_float;
    pub fn __acosf(__x: c_float) -> c_float;
    pub fn asinf(__x: c_float) -> c_float;
    pub fn __asinf(__x: c_float) -> c_float;
    pub fn atanf(__x: c_float) -> c_float;
    pub fn __atanf(__x: c_float) -> c_float;
    pub fn atan2f(__y: c_float, __x: c_float) -> c_float;
    pub fn __atan2f(__y: c_float, __x: c_float) -> c_float;
    pub fn cosf(__x: c_float) -> c_float;
    pub fn __cosf(__x: c_float) -> c_float;
    pub fn sinf(__x: c_float) -> c_float;
    pub fn __sinf(__x: c_float) -> c_float;
    pub fn tanf(__x: c_float) -> c_float;
    pub fn __tanf(__x: c_float) -> c_float;
    pub fn coshf(__x: c_float) -> c_float;
    pub fn __coshf(__x: c_float) -> c_float;
    pub fn sinhf(__x: c_float) -> c_float;
    pub fn __sinhf(__x: c_float) -> c_float;
    pub fn tanhf(__x: c_float) -> c_float;
    pub fn __tanhf(__x: c_float) -> c_float;
    pub fn acoshf(__x: c_float) -> c_float;
    pub fn __acoshf(__x: c_float) -> c_float;
    pub fn asinhf(__x: c_float) -> c_float;
    pub fn __asinhf(__x: c_float) -> c_float;
    pub fn atanhf(__x: c_float) -> c_float;
    pub fn __atanhf(__x: c_float) -> c_float;
    pub fn expf(__x: c_float) -> c_float;
    pub fn __expf(__x: c_float) -> c_float;
    pub fn frexpf(__x: c_float, __exponent: *mut c_int) -> c_float;
    pub fn __frexpf(__x: c_float, __exponent: *mut c_int) -> c_float;
    pub fn ldexpf(__x: c_float, __exponent: c_int) -> c_float;
    pub fn __ldexpf(__x: c_float, __exponent: c_int) -> c_float;
    pub fn logf(__x: c_float) -> c_float;
    pub fn __logf(__x: c_float) -> c_float;
    pub fn log10f(__x: c_float) -> c_float;
    pub fn __log10f(__x: c_float) -> c_float;
    pub fn modff(__x: c_float, __iptr: *mut c_float) -> c_float;
    pub fn __modff(__x: c_float, __iptr: *mut c_float) -> c_float;
    pub fn expm1f(__x: c_float) -> c_float;
    pub fn __expm1f(__x: c_float) -> c_float;
    pub fn log1pf(__x: c_float) -> c_float;
    pub fn __log1pf(__x: c_float) -> c_float;
    pub fn logbf(__x: c_float) -> c_float;
    pub fn __logbf(__x: c_float) -> c_float;
    pub fn exp2f(__x: c_float) -> c_float;
    pub fn __exp2f(__x: c_float) -> c_float;
    pub fn log2f(__x: c_float) -> c_float;
    pub fn __log2f(__x: c_float) -> c_float;
    pub fn powf(__x: c_float, __y: c_float) -> c_float;
    pub fn __powf(__x: c_float, __y: c_float) -> c_float;
    pub fn sqrtf(__x: c_float) -> c_float;
    pub fn __sqrtf(__x: c_float) -> c_float;
    pub fn hypotf(__x: c_float, __y: c_float) -> c_float;
    pub fn __hypotf(__x: c_float, __y: c_float) -> c_float;
    pub fn cbrtf(__x: c_float) -> c_float;
    pub fn __cbrtf(__x: c_float) -> c_float;
    pub fn ceilf(__x: c_float) -> c_float;
    pub fn __ceilf(__x: c_float) -> c_float;
    pub fn fabsf(__x: c_float) -> c_float;
    pub fn __fabsf(__x: c_float) -> c_float;
    pub fn floorf(__x: c_float) -> c_float;
    pub fn __floorf(__x: c_float) -> c_float;
    pub fn fmodf(__x: c_float, __y: c_float) -> c_float;
    pub fn __fmodf(__x: c_float, __y: c_float) -> c_float;
    pub fn __isinff(__value: c_float) -> c_int;
    pub fn __finitef(__value: c_float) -> c_int;
    pub fn isinff(__value: c_float) -> c_int;
    pub fn finitef(__value: c_float) -> c_int;
    pub fn dremf(__x: c_float, __y: c_float) -> c_float;
    pub fn __dremf(__x: c_float, __y: c_float) -> c_float;
    pub fn significandf(__x: c_float) -> c_float;
    pub fn __significandf(__x: c_float) -> c_float;
    pub fn copysignf(__x: c_float, __y: c_float) -> c_float;
    pub fn __copysignf(__x: c_float, __y: c_float) -> c_float;
    pub fn nanf(__tagb: *c_schar) -> c_float;
    pub fn __nanf(__tagb: *c_schar) -> c_float;
    pub fn __isnanf(__value: c_float) -> c_int;
    pub fn isnanf(__value: c_float) -> c_int;
    pub fn j0f(arg1: c_float) -> c_float;
    pub fn __j0f(arg1: c_float) -> c_float;
    pub fn j1f(arg1: c_float) -> c_float;
    pub fn __j1f(arg1: c_float) -> c_float;
    pub fn jnf(arg1: c_int, arg2: c_float) -> c_float;
    pub fn __jnf(arg1: c_int, arg2: c_float) -> c_float;
    pub fn y0f(arg1: c_float) -> c_float;
    pub fn __y0f(arg1: c_float) -> c_float;
    pub fn y1f(arg1: c_float) -> c_float;
    pub fn __y1f(arg1: c_float) -> c_float;
    pub fn ynf(arg1: c_int, arg2: c_float) -> c_float;
    pub fn __ynf(arg1: c_int, arg2: c_float) -> c_float;
    pub fn erff(arg1: c_float) -> c_float;
    pub fn __erff(arg1: c_float) -> c_float;
    pub fn erfcf(arg1: c_float) -> c_float;
    pub fn __erfcf(arg1: c_float) -> c_float;
    pub fn lgammaf(arg1: c_float) -> c_float;
    pub fn __lgammaf(arg1: c_float) -> c_float;
    pub fn tgammaf(arg1: c_float) -> c_float;
    pub fn __tgammaf(arg1: c_float) -> c_float;
    pub fn gammaf(arg1: c_float) -> c_float;
    pub fn __gammaf(arg1: c_float) -> c_float;
    pub fn lgammaf_r(arg1: c_float, __signgamp: *mut c_int) -> c_float;
    pub fn __lgammaf_r(arg1: c_float, __signgamp: *mut c_int) -> c_float;
    pub fn rintf(__x: c_float) -> c_float;
    pub fn __rintf(__x: c_float) -> c_float;
    pub fn nextafterf(__x: c_float, __y: c_float) -> c_float;
    pub fn __nextafterf(__x: c_float, __y: c_float) -> c_float;
    pub fn nexttowardf(__x: c_float, __y: c_double) -> c_float;
    pub fn __nexttowardf(__x: c_float, __y: c_double) -> c_float;
    pub fn remainderf(__x: c_float, __y: c_float) -> c_float;
    pub fn __remainderf(__x: c_float, __y: c_float) -> c_float;
    pub fn scalbnf(__x: c_float, __n: c_int) -> c_float;
    pub fn __scalbnf(__x: c_float, __n: c_int) -> c_float;
    pub fn ilogbf(__x: c_float) -> c_int;
    pub fn __ilogbf(__x: c_float) -> c_int;
    pub fn scalblnf(__x: c_float, __n: c_long) -> c_float;
    pub fn __scalblnf(__x: c_float, __n: c_long) -> c_float;
    pub fn nearbyintf(__x: c_float) -> c_float;
    pub fn __nearbyintf(__x: c_float) -> c_float;
    pub fn roundf(__x: c_float) -> c_float;
    pub fn __roundf(__x: c_float) -> c_float;
    pub fn truncf(__x: c_float) -> c_float;
    pub fn __truncf(__x: c_float) -> c_float;
    pub fn remquof(__x: c_float, __y: c_float, __quo: *mut c_int) -> c_float;
    pub fn __remquof(__x: c_float, __y: c_float, __quo: *mut c_int) ->
     c_float;
    pub fn lrintf(__x: c_float) -> c_long;
    pub fn __lrintf(__x: c_float) -> c_long;
    pub fn llrintf(__x: c_float) -> c_longlong;
    pub fn __llrintf(__x: c_float) -> c_longlong;
    pub fn lroundf(__x: c_float) -> c_long;
    pub fn __lroundf(__x: c_float) -> c_long;
    pub fn llroundf(__x: c_float) -> c_longlong;
    pub fn __llroundf(__x: c_float) -> c_longlong;
    pub fn fdimf(__x: c_float, __y: c_float) -> c_float;
    pub fn __fdimf(__x: c_float, __y: c_float) -> c_float;
    pub fn fmaxf(__x: c_float, __y: c_float) -> c_float;
    pub fn __fmaxf(__x: c_float, __y: c_float) -> c_float;
    pub fn fminf(__x: c_float, __y: c_float) -> c_float;
    pub fn __fminf(__x: c_float, __y: c_float) -> c_float;
    pub fn __fpclassifyf(__value: c_float) -> c_int;
    pub fn __signbitf(__value: c_float) -> c_int;
    pub fn fmaf(__x: c_float, __y: c_float, __z: c_float) -> c_float;
    pub fn __fmaf(__x: c_float, __y: c_float, __z: c_float) -> c_float;
    pub fn scalbf(__x: c_float, __n: c_float) -> c_float;
    pub fn __scalbf(__x: c_float, __n: c_float) -> c_float;
    pub fn acosl(__x: c_double) -> c_double;
    pub fn __acosl(__x: c_double) -> c_double;
    pub fn asinl(__x: c_double) -> c_double;
    pub fn __asinl(__x: c_double) -> c_double;
    pub fn atanl(__x: c_double) -> c_double;
    pub fn __atanl(__x: c_double) -> c_double;
    pub fn atan2l(__y: c_double, __x: c_double) -> c_double;
    pub fn __atan2l(__y: c_double, __x: c_double) -> c_double;
    pub fn cosl(__x: c_double) -> c_double;
    pub fn __cosl(__x: c_double) -> c_double;
    pub fn sinl(__x: c_double) -> c_double;
    pub fn __sinl(__x: c_double) -> c_double;
    pub fn tanl(__x: c_double) -> c_double;
    pub fn __tanl(__x: c_double) -> c_double;
    pub fn coshl(__x: c_double) -> c_double;
    pub fn __coshl(__x: c_double) -> c_double;
    pub fn sinhl(__x: c_double) -> c_double;
    pub fn __sinhl(__x: c_double) -> c_double;
    pub fn tanhl(__x: c_double) -> c_double;
    pub fn __tanhl(__x: c_double) -> c_double;
    pub fn acoshl(__x: c_double) -> c_double;
    pub fn __acoshl(__x: c_double) -> c_double;
    pub fn asinhl(__x: c_double) -> c_double;
    pub fn __asinhl(__x: c_double) -> c_double;
    pub fn atanhl(__x: c_double) -> c_double;
    pub fn __atanhl(__x: c_double) -> c_double;
    pub fn expl(__x: c_double) -> c_double;
    pub fn __expl(__x: c_double) -> c_double;
    pub fn frexpl(__x: c_double, __exponent: *mut c_int) -> c_double;
    pub fn __frexpl(__x: c_double, __exponent: *mut c_int) -> c_double;
    pub fn ldexpl(__x: c_double, __exponent: c_int) -> c_double;
    pub fn __ldexpl(__x: c_double, __exponent: c_int) -> c_double;
    pub fn logl(__x: c_double) -> c_double;
    pub fn __logl(__x: c_double) -> c_double;
    pub fn log10l(__x: c_double) -> c_double;
    pub fn __log10l(__x: c_double) -> c_double;
    pub fn modfl(__x: c_double, __iptr: *mut c_double) -> c_double;
    pub fn __modfl(__x: c_double, __iptr: *mut c_double) -> c_double;
    pub fn expm1l(__x: c_double) -> c_double;
    pub fn __expm1l(__x: c_double) -> c_double;
    pub fn log1pl(__x: c_double) -> c_double;
    pub fn __log1pl(__x: c_double) -> c_double;
    pub fn logbl(__x: c_double) -> c_double;
    pub fn __logbl(__x: c_double) -> c_double;
    pub fn exp2l(__x: c_double) -> c_double;
    pub fn __exp2l(__x: c_double) -> c_double;
    pub fn log2l(__x: c_double) -> c_double;
    pub fn __log2l(__x: c_double) -> c_double;
    pub fn powl(__x: c_double, __y: c_double) -> c_double;
    pub fn __powl(__x: c_double, __y: c_double) -> c_double;
    pub fn sqrtl(__x: c_double) -> c_double;
    pub fn __sqrtl(__x: c_double) -> c_double;
    pub fn hypotl(__x: c_double, __y: c_double) -> c_double;
    pub fn __hypotl(__x: c_double, __y: c_double) -> c_double;
    pub fn cbrtl(__x: c_double) -> c_double;
    pub fn __cbrtl(__x: c_double) -> c_double;
    pub fn ceill(__x: c_double) -> c_double;
    pub fn __ceill(__x: c_double) -> c_double;
    pub fn fabsl(__x: c_double) -> c_double;
    pub fn __fabsl(__x: c_double) -> c_double;
    pub fn floorl(__x: c_double) -> c_double;
    pub fn __floorl(__x: c_double) -> c_double;
    pub fn fmodl(__x: c_double, __y: c_double) -> c_double;
    pub fn __fmodl(__x: c_double, __y: c_double) -> c_double;
    pub fn __isinfl(__value: c_double) -> c_int;
    pub fn __finitel(__value: c_double) -> c_int;
    pub fn isinfl(__value: c_double) -> c_int;
    pub fn finitel(__value: c_double) -> c_int;
    pub fn dreml(__x: c_double, __y: c_double) -> c_double;
    pub fn __dreml(__x: c_double, __y: c_double) -> c_double;
    pub fn significandl(__x: c_double) -> c_double;
    pub fn __significandl(__x: c_double) -> c_double;
    pub fn copysignl(__x: c_double, __y: c_double) -> c_double;
    pub fn __copysignl(__x: c_double, __y: c_double) -> c_double;
    pub fn nanl(__tagb: *c_schar) -> c_double;
    pub fn __nanl(__tagb: *c_schar) -> c_double;
    pub fn __isnanl(__value: c_double) -> c_int;
    pub fn isnanl(__value: c_double) -> c_int;
    pub fn j0l(arg1: c_double) -> c_double;
    pub fn __j0l(arg1: c_double) -> c_double;
    pub fn j1l(arg1: c_double) -> c_double;
    pub fn __j1l(arg1: c_double) -> c_double;
    pub fn jnl(arg1: c_int, arg2: c_double) -> c_double;
    pub fn __jnl(arg1: c_int, arg2: c_double) -> c_double;
    pub fn y0l(arg1: c_double) -> c_double;
    pub fn __y0l(arg1: c_double) -> c_double;
    pub fn y1l(arg1: c_double) -> c_double;
    pub fn __y1l(arg1: c_double) -> c_double;
    pub fn ynl(arg1: c_int, arg2: c_double) -> c_double;
    pub fn __ynl(arg1: c_int, arg2: c_double) -> c_double;
    pub fn erfl(arg1: c_double) -> c_double;
    pub fn __erfl(arg1: c_double) -> c_double;
    pub fn erfcl(arg1: c_double) -> c_double;
    pub fn __erfcl(arg1: c_double) -> c_double;
    pub fn lgammal(arg1: c_double) -> c_double;
    pub fn __lgammal(arg1: c_double) -> c_double;
    pub fn tgammal(arg1: c_double) -> c_double;
    pub fn __tgammal(arg1: c_double) -> c_double;
    pub fn gammal(arg1: c_double) -> c_double;
    pub fn __gammal(arg1: c_double) -> c_double;
    pub fn lgammal_r(arg1: c_double, __signgamp: *mut c_int) -> c_double;
    pub fn __lgammal_r(arg1: c_double, __signgamp: *mut c_int) -> c_double;
    pub fn rintl(__x: c_double) -> c_double;
    pub fn __rintl(__x: c_double) -> c_double;
    pub fn nextafterl(__x: c_double, __y: c_double) -> c_double;
    pub fn __nextafterl(__x: c_double, __y: c_double) -> c_double;
    pub fn nexttowardl(__x: c_double, __y: c_double) -> c_double;
    pub fn __nexttowardl(__x: c_double, __y: c_double) -> c_double;
    pub fn remainderl(__x: c_double, __y: c_double) -> c_double;
    pub fn __remainderl(__x: c_double, __y: c_double) -> c_double;
    pub fn scalbnl(__x: c_double, __n: c_int) -> c_double;
    pub fn __scalbnl(__x: c_double, __n: c_int) -> c_double;
    pub fn ilogbl(__x: c_double) -> c_int;
    pub fn __ilogbl(__x: c_double) -> c_int;
    pub fn scalblnl(__x: c_double, __n: c_long) -> c_double;
    pub fn __scalblnl(__x: c_double, __n: c_long) -> c_double;
    pub fn nearbyintl(__x: c_double) -> c_double;
    pub fn __nearbyintl(__x: c_double) -> c_double;
    pub fn roundl(__x: c_double) -> c_double;
    pub fn __roundl(__x: c_double) -> c_double;
    pub fn truncl(__x: c_double) -> c_double;
    pub fn __truncl(__x: c_double) -> c_double;
    pub fn remquol(__x: c_double, __y: c_double, __quo: *mut c_int) ->
     c_double;
    pub fn __remquol(__x: c_double, __y: c_double, __quo: *mut c_int) ->
     c_double;
    pub fn lrintl(__x: c_double) -> c_long;
    pub fn __lrintl(__x: c_double) -> c_long;
    pub fn llrintl(__x: c_double) -> c_longlong;
    pub fn __llrintl(__x: c_double) -> c_longlong;
    pub fn lroundl(__x: c_double) -> c_long;
    pub fn __lroundl(__x: c_double) -> c_long;
    pub fn llroundl(__x: c_double) -> c_longlong;
    pub fn __llroundl(__x: c_double) -> c_longlong;
    pub fn fdiml(__x: c_double, __y: c_double) -> c_double;
    pub fn __fdiml(__x: c_double, __y: c_double) -> c_double;
    pub fn fmaxl(__x: c_double, __y: c_double) -> c_double;
    pub fn __fmaxl(__x: c_double, __y: c_double) -> c_double;
    pub fn fminl(__x: c_double, __y: c_double) -> c_double;
    pub fn __fminl(__x: c_double, __y: c_double) -> c_double;
    pub fn __fpclassifyl(__value: c_double) -> c_int;
    pub fn __signbitl(__value: c_double) -> c_int;
    pub fn fmal(__x: c_double, __y: c_double, __z: c_double) -> c_double;
    pub fn __fmal(__x: c_double, __y: c_double, __z: c_double) -> c_double;
    pub fn scalbl(__x: c_double, __n: c_double) -> c_double;
    pub fn __scalbl(__x: c_double, __n: c_double) -> c_double;
    pub fn matherr(__exc: *mut Struct_exception) -> c_int;
    pub fn __underflow(arg1: *mut _IO_FILE) -> c_int;
    pub fn __uflow(arg1: *mut _IO_FILE) -> c_int;
    pub fn __overflow(arg1: *mut _IO_FILE, arg2: c_int) -> c_int;
    pub fn _IO_getc(__fp: *mut _IO_FILE) -> c_int;
    pub fn _IO_putc(__c: c_int, __fp: *mut _IO_FILE) -> c_int;
    pub fn _IO_feof(__fp: *mut _IO_FILE) -> c_int;
    pub fn _IO_ferror(__fp: *mut _IO_FILE) -> c_int;
    pub fn _IO_peekc_locked(__fp: *mut _IO_FILE) -> c_int;
    pub fn _IO_flockfile(arg1: *mut _IO_FILE);
    pub fn _IO_funlockfile(arg1: *mut _IO_FILE);
    pub fn _IO_ftrylockfile(arg1: *mut _IO_FILE) -> c_int;
    pub fn _IO_vfscanf(arg1: *mut _IO_FILE, arg2: *c_schar,
                       arg3: __gnuc_va_list, arg4: *mut c_int) -> c_int;
    pub fn _IO_vfprintf(arg1: *mut _IO_FILE, arg2: *c_schar,
                        arg3: __gnuc_va_list) -> c_int;
    pub fn _IO_padn(arg1: *mut _IO_FILE, arg2: c_int, arg3: __ssize_t) ->
     __ssize_t;
    pub fn _IO_sgetn(arg1: *mut _IO_FILE, arg2: *mut c_void, arg3: size_t) ->
     size_t;
    pub fn _IO_seekoff(arg1: *mut _IO_FILE, arg2: __off64_t, arg3: c_int,
                       arg4: c_int) -> __off64_t;
    pub fn _IO_seekpos(arg1: *mut _IO_FILE, arg2: __off64_t, arg3: c_int) ->
     __off64_t;
    pub fn _IO_free_backup_area(arg1: *mut _IO_FILE);
    pub fn remove(__filename: *c_schar) -> c_int;
    pub fn rename(__old: *c_schar, __new: *c_schar) -> c_int;
    pub fn renameat(__oldfd: c_int, __old: *c_schar, __newfd: c_int,
                    __new: *c_schar) -> c_int;
    pub fn tmpfile() -> *mut FILE;
    pub fn tmpnam(__s: *mut c_schar) -> *mut c_schar;
    pub fn tmpnam_r(__s: *mut c_schar) -> *mut c_schar;
    pub fn tempnam(__dir: *c_schar, __pfx: *c_schar) -> *mut c_schar;
    pub fn fclose(__stream: *mut FILE) -> c_int;
    pub fn fflush(__stream: *mut FILE) -> c_int;
    pub fn fflush_unlocked(__stream: *mut FILE) -> c_int;
    pub fn fopen(__filename: *c_schar, __modes: *c_schar) -> *mut FILE;
    pub fn freopen(__filename: *c_schar, __modes: *c_schar,
                   __stream: *mut FILE) -> *mut FILE;
    pub fn fdopen(__fd: c_int, __modes: *c_schar) -> *mut FILE;
    pub fn fmemopen(__s: *mut c_void, __len: size_t, __modes: *c_schar) ->
     *mut FILE;
    pub fn open_memstream(__bufloc: *mut *mut c_schar, __sizeloc: *mut size_t)
     -> *mut FILE;
    pub fn setbuf(__stream: *mut FILE, __buf: *mut c_schar);
    pub fn setvbuf(__stream: *mut FILE, __buf: *mut c_schar, __modes: c_int,
                   __n: size_t) -> c_int;
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut c_schar,
                     __size: size_t);
    pub fn setlinebuf(__stream: *mut FILE);
    pub fn fprintf(__stream: *mut FILE, __format: *c_schar, ...) -> c_int;
    pub fn printf(__format: *c_schar, ...) -> c_int;
    pub fn sprintf(__s: *mut c_schar, __format: *c_schar, ...) -> c_int;
    pub fn vfprintf(__s: *mut FILE, __format: *c_schar, __arg: __gnuc_va_list)
     -> c_int;
    pub fn vprintf(__format: *c_schar, __arg: __gnuc_va_list) -> c_int;
    pub fn vsprintf(__s: *mut c_schar, __format: *c_schar,
                    __arg: __gnuc_va_list) -> c_int;
    pub fn snprintf(__s: *mut c_schar, __maxlen: size_t,
                    __format: *c_schar, ...) -> c_int;
    pub fn vsnprintf(__s: *mut c_schar, __maxlen: size_t, __format: *c_schar,
                     __arg: __gnuc_va_list) -> c_int;
    pub fn vdprintf(__fd: c_int, __fmt: *c_schar, __arg: __gnuc_va_list) ->
     c_int;
    pub fn dprintf(__fd: c_int, __fmt: *c_schar, ...) -> c_int;
    pub fn fscanf(__stream: *mut FILE, __format: *c_schar, ...) -> c_int;
    pub fn scanf(__format: *c_schar, ...) -> c_int;
    pub fn sscanf(__s: *c_schar, __format: *c_schar, ...) -> c_int;
    pub fn vfscanf(__s: *mut FILE, __format: *c_schar, __arg: __gnuc_va_list)
     -> c_int;
    pub fn vscanf(__format: *c_schar, __arg: __gnuc_va_list) -> c_int;
    pub fn vsscanf(__s: *c_schar, __format: *c_schar, __arg: __gnuc_va_list)
     -> c_int;
    pub fn fgetc(__stream: *mut FILE) -> c_int;
    pub fn getc(__stream: *mut FILE) -> c_int;
    pub fn getchar() -> c_int;
    pub fn getc_unlocked(__stream: *mut FILE) -> c_int;
    pub fn getchar_unlocked() -> c_int;
    pub fn fgetc_unlocked(__stream: *mut FILE) -> c_int;
    pub fn fputc(__c: c_int, __stream: *mut FILE) -> c_int;
    pub fn putc(__c: c_int, __stream: *mut FILE) -> c_int;
    pub fn putchar(__c: c_int) -> c_int;
    pub fn fputc_unlocked(__c: c_int, __stream: *mut FILE) -> c_int;
    pub fn putc_unlocked(__c: c_int, __stream: *mut FILE) -> c_int;
    pub fn putchar_unlocked(__c: c_int) -> c_int;
    pub fn getw(__stream: *mut FILE) -> c_int;
    pub fn putw(__w: c_int, __stream: *mut FILE) -> c_int;
    pub fn fgets(__s: *mut c_schar, __n: c_int, __stream: *mut FILE) ->
     *mut c_schar;
    pub fn gets(__s: *mut c_schar) -> *mut c_schar;
    pub fn __getdelim(__lineptr: *mut *mut c_schar, __n: *mut size_t,
                      __delimiter: c_int, __stream: *mut FILE) -> __ssize_t;
    pub fn getdelim(__lineptr: *mut *mut c_schar, __n: *mut size_t,
                    __delimiter: c_int, __stream: *mut FILE) -> __ssize_t;
    pub fn getline(__lineptr: *mut *mut c_schar, __n: *mut size_t,
                   __stream: *mut FILE) -> __ssize_t;
    pub fn fputs(__s: *c_schar, __stream: *mut FILE) -> c_int;
    pub fn puts(__s: *c_schar) -> c_int;
    pub fn ungetc(__c: c_int, __stream: *mut FILE) -> c_int;
    pub fn fread(__ptr: *mut c_void, __size: size_t, __n: size_t,
                 __stream: *mut FILE) -> size_t;
    pub fn fwrite(__ptr: *c_void, __size: size_t, __n: size_t, __s: *mut FILE)
     -> size_t;
    pub fn fread_unlocked(__ptr: *mut c_void, __size: size_t, __n: size_t,
                          __stream: *mut FILE) -> size_t;
    pub fn fwrite_unlocked(__ptr: *c_void, __size: size_t, __n: size_t,
                           __stream: *mut FILE) -> size_t;
    pub fn fseek(__stream: *mut FILE, __off: c_long, __whence: c_int) ->
     c_int;
    pub fn ftell(__stream: *mut FILE) -> c_long;
    pub fn rewind(__stream: *mut FILE);
    pub fn fseeko(__stream: *mut FILE, __off: __off_t, __whence: c_int) ->
     c_int;
    pub fn ftello(__stream: *mut FILE) -> __off_t;
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> c_int;
    pub fn fsetpos(__stream: *mut FILE, __pos: *fpos_t) -> c_int;
    pub fn clearerr(__stream: *mut FILE);
    pub fn feof(__stream: *mut FILE) -> c_int;
    pub fn ferror(__stream: *mut FILE) -> c_int;
    pub fn clearerr_unlocked(__stream: *mut FILE);
    pub fn feof_unlocked(__stream: *mut FILE) -> c_int;
    pub fn ferror_unlocked(__stream: *mut FILE) -> c_int;
    pub fn perror(__s: *c_schar);
    pub fn fileno(__stream: *mut FILE) -> c_int;
    pub fn fileno_unlocked(__stream: *mut FILE) -> c_int;
    pub fn popen(__command: *c_schar, __modes: *c_schar) -> *mut FILE;
    pub fn pclose(__stream: *mut FILE) -> c_int;
    pub fn ctermid(__s: *mut c_schar) -> *mut c_schar;
    pub fn flockfile(__stream: *mut FILE);
    pub fn ftrylockfile(__stream: *mut FILE) -> c_int;
    pub fn funlockfile(__stream: *mut FILE);
    pub fn __ctype_get_mb_cur_max() -> size_t;
    pub fn atof(__nptr: *c_schar) -> c_double;
    pub fn atoi(__nptr: *c_schar) -> c_int;
    pub fn atol(__nptr: *c_schar) -> c_long;
    pub fn atoll(__nptr: *c_schar) -> c_longlong;
    pub fn strtod(__nptr: *c_schar, __endptr: *mut *mut c_schar) -> c_double;
    pub fn strtof(__nptr: *c_schar, __endptr: *mut *mut c_schar) -> c_float;
    pub fn strtold(__nptr: *c_schar, __endptr: *mut *mut c_schar) -> c_double;
    pub fn strtol(__nptr: *c_schar, __endptr: *mut *mut c_schar,
                  __base: c_int) -> c_long;
    pub fn strtoul(__nptr: *c_schar, __endptr: *mut *mut c_schar,
                   __base: c_int) -> c_ulong;
    pub fn strtoq(__nptr: *c_schar, __endptr: *mut *mut c_schar,
                  __base: c_int) -> c_longlong;
    pub fn strtouq(__nptr: *c_schar, __endptr: *mut *mut c_schar,
                   __base: c_int) -> c_ulonglong;
    pub fn strtoll(__nptr: *c_schar, __endptr: *mut *mut c_schar,
                   __base: c_int) -> c_longlong;
    pub fn strtoull(__nptr: *c_schar, __endptr: *mut *mut c_schar,
                    __base: c_int) -> c_ulonglong;
    pub fn l64a(__n: c_long) -> *mut c_schar;
    pub fn a64l(__s: *c_schar) -> c_long;
    pub fn select(__nfds: c_int, __readfds: *mut fd_set,
                  __writefds: *mut fd_set, __exceptfds: *mut fd_set,
                  __timeout: *mut Struct_timeval) -> c_int;
    pub fn pselect(__nfds: c_int, __readfds: *mut fd_set,
                   __writefds: *mut fd_set, __exceptfds: *mut fd_set,
                   __timeout: *Struct_timespec, __sigmask: *__sigset_t) ->
     c_int;
    pub fn gnu_dev_major(__dev: c_ulonglong) -> c_uint;
    pub fn gnu_dev_minor(__dev: c_ulonglong) -> c_uint;
    pub fn gnu_dev_makedev(__major: c_uint, __minor: c_uint) -> c_ulonglong;
    pub fn random() -> c_long;
    pub fn srandom(__seed: c_uint);
    pub fn initstate(__seed: c_uint, __statebuf: *mut c_schar,
                     __statelen: size_t) -> *mut c_schar;
    pub fn setstate(__statebuf: *mut c_schar) -> *mut c_schar;
    pub fn random_r(__buf: *mut Struct_random_data, __result: *mut int32_t) ->
     c_int;
    pub fn srandom_r(__seed: c_uint, __buf: *mut Struct_random_data) -> c_int;
    pub fn initstate_r(__seed: c_uint, __statebuf: *mut c_schar,
                       __statelen: size_t, __buf: *mut Struct_random_data) ->
     c_int;
    pub fn setstate_r(__statebuf: *mut c_schar,
                      __buf: *mut Struct_random_data) -> c_int;
    pub fn rand() -> c_int;
    pub fn srand(__seed: c_uint);
    pub fn rand_r(__seed: *mut c_uint) -> c_int;
    pub fn drand48() -> c_double;
    pub fn erand48(__xsubi: [c_ushort, ..3u]) -> c_double;
    pub fn lrand48() -> c_long;
    pub fn nrand48(__xsubi: [c_ushort, ..3u]) -> c_long;
    pub fn mrand48() -> c_long;
    pub fn jrand48(__xsubi: [c_ushort, ..3u]) -> c_long;
    pub fn srand48(__seedval: c_long);
    pub fn seed48(__seed16v: [c_ushort, ..3u]) -> *mut c_ushort;
    pub fn lcong48(__param: [c_ushort, ..7u]);
    pub fn drand48_r(__buffer: *mut Struct_drand48_data,
                     __result: *mut c_double) -> c_int;
    pub fn erand48_r(__xsubi: [c_ushort, ..3u],
                     __buffer: *mut Struct_drand48_data,
                     __result: *mut c_double) -> c_int;
    pub fn lrand48_r(__buffer: *mut Struct_drand48_data,
                     __result: *mut c_long) -> c_int;
    pub fn nrand48_r(__xsubi: [c_ushort, ..3u],
                     __buffer: *mut Struct_drand48_data,
                     __result: *mut c_long) -> c_int;
    pub fn mrand48_r(__buffer: *mut Struct_drand48_data,
                     __result: *mut c_long) -> c_int;
    pub fn jrand48_r(__xsubi: [c_ushort, ..3u],
                     __buffer: *mut Struct_drand48_data,
                     __result: *mut c_long) -> c_int;
    pub fn srand48_r(__seedval: c_long, __buffer: *mut Struct_drand48_data) ->
     c_int;
    pub fn seed48_r(__seed16v: [c_ushort, ..3u],
                    __buffer: *mut Struct_drand48_data) -> c_int;
    pub fn lcong48_r(__param: [c_ushort, ..7u],
                     __buffer: *mut Struct_drand48_data) -> c_int;
    pub fn malloc(__size: size_t) -> *mut c_void;
    pub fn calloc(__nmemb: size_t, __size: size_t) -> *mut c_void;
    pub fn realloc(__ptr: *mut c_void, __size: size_t) -> *mut c_void;
    pub fn free(__ptr: *mut c_void);
    pub fn cfree(__ptr: *mut c_void);
    pub fn alloca(__size: size_t) -> *mut c_void;
    pub fn valloc(__size: size_t) -> *mut c_void;
    pub fn posix_memalign(__memptr: *mut *mut c_void, __alignment: size_t,
                          __size: size_t) -> c_int;
    pub fn abort();
    pub fn atexit(__func: ::std::option::Option<extern "C" fn()>) -> c_int;
    pub fn on_exit(__func:
                       ::std::option::Option<extern "C" fn
                                                 (arg1: c_int,
                                                  arg2: *mut c_void)>,
                   __arg: *mut c_void) -> c_int;
    pub fn exit(__status: c_int);
    pub fn _Exit(__status: c_int);
    pub fn getenv(__name: *c_schar) -> *mut c_schar;
    pub fn putenv(__string: *mut c_schar) -> c_int;
    pub fn setenv(__name: *c_schar, __value: *c_schar, __replace: c_int) ->
     c_int;
    pub fn unsetenv(__name: *c_schar) -> c_int;
    pub fn clearenv() -> c_int;
    pub fn mktemp(__template: *mut c_schar) -> *mut c_schar;
    pub fn mkstemp(__template: *mut c_schar) -> c_int;
    pub fn mkstemps(__template: *mut c_schar, __suffixlen: c_int) -> c_int;
    pub fn mkdtemp(__template: *mut c_schar) -> *mut c_schar;
    pub fn system(__command: *c_schar) -> c_int;
    pub fn realpath(__name: *c_schar, __resolved: *mut c_schar) ->
     *mut c_schar;
    pub fn bsearch(__key: *c_void, __base: *c_void, __nmemb: size_t,
                   __size: size_t, __compar: __compar_fn_t) -> *mut c_void;
    pub fn qsort(__base: *mut c_void, __nmemb: size_t, __size: size_t,
                 __compar: __compar_fn_t);
    pub fn abs(__x: c_int) -> c_int;
    pub fn labs(__x: c_long) -> c_long;
    pub fn llabs(__x: c_longlong) -> c_longlong;
    pub fn div(__numer: c_int, __denom: c_int) -> div_t;
    pub fn ldiv(__numer: c_long, __denom: c_long) -> ldiv_t;
    pub fn lldiv(__numer: c_longlong, __denom: c_longlong) -> lldiv_t;
    pub fn ecvt(__value: c_double, __ndigit: c_int, __decpt: *mut c_int,
                __sign: *mut c_int) -> *mut c_schar;
    pub fn fcvt(__value: c_double, __ndigit: c_int, __decpt: *mut c_int,
                __sign: *mut c_int) -> *mut c_schar;
    pub fn gcvt(__value: c_double, __ndigit: c_int, __buf: *mut c_schar) ->
     *mut c_schar;
    pub fn qecvt(__value: c_double, __ndigit: c_int, __decpt: *mut c_int,
                 __sign: *mut c_int) -> *mut c_schar;
    pub fn qfcvt(__value: c_double, __ndigit: c_int, __decpt: *mut c_int,
                 __sign: *mut c_int) -> *mut c_schar;
    pub fn qgcvt(__value: c_double, __ndigit: c_int, __buf: *mut c_schar) ->
     *mut c_schar;
    pub fn ecvt_r(__value: c_double, __ndigit: c_int, __decpt: *mut c_int,
                  __sign: *mut c_int, __buf: *mut c_schar, __len: size_t) ->
     c_int;
    pub fn fcvt_r(__value: c_double, __ndigit: c_int, __decpt: *mut c_int,
                  __sign: *mut c_int, __buf: *mut c_schar, __len: size_t) ->
     c_int;
    pub fn qecvt_r(__value: c_double, __ndigit: c_int, __decpt: *mut c_int,
                   __sign: *mut c_int, __buf: *mut c_schar, __len: size_t) ->
     c_int;
    pub fn qfcvt_r(__value: c_double, __ndigit: c_int, __decpt: *mut c_int,
                   __sign: *mut c_int, __buf: *mut c_schar, __len: size_t) ->
     c_int;
    pub fn mblen(__s: *c_schar, __n: size_t) -> c_int;
    pub fn mbtowc(__pwc: *mut wchar_t, __s: *c_schar, __n: size_t) -> c_int;
    pub fn wctomb(__s: *mut c_schar, __wchar: wchar_t) -> c_int;
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *c_schar, __n: size_t) ->
     size_t;
    pub fn wcstombs(__s: *mut c_schar, __pwcs: *wchar_t, __n: size_t) ->
     size_t;
    pub fn rpmatch(__response: *c_schar) -> c_int;
    pub fn getsubopt(__optionp: *mut *mut c_schar, __tokens: **mut c_schar,
                     __valuep: *mut *mut c_schar) -> c_int;
    pub fn getloadavg(__loadavg: c_void, __nelem: c_int) -> c_int;
    pub fn memcpy(__dest: *mut c_void, __src: *c_void, __n: size_t) ->
     *mut c_void;
    pub fn memmove(__dest: *mut c_void, __src: *c_void, __n: size_t) ->
     *mut c_void;
    pub fn memccpy(__dest: *mut c_void, __src: *c_void, __c: c_int,
                   __n: size_t) -> *mut c_void;
    pub fn memset(__s: *mut c_void, __c: c_int, __n: size_t) -> *mut c_void;
    pub fn memcmp(__s1: *c_void, __s2: *c_void, __n: size_t) -> c_int;
    pub fn memchr(__s: *c_void, __c: c_int, __n: size_t) -> *mut c_void;
    pub fn strcpy(__dest: *mut c_schar, __src: *c_schar) -> *mut c_schar;
    pub fn strncpy(__dest: *mut c_schar, __src: *c_schar, __n: size_t) ->
     *mut c_schar;
    pub fn strcat(__dest: *mut c_schar, __src: *c_schar) -> *mut c_schar;
    pub fn strncat(__dest: *mut c_schar, __src: *c_schar, __n: size_t) ->
     *mut c_schar;
    pub fn strcmp(__s1: *c_schar, __s2: *c_schar) -> c_int;
    pub fn strncmp(__s1: *c_schar, __s2: *c_schar, __n: size_t) -> c_int;
    pub fn strcoll(__s1: *c_schar, __s2: *c_schar) -> c_int;
    pub fn strxfrm(__dest: *mut c_schar, __src: *c_schar, __n: size_t) ->
     size_t;
    pub fn strcoll_l(__s1: *c_schar, __s2: *c_schar, __l: __locale_t) ->
     c_int;
    pub fn strxfrm_l(__dest: *mut c_schar, __src: *c_schar, __n: size_t,
                     __l: __locale_t) -> size_t;
    pub fn strdup(__s: *c_schar) -> *mut c_schar;
    pub fn strndup(__string: *c_schar, __n: size_t) -> *mut c_schar;
    pub fn strchr(__s: *c_schar, __c: c_int) -> *mut c_schar;
    pub fn strrchr(__s: *c_schar, __c: c_int) -> *mut c_schar;
    pub fn strcspn(__s: *c_schar, __reject: *c_schar) -> size_t;
    pub fn strspn(__s: *c_schar, __accept: *c_schar) -> size_t;
    pub fn strpbrk(__s: *c_schar, __accept: *c_schar) -> *mut c_schar;
    pub fn strstr(__haystack: *c_schar, __needle: *c_schar) -> *mut c_schar;
    pub fn strtok(__s: *mut c_schar, __delim: *c_schar) -> *mut c_schar;
    pub fn __strtok_r(__s: *mut c_schar, __delim: *c_schar,
                      __save_ptr: *mut *mut c_schar) -> *mut c_schar;
    pub fn strtok_r(__s: *mut c_schar, __delim: *c_schar,
                    __save_ptr: *mut *mut c_schar) -> *mut c_schar;
    pub fn strlen(__s: *c_schar) -> size_t;
    pub fn strnlen(__string: *c_schar, __maxlen: size_t) -> size_t;
    pub fn strerror(__errnum: c_int) -> *mut c_schar;
    pub fn strerror_r(__errnum: c_int, __buf: *mut c_schar, __buflen: size_t)
     -> c_int;
    pub fn strerror_l(__errnum: c_int, __l: __locale_t) -> *mut c_schar;
    pub fn __bzero(__s: *mut c_void, __n: size_t);
    pub fn bcopy(__src: *c_void, __dest: *mut c_void, __n: size_t);
    pub fn bzero(__s: *mut c_void, __n: size_t);
    pub fn bcmp(__s1: *c_void, __s2: *c_void, __n: size_t) -> c_int;
    pub fn index(__s: *c_schar, __c: c_int) -> *mut c_schar;
    pub fn rindex(__s: *c_schar, __c: c_int) -> *mut c_schar;
    pub fn ffs(__i: c_int) -> c_int;
    pub fn strcasecmp(__s1: *c_schar, __s2: *c_schar) -> c_int;
    pub fn strncasecmp(__s1: *c_schar, __s2: *c_schar, __n: size_t) -> c_int;
    pub fn strsep(__stringp: *mut *mut c_schar, __delim: *c_schar) ->
     *mut c_schar;
    pub fn strsignal(__sig: c_int) -> *mut c_schar;
    pub fn __stpcpy(__dest: *mut c_schar, __src: *c_schar) -> *mut c_schar;
    pub fn stpcpy(__dest: *mut c_schar, __src: *c_schar) -> *mut c_schar;
    pub fn __stpncpy(__dest: *mut c_schar, __src: *c_schar, __n: size_t) ->
     *mut c_schar;
    pub fn stpncpy(__dest: *mut c_schar, __src: *c_schar, __n: size_t) ->
     *mut c_schar;
    pub fn av_log2(v: c_uint) -> c_int;
    pub fn av_log2_16bit(v: c_uint) -> c_int;
    pub fn av_strerror(errnum: c_int, errbuf: *mut c_schar,
                       errbuf_size: size_t) -> c_int;
    pub fn av_malloc(size: size_t) -> *mut c_void;
    pub fn av_realloc(ptr: *mut c_void, size: size_t) -> *mut c_void;
    pub fn av_realloc_f(ptr: *mut c_void, nelem: size_t, elsize: size_t) ->
     *mut c_void;
    pub fn av_reallocp(ptr: *mut c_void, size: size_t) -> c_int;
    pub fn av_realloc_array(ptr: *mut c_void, nmemb: size_t, size: size_t) ->
     *mut c_void;
    pub fn av_reallocp_array(ptr: *mut c_void, nmemb: size_t, size: size_t) ->
     c_int;
    pub fn av_free(ptr: *mut c_void);
    pub fn av_mallocz(size: size_t) -> *mut c_void;
    pub fn av_calloc(nmemb: size_t, size: size_t) -> *mut c_void;
    pub fn av_strdup(s: *c_schar) -> *mut c_schar;
    pub fn av_memdup(p: *c_void, size: size_t) -> *mut c_void;
    pub fn av_freep(ptr: *mut c_void);
    pub fn av_dynarray_add(tab_ptr: *mut c_void, nb_ptr: *mut c_int,
                           elem: *mut c_void);
    pub fn av_dynarray2_add(tab_ptr: *mut *mut c_void, nb_ptr: *mut c_int,
                            elem_size: size_t, elem_data: *uint8_t) ->
     *mut c_void;
    pub fn av_max_alloc(max: size_t);
    pub fn av_memcpy_backptr(dst: *mut uint8_t, back: c_int, cnt: c_int);
    pub fn av_fast_realloc(ptr: *mut c_void, size: *mut c_uint,
                           min_size: size_t) -> *mut c_void;
    pub fn av_fast_malloc(ptr: *mut c_void, size: *mut c_uint,
                          min_size: size_t);
    pub fn av_reduce(dst_num: *mut c_int, dst_den: *mut c_int, num: int64_t,
                     den: int64_t, max: int64_t) -> c_int;
    pub fn av_mul_q(b: AVRational, c: AVRational) -> AVRational;
    pub fn av_div_q(b: AVRational, c: AVRational) -> AVRational;
    pub fn av_add_q(b: AVRational, c: AVRational) -> AVRational;
    pub fn av_sub_q(b: AVRational, c: AVRational) -> AVRational;
    pub fn av_d2q(d: c_double, max: c_int) -> AVRational;
    pub fn av_nearer_q(q: AVRational, q1: AVRational, q2: AVRational) ->
     c_int;
    pub fn av_find_nearest_q_idx(q: AVRational, q_list: *AVRational) -> c_int;
    pub fn av_gcd(a: int64_t, b: int64_t) -> int64_t;
    pub fn av_rescale(a: int64_t, b: int64_t, c: int64_t) -> int64_t;
    pub fn av_rescale_rnd(a: int64_t, b: int64_t, c: int64_t,
                          arg1: Enum_AVRounding) -> int64_t;
    pub fn av_rescale_q(a: int64_t, bq: AVRational, cq: AVRational) ->
     int64_t;
    pub fn av_rescale_q_rnd(a: int64_t, bq: AVRational, cq: AVRational,
                            arg1: Enum_AVRounding) -> int64_t;
    pub fn av_compare_ts(ts_a: int64_t, tb_a: AVRational, ts_b: int64_t,
                         tb_b: AVRational) -> c_int;
    pub fn av_compare_mod(a: uint64_t, b: uint64_t, _mod: uint64_t) ->
     int64_t;
    pub fn av_rescale_delta(in_tb: AVRational, in_ts: int64_t,
                            fs_tb: AVRational, duration: c_int,
                            last: *mut int64_t, out_tb: AVRational) ->
     int64_t;
    pub fn av_add_stable(ts_tb: AVRational, ts: int64_t, inc_tb: AVRational,
                         inc: int64_t) -> int64_t;
    pub fn av_log(avcl: *mut c_void, level: c_int, fmt: *c_schar, ...);
    pub fn av_vlog(avcl: *mut c_void, level: c_int, fmt: *c_schar,
                   vl: va_list);
    pub fn av_log_get_level() -> c_int;
    pub fn av_log_set_level(level: c_int);
    pub fn av_log_set_callback(callback:
                                   ::std::option::Option<extern "C" fn
                                                             (arg1:
                                                                  *mut c_void,
                                                              arg2: c_int,
                                                              arg3: *c_schar,
                                                              arg4:
                                                                  va_list)>);
    pub fn av_log_default_callback(avcl: *mut c_void, level: c_int,
                                   fmt: *c_schar, vl: va_list);
    pub fn av_default_item_name(ctx: *mut c_void) -> *c_schar;
    pub fn av_default_get_category(ptr: *mut c_void) -> AVClassCategory;
    pub fn av_log_format_line(ptr: *mut c_void, level: c_int, fmt: *c_schar,
                              vl: va_list, line: *mut c_schar,
                              line_size: c_int, print_prefix: *mut c_int);
    pub fn av_log_set_flags(arg: c_int);
    pub fn av_int_list_length_for_size(elsize: c_uint, list: *c_void,
                                       term: uint64_t) -> c_uint;
    pub fn av_fopen_utf8(path: *c_schar, mode: *c_schar) -> *mut FILE;
    pub fn av_get_sample_fmt_name(sample_fmt: Enum_AVSampleFormat) ->
     *c_schar;
    pub fn av_get_sample_fmt(name: *c_schar) -> Enum_AVSampleFormat;
    pub fn av_get_alt_sample_fmt(sample_fmt: Enum_AVSampleFormat,
                                 planar: c_int) -> Enum_AVSampleFormat;
    pub fn av_get_packed_sample_fmt(sample_fmt: Enum_AVSampleFormat) ->
     Enum_AVSampleFormat;
    pub fn av_get_planar_sample_fmt(sample_fmt: Enum_AVSampleFormat) ->
     Enum_AVSampleFormat;
    pub fn av_get_sample_fmt_string(buf: *mut c_schar, buf_size: c_int,
                                    sample_fmt: Enum_AVSampleFormat) ->
     *mut c_schar;
    pub fn av_get_bits_per_sample_fmt(sample_fmt: Enum_AVSampleFormat) ->
     c_int;
    pub fn av_get_bytes_per_sample(sample_fmt: Enum_AVSampleFormat) -> c_int;
    pub fn av_sample_fmt_is_planar(sample_fmt: Enum_AVSampleFormat) -> c_int;
    pub fn av_samples_get_buffer_size(linesize: *mut c_int,
                                      nb_channels: c_int, nb_samples: c_int,
                                      sample_fmt: Enum_AVSampleFormat,
                                      align: c_int) -> c_int;
    pub fn av_samples_fill_arrays(audio_data: *mut *mut uint8_t,
                                  linesize: *mut c_int, buf: *uint8_t,
                                  nb_channels: c_int, nb_samples: c_int,
                                  sample_fmt: Enum_AVSampleFormat,
                                  align: c_int) -> c_int;
    pub fn av_samples_alloc(audio_data: *mut *mut uint8_t,
                            linesize: *mut c_int, nb_channels: c_int,
                            nb_samples: c_int,
                            sample_fmt: Enum_AVSampleFormat, align: c_int) ->
     c_int;
    pub fn av_samples_alloc_array_and_samples(audio_data:
                                                  *mut *mut *mut uint8_t,
                                              linesize: *mut c_int,
                                              nb_channels: c_int,
                                              nb_samples: c_int,
                                              sample_fmt: Enum_AVSampleFormat,
                                              align: c_int) -> c_int;
    pub fn av_samples_copy(dst: *mut *mut uint8_t, src: **mut uint8_t,
                           dst_offset: c_int, src_offset: c_int,
                           nb_samples: c_int, nb_channels: c_int,
                           sample_fmt: Enum_AVSampleFormat) -> c_int;
    pub fn av_samples_set_silence(audio_data: *mut *mut uint8_t,
                                  offset: c_int, nb_samples: c_int,
                                  nb_channels: c_int,
                                  sample_fmt: Enum_AVSampleFormat) -> c_int;
    pub fn av_buffer_alloc(size: c_int) -> *mut AVBufferRef;
    pub fn av_buffer_allocz(size: c_int) -> *mut AVBufferRef;
    pub fn av_buffer_create(data: *mut uint8_t, size: c_int,
                            free:
                                ::std::option::Option<extern "C" fn
                                                          (arg1: *mut c_void,
                                                           arg2:
                                                               *mut uint8_t)>,
                            opaque: *mut c_void, flags: c_int) ->
     *mut AVBufferRef;
    pub fn av_buffer_default_free(opaque: *mut c_void, data: *mut uint8_t);
    pub fn av_buffer_ref(buf: *mut AVBufferRef) -> *mut AVBufferRef;
    pub fn av_buffer_unref(buf: *mut *mut AVBufferRef);
    pub fn av_buffer_is_writable(buf: *AVBufferRef) -> c_int;
    pub fn av_buffer_get_opaque(buf: *AVBufferRef) -> *mut c_void;
    pub fn av_buffer_get_ref_count(buf: *AVBufferRef) -> c_int;
    pub fn av_buffer_make_writable(buf: *mut *mut AVBufferRef) -> c_int;
    pub fn av_buffer_realloc(buf: *mut *mut AVBufferRef, size: c_int) ->
     c_int;
    pub fn av_buffer_pool_init(size: c_int,
                               alloc:
                                   ::std::option::Option<extern "C" fn
                                                             (arg1: c_int)
                                                             ->
                                                                 *mut AVBufferRef>)
     -> *mut AVBufferPool;
    pub fn av_buffer_pool_uninit(pool: *mut *mut AVBufferPool);
    pub fn av_buffer_pool_get(pool: *mut AVBufferPool) -> *mut AVBufferRef;
    pub fn av_get_cpu_flags() -> c_int;
    pub fn av_force_cpu_flags(flags: c_int);
    pub fn av_set_cpu_flags_mask(mask: c_int);
    pub fn av_parse_cpu_flags(s: *c_schar) -> c_int;
    pub fn av_parse_cpu_caps(flags: *mut c_uint, s: *c_schar) -> c_int;
    pub fn av_cpu_count() -> c_int;
    pub fn av_get_channel_layout(name: *c_schar) -> uint64_t;
    pub fn av_get_channel_layout_string(buf: *mut c_schar, buf_size: c_int,
                                        nb_channels: c_int,
                                        channel_layout: uint64_t);
    pub fn av_bprint_channel_layout(bp: *mut Struct_AVBPrint,
                                    nb_channels: c_int,
                                    channel_layout: uint64_t);
    pub fn av_get_channel_layout_nb_channels(channel_layout: uint64_t) ->
     c_int;
    pub fn av_get_default_channel_layout(nb_channels: c_int) -> int64_t;
    pub fn av_get_channel_layout_channel_index(channel_layout: uint64_t,
                                               channel: uint64_t) -> c_int;
    pub fn av_channel_layout_extract_channel(channel_layout: uint64_t,
                                             index: c_int) -> uint64_t;
    pub fn av_get_channel_name(channel: uint64_t) -> *c_schar;
    pub fn av_get_channel_description(channel: uint64_t) -> *c_schar;
    pub fn av_get_standard_channel_layout(index: c_uint,
                                          layout: *mut uint64_t,
                                          name: *mut *c_schar) -> c_int;
    pub fn av_dict_get(m: *mut AVDictionary, key: *c_schar,
                       prev: *AVDictionaryEntry, flags: c_int) ->
     *mut AVDictionaryEntry;
    pub fn av_dict_count(m: *AVDictionary) -> c_int;
    pub fn av_dict_set(pm: *mut *mut AVDictionary, key: *c_schar,
                       value: *c_schar, flags: c_int) -> c_int;
    pub fn av_dict_parse_string(pm: *mut *mut AVDictionary, str: *c_schar,
                                key_val_sep: *c_schar, pairs_sep: *c_schar,
                                flags: c_int) -> c_int;
    pub fn av_dict_copy(dst: *mut *mut AVDictionary, src: *mut AVDictionary,
                        flags: c_int);
    pub fn av_dict_free(m: *mut *mut AVDictionary);
    pub fn av_frame_get_best_effort_timestamp(frame: *AVFrame) -> int64_t;
    pub fn av_frame_set_best_effort_timestamp(frame: *mut AVFrame,
                                              val: int64_t);
    pub fn av_frame_get_pkt_duration(frame: *AVFrame) -> int64_t;
    pub fn av_frame_set_pkt_duration(frame: *mut AVFrame, val: int64_t);
    pub fn av_frame_get_pkt_pos(frame: *AVFrame) -> int64_t;
    pub fn av_frame_set_pkt_pos(frame: *mut AVFrame, val: int64_t);
    pub fn av_frame_get_channel_layout(frame: *AVFrame) -> int64_t;
    pub fn av_frame_set_channel_layout(frame: *mut AVFrame, val: int64_t);
    pub fn av_frame_get_channels(frame: *AVFrame) -> c_int;
    pub fn av_frame_set_channels(frame: *mut AVFrame, val: c_int);
    pub fn av_frame_get_sample_rate(frame: *AVFrame) -> c_int;
    pub fn av_frame_set_sample_rate(frame: *mut AVFrame, val: c_int);
    pub fn av_frame_get_metadata(frame: *AVFrame) -> *mut AVDictionary;
    pub fn av_frame_set_metadata(frame: *mut AVFrame, val: *mut AVDictionary);
    pub fn av_frame_get_decode_error_flags(frame: *AVFrame) -> c_int;
    pub fn av_frame_set_decode_error_flags(frame: *mut AVFrame, val: c_int);
    pub fn av_frame_get_pkt_size(frame: *AVFrame) -> c_int;
    pub fn av_frame_set_pkt_size(frame: *mut AVFrame, val: c_int);
    pub fn avpriv_frame_get_metadatap(frame: *mut AVFrame) ->
     *mut *mut AVDictionary;
    pub fn av_frame_get_qp_table(f: *mut AVFrame, stride: *mut c_int,
                                 _type: *mut c_int) -> *mut int8_t;
    pub fn av_frame_set_qp_table(f: *mut AVFrame, buf: *mut AVBufferRef,
                                 stride: c_int, _type: c_int) -> c_int;
    pub fn av_frame_get_colorspace(frame: *AVFrame) -> Enum_AVColorSpace;
    pub fn av_frame_set_colorspace(frame: *mut AVFrame,
                                   val: Enum_AVColorSpace);
    pub fn av_frame_get_color_range(frame: *AVFrame) -> Enum_AVColorRange;
    pub fn av_frame_set_color_range(frame: *mut AVFrame,
                                    val: Enum_AVColorRange);
    pub fn av_get_colorspace_name(val: Enum_AVColorSpace) -> *c_schar;
    pub fn av_frame_alloc() -> *mut AVFrame;
    pub fn av_frame_free(frame: *mut *mut AVFrame);
    pub fn av_frame_ref(dst: *mut AVFrame, src: *AVFrame) -> c_int;
    pub fn av_frame_clone(src: *AVFrame) -> *mut AVFrame;
    pub fn av_frame_unref(frame: *mut AVFrame);
    pub fn av_frame_move_ref(dst: *mut AVFrame, src: *mut AVFrame);
    pub fn av_frame_get_buffer(frame: *mut AVFrame, align: c_int) -> c_int;
    pub fn av_frame_is_writable(frame: *mut AVFrame) -> c_int;
    pub fn av_frame_make_writable(frame: *mut AVFrame) -> c_int;
    pub fn av_frame_copy(dst: *mut AVFrame, src: *AVFrame) -> c_int;
    pub fn av_frame_copy_props(dst: *mut AVFrame, src: *AVFrame) -> c_int;
    pub fn av_frame_get_plane_buffer(frame: *mut AVFrame, plane: c_int) ->
     *mut AVBufferRef;
    pub fn av_frame_new_side_data(frame: *mut AVFrame,
                                  _type: Enum_AVFrameSideDataType,
                                  size: c_int) -> *mut AVFrameSideData;
    pub fn av_frame_get_side_data(frame: *AVFrame,
                                  _type: Enum_AVFrameSideDataType) ->
     *mut AVFrameSideData;
    pub fn av_codec_get_pkt_timebase(avctx: *AVCodecContext) -> AVRational;
    pub fn av_codec_set_pkt_timebase(avctx: *mut AVCodecContext,
                                     val: AVRational);
    pub fn av_codec_get_codec_descriptor(avctx: *AVCodecContext) ->
     *AVCodecDescriptor;
    pub fn av_codec_set_codec_descriptor(avctx: *mut AVCodecContext,
                                         desc: *AVCodecDescriptor);
    pub fn av_codec_get_lowres(avctx: *AVCodecContext) -> c_int;
    pub fn av_codec_set_lowres(avctx: *mut AVCodecContext, val: c_int);
    pub fn av_codec_get_seek_preroll(avctx: *AVCodecContext) -> c_int;
    pub fn av_codec_set_seek_preroll(avctx: *mut AVCodecContext, val: c_int);
    pub fn av_codec_get_chroma_intra_matrix(avctx: *AVCodecContext) ->
     *mut uint16_t;
    pub fn av_codec_set_chroma_intra_matrix(avctx: *mut AVCodecContext,
                                            val: *mut uint16_t);
    pub fn av_codec_get_max_lowres(codec: *AVCodec) -> c_int;
    pub fn av_codec_next(c: *AVCodec) -> *mut AVCodec;
    pub fn avcodec_version() -> c_uint;
    pub fn avcodec_configuration() -> *c_schar;
    pub fn avcodec_license() -> *c_schar;
    pub fn avcodec_register(codec: *mut AVCodec);
    pub fn avcodec_register_all();
    pub fn avcodec_alloc_context3(codec: *AVCodec) -> *mut AVCodecContext;
    pub fn avcodec_get_context_defaults3(s: *mut AVCodecContext,
                                         codec: *AVCodec) -> c_int;
    pub fn avcodec_get_class() -> *AVClass;
    pub fn avcodec_get_frame_class() -> *AVClass;
    pub fn avcodec_get_subtitle_rect_class() -> *AVClass;
    pub fn avcodec_copy_context(dest: *mut AVCodecContext,
                                src: *AVCodecContext) -> c_int;
    pub fn avcodec_alloc_frame() -> *mut AVFrame;
    pub fn avcodec_get_frame_defaults(frame: *mut AVFrame);
    pub fn avcodec_free_frame(frame: *mut *mut AVFrame);
    pub fn avcodec_open2(avctx: *mut AVCodecContext, codec: *AVCodec,
                         options: *mut *mut AVDictionary) -> c_int;
    pub fn avcodec_close(avctx: *mut AVCodecContext) -> c_int;
    pub fn avsubtitle_free(sub: *mut AVSubtitle);
    pub fn av_destruct_packet(pkt: *mut AVPacket);
    pub fn av_init_packet(pkt: *mut AVPacket);
    pub fn av_new_packet(pkt: *mut AVPacket, size: c_int) -> c_int;
    pub fn av_shrink_packet(pkt: *mut AVPacket, size: c_int);
    pub fn av_grow_packet(pkt: *mut AVPacket, grow_by: c_int) -> c_int;
    pub fn av_packet_from_data(pkt: *mut AVPacket, data: *mut uint8_t,
                               size: c_int) -> c_int;
    pub fn av_dup_packet(pkt: *mut AVPacket) -> c_int;
    pub fn av_copy_packet(dst: *mut AVPacket, src: *mut AVPacket) -> c_int;
    pub fn av_copy_packet_side_data(dst: *mut AVPacket, src: *mut AVPacket) ->
     c_int;
    pub fn av_free_packet(pkt: *mut AVPacket);
    pub fn av_packet_new_side_data(pkt: *mut AVPacket,
                                   _type: Enum_AVPacketSideDataType,
                                   size: c_int) -> *mut uint8_t;
    pub fn av_packet_shrink_side_data(pkt: *mut AVPacket,
                                      _type: Enum_AVPacketSideDataType,
                                      size: c_int) -> c_int;
    pub fn av_packet_get_side_data(pkt: *mut AVPacket,
                                   _type: Enum_AVPacketSideDataType,
                                   size: *mut c_int) -> *mut uint8_t;
    pub fn av_packet_merge_side_data(pkt: *mut AVPacket) -> c_int;
    pub fn av_packet_split_side_data(pkt: *mut AVPacket) -> c_int;
    pub fn av_packet_pack_dictionary(dict: *mut AVDictionary,
                                     size: *mut c_int) -> *mut uint8_t;
    pub fn av_packet_unpack_dictionary(data: *uint8_t, size: c_int,
                                       dict: *mut *mut AVDictionary) -> c_int;
    pub fn av_packet_free_side_data(pkt: *mut AVPacket);
    pub fn av_packet_ref(dst: *mut AVPacket, src: *mut AVPacket) -> c_int;
    pub fn av_packet_unref(pkt: *mut AVPacket);
    pub fn av_packet_move_ref(dst: *mut AVPacket, src: *mut AVPacket);
    pub fn av_packet_copy_props(dst: *mut AVPacket, src: *AVPacket) -> c_int;
    pub fn avcodec_find_decoder(id: Enum_AVCodecID) -> *mut AVCodec;
    pub fn avcodec_find_decoder_by_name(name: *c_schar) -> *mut AVCodec;
    pub fn avcodec_default_get_buffer(s: *mut AVCodecContext,
                                      pic: *mut AVFrame) -> c_int;
    pub fn avcodec_default_release_buffer(s: *mut AVCodecContext,
                                          pic: *mut AVFrame);
    pub fn avcodec_default_reget_buffer(s: *mut AVCodecContext,
                                        pic: *mut AVFrame) -> c_int;
    pub fn avcodec_default_get_buffer2(s: *mut AVCodecContext,
                                       frame: *mut AVFrame, flags: c_int) ->
     c_int;
    pub fn avcodec_get_edge_width() -> c_uint;
    pub fn avcodec_align_dimensions(s: *mut AVCodecContext, width: *mut c_int,
                                    height: *mut c_int);
    pub fn avcodec_align_dimensions2(s: *mut AVCodecContext,
                                     width: *mut c_int, height: *mut c_int,
                                     linesize_align: [c_int, ..8u]);
    pub fn avcodec_enum_to_chroma_pos(xpos: *mut c_int, ypos: *mut c_int,
                                      pos: Enum_AVChromaLocation) -> c_int;
    pub fn avcodec_chroma_pos_to_enum(xpos: c_int, ypos: c_int) ->
     Enum_AVChromaLocation;
    pub fn avcodec_decode_audio3(avctx: *mut AVCodecContext,
                                 samples: *mut int16_t,
                                 frame_size_ptr: *mut c_int,
                                 avpkt: *mut AVPacket) -> c_int;
    pub fn avcodec_decode_audio4(avctx: *mut AVCodecContext,
                                 frame: *mut AVFrame,
                                 got_frame_ptr: *mut c_int, avpkt: *AVPacket)
     -> c_int;
    pub fn avcodec_decode_video2(avctx: *mut AVCodecContext,
                                 picture: *mut AVFrame,
                                 got_picture_ptr: *mut c_int,
                                 avpkt: *AVPacket) -> c_int;
    pub fn avcodec_decode_subtitle2(avctx: *mut AVCodecContext,
                                    sub: *mut AVSubtitle,
                                    got_sub_ptr: *mut c_int,
                                    avpkt: *mut AVPacket) -> c_int;
    pub fn av_parser_next(c: *mut AVCodecParser) -> *mut AVCodecParser;
    pub fn av_register_codec_parser(parser: *mut AVCodecParser);
    pub fn av_parser_init(codec_id: c_int) -> *mut AVCodecParserContext;
    pub fn av_parser_parse2(s: *mut AVCodecParserContext,
                            avctx: *mut AVCodecContext,
                            poutbuf: *mut *mut uint8_t,
                            poutbuf_size: *mut c_int, buf: *uint8_t,
                            buf_size: c_int, pts: int64_t, dts: int64_t,
                            pos: int64_t) -> c_int;
    pub fn av_parser_change(s: *mut AVCodecParserContext,
                            avctx: *mut AVCodecContext,
                            poutbuf: *mut *mut uint8_t,
                            poutbuf_size: *mut c_int, buf: *uint8_t,
                            buf_size: c_int, keyframe: c_int) -> c_int;
    pub fn av_parser_close(s: *mut AVCodecParserContext);
    pub fn avcodec_find_encoder(id: Enum_AVCodecID) -> *mut AVCodec;
    pub fn avcodec_find_encoder_by_name(name: *c_schar) -> *mut AVCodec;
    pub fn avcodec_encode_audio(avctx: *mut AVCodecContext, buf: *mut uint8_t,
                                buf_size: c_int, samples: *c_short) -> c_int;
    pub fn avcodec_encode_audio2(avctx: *mut AVCodecContext,
                                 avpkt: *mut AVPacket, frame: *AVFrame,
                                 got_packet_ptr: *mut c_int) -> c_int;
    pub fn avcodec_encode_video(avctx: *mut AVCodecContext, buf: *mut uint8_t,
                                buf_size: c_int, pict: *AVFrame) -> c_int;
    pub fn avcodec_encode_video2(avctx: *mut AVCodecContext,
                                 avpkt: *mut AVPacket, frame: *AVFrame,
                                 got_packet_ptr: *mut c_int) -> c_int;
    pub fn avcodec_encode_subtitle(avctx: *mut AVCodecContext,
                                   buf: *mut uint8_t, buf_size: c_int,
                                   sub: *AVSubtitle) -> c_int;
    pub fn av_audio_resample_init(output_channels: c_int,
                                  input_channels: c_int, output_rate: c_int,
                                  input_rate: c_int,
                                  sample_fmt_out: Enum_AVSampleFormat,
                                  sample_fmt_in: Enum_AVSampleFormat,
                                  filter_length: c_int,
                                  log2_phase_count: c_int, linear: c_int,
                                  cutoff: c_double) -> *mut ReSampleContext;
    pub fn audio_resample(s: *mut ReSampleContext, output: *mut c_short,
                          input: *mut c_short, nb_samples: c_int) -> c_int;
    pub fn audio_resample_close(s: *mut ReSampleContext);
    pub fn av_resample_init(out_rate: c_int, in_rate: c_int,
                            filter_length: c_int, log2_phase_count: c_int,
                            linear: c_int, cutoff: c_double) ->
     *mut Struct_AVResampleContext;
    pub fn av_resample(c: *mut Struct_AVResampleContext, dst: *mut c_short,
                       src: *mut c_short, consumed: *mut c_int,
                       src_size: c_int, dst_size: c_int, update_ctx: c_int) ->
     c_int;
    pub fn av_resample_compensate(c: *mut Struct_AVResampleContext,
                                  sample_delta: c_int,
                                  compensation_distance: c_int);
    pub fn av_resample_close(c: *mut Struct_AVResampleContext);
    pub fn avpicture_alloc(picture: *mut AVPicture,
                           pix_fmt: Enum_AVPixelFormat, width: c_int,
                           height: c_int) -> c_int;
    pub fn avpicture_free(picture: *mut AVPicture);
    pub fn avpicture_fill(picture: *mut AVPicture, ptr: *uint8_t,
                          pix_fmt: Enum_AVPixelFormat, width: c_int,
                          height: c_int) -> c_int;
    pub fn avpicture_layout(src: *AVPicture, pix_fmt: Enum_AVPixelFormat,
                            width: c_int, height: c_int, dest: *mut c_uchar,
                            dest_size: c_int) -> c_int;
    pub fn avpicture_get_size(pix_fmt: Enum_AVPixelFormat, width: c_int,
                              height: c_int) -> c_int;
    pub fn avpicture_deinterlace(dst: *mut AVPicture, src: *AVPicture,
                                 pix_fmt: Enum_AVPixelFormat, width: c_int,
                                 height: c_int) -> c_int;
    pub fn av_picture_copy(dst: *mut AVPicture, src: *AVPicture,
                           pix_fmt: Enum_AVPixelFormat, width: c_int,
                           height: c_int);
    pub fn av_picture_crop(dst: *mut AVPicture, src: *AVPicture,
                           pix_fmt: Enum_AVPixelFormat, top_band: c_int,
                           left_band: c_int) -> c_int;
    pub fn av_picture_pad(dst: *mut AVPicture, src: *AVPicture, height: c_int,
                          width: c_int, pix_fmt: Enum_AVPixelFormat,
                          padtop: c_int, padbottom: c_int, padleft: c_int,
                          padright: c_int, color: *mut c_int) -> c_int;
    pub fn avcodec_get_chroma_sub_sample(pix_fmt: Enum_AVPixelFormat,
                                         h_shift: *mut c_int,
                                         v_shift: *mut c_int);
    pub fn avcodec_pix_fmt_to_codec_tag(pix_fmt: Enum_AVPixelFormat) ->
     c_uint;
    pub fn avcodec_get_pix_fmt_loss(dst_pix_fmt: Enum_AVPixelFormat,
                                    src_pix_fmt: Enum_AVPixelFormat,
                                    has_alpha: c_int) -> c_int;
    pub fn avcodec_find_best_pix_fmt_of_list(pix_fmt_list:
                                                 *Enum_AVPixelFormat,
                                             src_pix_fmt: Enum_AVPixelFormat,
                                             has_alpha: c_int,
                                             loss_ptr: *mut c_int) ->
     Enum_AVPixelFormat;
    pub fn avcodec_find_best_pix_fmt_of_2(dst_pix_fmt1: Enum_AVPixelFormat,
                                          dst_pix_fmt2: Enum_AVPixelFormat,
                                          src_pix_fmt: Enum_AVPixelFormat,
                                          has_alpha: c_int,
                                          loss_ptr: *mut c_int) ->
     Enum_AVPixelFormat;
    pub fn avcodec_find_best_pix_fmt2(dst_pix_fmt1: Enum_AVPixelFormat,
                                      dst_pix_fmt2: Enum_AVPixelFormat,
                                      src_pix_fmt: Enum_AVPixelFormat,
                                      has_alpha: c_int, loss_ptr: *mut c_int)
     -> Enum_AVPixelFormat;
    pub fn avcodec_default_get_format(s: *mut Struct_AVCodecContext,
                                      fmt: *Enum_AVPixelFormat) ->
     Enum_AVPixelFormat;
    pub fn avcodec_set_dimensions(s: *mut AVCodecContext, width: c_int,
                                  height: c_int);
    pub fn av_get_codec_tag_string(buf: *mut c_schar, buf_size: size_t,
                                   codec_tag: c_uint) -> size_t;
    pub fn avcodec_string(buf: *mut c_schar, buf_size: c_int,
                          enc: *mut AVCodecContext, encode: c_int);
    pub fn av_get_profile_name(codec: *AVCodec, profile: c_int) -> *c_schar;
    pub fn avcodec_default_execute(c: *mut AVCodecContext,
                                   func:
                                       ::std::option::Option<extern "C" fn
                                                                 (arg1:
                                                                      *mut AVCodecContext,
                                                                  arg2:
                                                                      *mut c_void)
                                                                 -> c_int>,
                                   arg: *mut c_void, ret: *mut c_int,
                                   count: c_int, size: c_int) -> c_int;
    pub fn avcodec_default_execute2(c: *mut AVCodecContext,
                                    func:
                                        ::std::option::Option<extern "C" fn
                                                                  (arg1:
                                                                       *mut AVCodecContext,
                                                                   arg2:
                                                                       *mut c_void,
                                                                   arg3:
                                                                       c_int,
                                                                   arg4:
                                                                       c_int)
                                                                  -> c_int>,
                                    arg: *mut c_void, ret: *mut c_int,
                                    count: c_int) -> c_int;
    pub fn avcodec_fill_audio_frame(frame: *mut AVFrame, nb_channels: c_int,
                                    sample_fmt: Enum_AVSampleFormat,
                                    buf: *uint8_t, buf_size: c_int,
                                    align: c_int) -> c_int;
    pub fn avcodec_flush_buffers(avctx: *mut AVCodecContext);
    pub fn av_get_bits_per_sample(codec_id: Enum_AVCodecID) -> c_int;
    pub fn av_get_pcm_codec(fmt: Enum_AVSampleFormat, _be: c_int) ->
     Enum_AVCodecID;
    pub fn av_get_exact_bits_per_sample(codec_id: Enum_AVCodecID) -> c_int;
    pub fn av_get_audio_frame_duration(avctx: *mut AVCodecContext,
                                       frame_bytes: c_int) -> c_int;
    pub fn av_register_bitstream_filter(bsf: *mut AVBitStreamFilter);
    pub fn av_bitstream_filter_init(name: *c_schar) ->
     *mut AVBitStreamFilterContext;
    pub fn av_bitstream_filter_filter(bsfc: *mut AVBitStreamFilterContext,
                                      avctx: *mut AVCodecContext,
                                      args: *c_schar,
                                      poutbuf: *mut *mut uint8_t,
                                      poutbuf_size: *mut c_int, buf: *uint8_t,
                                      buf_size: c_int, keyframe: c_int) ->
     c_int;
    pub fn av_bitstream_filter_close(bsf: *mut AVBitStreamFilterContext);
    pub fn av_bitstream_filter_next(f: *mut AVBitStreamFilter) ->
     *mut AVBitStreamFilter;
    pub fn av_fast_padded_malloc(ptr: *mut c_void, size: *mut c_uint,
                                 min_size: size_t);
    pub fn av_fast_padded_mallocz(ptr: *mut c_void, size: *mut c_uint,
                                  min_size: size_t);
    pub fn av_xiphlacing(s: *mut c_uchar, v: c_uint) -> c_uint;
    pub fn av_log_missing_feature(avc: *mut c_void, feature: *c_schar,
                                  want_sample: c_int);
    pub fn av_log_ask_for_sample(avc: *mut c_void, msg: *c_schar, ...);
    pub fn av_register_hwaccel(hwaccel: *mut AVHWAccel);
    pub fn av_hwaccel_next(hwaccel: *mut AVHWAccel) -> *mut AVHWAccel;
    pub fn av_lockmgr_register(cb:
                                   ::std::option::Option<extern "C" fn
                                                             (arg1:
                                                                  *mut *mut c_void,
                                                              arg2:
                                                                  Enum_AVLockOp)
                                                             -> c_int>) ->
     c_int;
    pub fn avcodec_get_type(codec_id: Enum_AVCodecID) -> Enum_AVMediaType;
    pub fn avcodec_get_name(id: Enum_AVCodecID) -> *c_schar;
    pub fn avcodec_is_open(s: *mut AVCodecContext) -> c_int;
    pub fn av_codec_is_encoder(codec: *AVCodec) -> c_int;
    pub fn av_codec_is_decoder(codec: *AVCodec) -> c_int;
    pub fn avcodec_descriptor_get(id: Enum_AVCodecID) -> *AVCodecDescriptor;
    pub fn avcodec_descriptor_next(prev: *AVCodecDescriptor) ->
     *AVCodecDescriptor;
    pub fn avcodec_descriptor_get_by_name(name: *c_schar) ->
     *AVCodecDescriptor;
    pub fn clock() -> clock_t;
    pub fn time(__timer: *mut time_t) -> time_t;
    pub fn difftime(__time1: time_t, __time0: time_t) -> c_double;
    pub fn mktime(__tp: *mut Struct_tm) -> time_t;
    pub fn strftime(__s: *mut c_schar, __maxsize: size_t, __format: *c_schar,
                    __tp: *Struct_tm) -> size_t;
    pub fn strftime_l(__s: *mut c_schar, __maxsize: size_t,
                      __format: *c_schar, __tp: *Struct_tm, __loc: __locale_t)
     -> size_t;
    pub fn gmtime(__timer: *time_t) -> *mut Struct_tm;
    pub fn localtime(__timer: *time_t) -> *mut Struct_tm;
    pub fn gmtime_r(__timer: *time_t, __tp: *mut Struct_tm) -> *mut Struct_tm;
    pub fn localtime_r(__timer: *time_t, __tp: *mut Struct_tm) ->
     *mut Struct_tm;
    pub fn asctime(__tp: *Struct_tm) -> *mut c_schar;
    pub fn ctime(__timer: *time_t) -> *mut c_schar;
    pub fn asctime_r(__tp: *Struct_tm, __buf: *mut c_schar) -> *mut c_schar;
    pub fn ctime_r(__timer: *time_t, __buf: *mut c_schar) -> *mut c_schar;
    pub fn tzset();
    pub fn stime(__when: *time_t) -> c_int;
    pub fn timegm(__tp: *mut Struct_tm) -> time_t;
    pub fn timelocal(__tp: *mut Struct_tm) -> time_t;
    pub fn dysize(__year: c_int) -> c_int;
    pub fn nanosleep(__requested_time: *Struct_timespec,
                     __remaining: *mut Struct_timespec) -> c_int;
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut Struct_timespec) ->
     c_int;
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut Struct_timespec) ->
     c_int;
    pub fn clock_settime(__clock_id: clockid_t, __tp: *Struct_timespec) ->
     c_int;
    pub fn clock_nanosleep(__clock_id: clockid_t, __flags: c_int,
                           __req: *Struct_timespec,
                           __rem: *mut Struct_timespec) -> c_int;
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t) ->
     c_int;
    pub fn timer_create(__clock_id: clockid_t, __evp: *mut Struct_sigevent,
                        __timerid: *mut timer_t) -> c_int;
    pub fn timer_delete(__timerid: timer_t) -> c_int;
    pub fn timer_settime(__timerid: timer_t, __flags: c_int,
                         __value: *Struct_itimerspec,
                         __ovalue: *mut Struct_itimerspec) -> c_int;
    pub fn timer_gettime(__timerid: timer_t, __value: *mut Struct_itimerspec)
     -> c_int;
    pub fn timer_getoverrun(__timerid: timer_t) -> c_int;
    pub fn avio_find_protocol_name(url: *c_schar) -> *c_schar;
    pub fn avio_check(url: *c_schar, flags: c_int) -> c_int;
    pub fn avio_alloc_context(buffer: *mut c_uchar, buffer_size: c_int,
                              write_flag: c_int, opaque: *mut c_void,
                              read_packet:
                                  ::std::option::Option<extern "C" fn
                                                            (arg1:
                                                                 *mut c_void,
                                                             arg2:
                                                                 *mut uint8_t,
                                                             arg3: c_int)
                                                            -> c_int>,
                              write_packet:
                                  ::std::option::Option<extern "C" fn
                                                            (arg1:
                                                                 *mut c_void,
                                                             arg2:
                                                                 *mut uint8_t,
                                                             arg3: c_int)
                                                            -> c_int>,
                              seek:
                                  ::std::option::Option<extern "C" fn
                                                            (arg1:
                                                                 *mut c_void,
                                                             arg2: int64_t,
                                                             arg3: c_int)
                                                            -> int64_t>) ->
     *mut AVIOContext;
    pub fn avio_w8(s: *mut AVIOContext, b: c_int);
    pub fn avio_write(s: *mut AVIOContext, buf: *c_uchar, size: c_int);
    pub fn avio_wl64(s: *mut AVIOContext, val: uint64_t);
    pub fn avio_wb64(s: *mut AVIOContext, val: uint64_t);
    pub fn avio_wl32(s: *mut AVIOContext, val: c_uint);
    pub fn avio_wb32(s: *mut AVIOContext, val: c_uint);
    pub fn avio_wl24(s: *mut AVIOContext, val: c_uint);
    pub fn avio_wb24(s: *mut AVIOContext, val: c_uint);
    pub fn avio_wl16(s: *mut AVIOContext, val: c_uint);
    pub fn avio_wb16(s: *mut AVIOContext, val: c_uint);
    pub fn avio_put_str(s: *mut AVIOContext, str: *c_schar) -> c_int;
    pub fn avio_put_str16le(s: *mut AVIOContext, str: *c_schar) -> c_int;
    pub fn avio_seek(s: *mut AVIOContext, offset: int64_t, whence: c_int) ->
     int64_t;
    pub fn avio_skip(s: *mut AVIOContext, offset: int64_t) -> int64_t;
    pub fn avio_size(s: *mut AVIOContext) -> int64_t;
    pub fn url_feof(s: *mut AVIOContext) -> c_int;
    pub fn avio_printf(s: *mut AVIOContext, fmt: *c_schar, ...) -> c_int;
    pub fn avio_flush(s: *mut AVIOContext);
    pub fn avio_read(s: *mut AVIOContext, buf: *mut c_uchar, size: c_int) ->
     c_int;
    pub fn avio_r8(s: *mut AVIOContext) -> c_int;
    pub fn avio_rl16(s: *mut AVIOContext) -> c_uint;
    pub fn avio_rl24(s: *mut AVIOContext) -> c_uint;
    pub fn avio_rl32(s: *mut AVIOContext) -> c_uint;
    pub fn avio_rl64(s: *mut AVIOContext) -> uint64_t;
    pub fn avio_rb16(s: *mut AVIOContext) -> c_uint;
    pub fn avio_rb24(s: *mut AVIOContext) -> c_uint;
    pub fn avio_rb32(s: *mut AVIOContext) -> c_uint;
    pub fn avio_rb64(s: *mut AVIOContext) -> uint64_t;
    pub fn avio_get_str(pb: *mut AVIOContext, maxlen: c_int,
                        buf: *mut c_schar, buflen: c_int) -> c_int;
    pub fn avio_get_str16le(pb: *mut AVIOContext, maxlen: c_int,
                            buf: *mut c_schar, buflen: c_int) -> c_int;
    pub fn avio_get_str16be(pb: *mut AVIOContext, maxlen: c_int,
                            buf: *mut c_schar, buflen: c_int) -> c_int;
    pub fn avio_open(s: *mut *mut AVIOContext, url: *c_schar, flags: c_int) ->
     c_int;
    pub fn avio_open2(s: *mut *mut AVIOContext, url: *c_schar, flags: c_int,
                      int_cb: *AVIOInterruptCB,
                      options: *mut *mut AVDictionary) -> c_int;
    pub fn avio_close(s: *mut AVIOContext) -> c_int;
    pub fn avio_closep(s: *mut *mut AVIOContext) -> c_int;
    pub fn avio_open_dyn_buf(s: *mut *mut AVIOContext) -> c_int;
    pub fn avio_close_dyn_buf(s: *mut AVIOContext, pbuffer: *mut *mut uint8_t)
     -> c_int;
    pub fn avio_enum_protocols(opaque: *mut *mut c_void, output: c_int) ->
     *c_schar;
    pub fn avio_pause(h: *mut AVIOContext, pause: c_int) -> c_int;
    pub fn avio_seek_time(h: *mut AVIOContext, stream_index: c_int,
                          timestamp: int64_t, flags: c_int) -> int64_t;
    pub fn av_get_packet(s: *mut AVIOContext, pkt: *mut AVPacket, size: c_int)
     -> c_int;
    pub fn av_append_packet(s: *mut AVIOContext, pkt: *mut AVPacket,
                            size: c_int) -> c_int;
    pub fn av_stream_get_r_frame_rate(s: *AVStream) -> AVRational;
    pub fn av_stream_set_r_frame_rate(s: *mut AVStream, r: AVRational);
    pub fn av_format_get_probe_score(s: *AVFormatContext) -> c_int;
    pub fn av_format_get_video_codec(s: *AVFormatContext) -> *mut AVCodec;
    pub fn av_format_set_video_codec(s: *mut AVFormatContext,
                                     c: *mut AVCodec);
    pub fn av_format_get_audio_codec(s: *AVFormatContext) -> *mut AVCodec;
    pub fn av_format_set_audio_codec(s: *mut AVFormatContext,
                                     c: *mut AVCodec);
    pub fn av_format_get_subtitle_codec(s: *AVFormatContext) -> *mut AVCodec;
    pub fn av_format_set_subtitle_codec(s: *mut AVFormatContext,
                                        c: *mut AVCodec);
    pub fn av_format_get_metadata_header_padding(s: *AVFormatContext) ->
     c_int;
    pub fn av_format_set_metadata_header_padding(s: *mut AVFormatContext,
                                                 c: c_int);
    pub fn av_format_get_opaque(s: *AVFormatContext) -> *mut c_void;
    pub fn av_format_set_opaque(s: *mut AVFormatContext, opaque: *mut c_void);
    pub fn av_format_get_control_message_cb(s: *AVFormatContext) ->
     av_format_control_message;
    pub fn av_format_set_control_message_cb(s: *mut AVFormatContext,
                                            callback:
                                                av_format_control_message);
    pub fn av_fmt_ctx_get_duration_estimation_method(ctx: *AVFormatContext) ->
     Enum_AVDurationEstimationMethod;
    pub fn avformat_version() -> c_uint;
    pub fn avformat_configuration() -> *c_schar;
    pub fn avformat_license() -> *c_schar;
    pub fn av_register_all();
    pub fn av_register_input_format(format: *mut AVInputFormat);
    pub fn av_register_output_format(format: *mut AVOutputFormat);
    pub fn avformat_network_init() -> c_int;
    pub fn avformat_network_deinit() -> c_int;
    pub fn av_iformat_next(f: *mut AVInputFormat) -> *mut AVInputFormat;
    pub fn av_oformat_next(f: *mut AVOutputFormat) -> *mut AVOutputFormat;
    pub fn avformat_alloc_context() -> *mut AVFormatContext;
    pub fn avformat_free_context(s: *mut AVFormatContext);
    pub fn avformat_get_class() -> *AVClass;
    pub fn avformat_new_stream(s: *mut AVFormatContext, c: *AVCodec) ->
     *mut AVStream;
    pub fn av_new_program(s: *mut AVFormatContext, id: c_int) ->
     *mut AVProgram;
    pub fn avformat_alloc_output_context(format: *c_schar,
                                         oformat: *mut AVOutputFormat,
                                         filename: *c_schar) ->
     *mut AVFormatContext;
    pub fn avformat_alloc_output_context2(ctx: *mut *mut AVFormatContext,
                                          oformat: *mut AVOutputFormat,
                                          format_name: *c_schar,
                                          filename: *c_schar) -> c_int;
    pub fn av_find_input_format(short_name: *c_schar) -> *mut AVInputFormat;
    pub fn av_probe_input_format(pd: *mut AVProbeData, is_opened: c_int) ->
     *mut AVInputFormat;
    pub fn av_probe_input_format2(pd: *mut AVProbeData, is_opened: c_int,
                                  score_max: *mut c_int) ->
     *mut AVInputFormat;
    pub fn av_probe_input_format3(pd: *mut AVProbeData, is_opened: c_int,
                                  score_ret: *mut c_int) ->
     *mut AVInputFormat;
    pub fn av_probe_input_buffer2(pb: *mut AVIOContext,
                                  fmt: *mut *mut AVInputFormat,
                                  filename: *c_schar, logctx: *mut c_void,
                                  offset: c_uint, max_probe_size: c_uint) ->
     c_int;
    pub fn av_probe_input_buffer(pb: *mut AVIOContext,
                                 fmt: *mut *mut AVInputFormat,
                                 filename: *c_schar, logctx: *mut c_void,
                                 offset: c_uint, max_probe_size: c_uint) ->
     c_int;
    pub fn avformat_open_input(ps: *mut *mut AVFormatContext,
                               filename: *c_schar, fmt: *mut AVInputFormat,
                               options: *mut *mut AVDictionary) -> c_int;
    pub fn av_demuxer_open(ic: *mut AVFormatContext) -> c_int;
    pub fn av_find_stream_info(ic: *mut AVFormatContext) -> c_int;
    pub fn avformat_find_stream_info(ic: *mut AVFormatContext,
                                     options: *mut *mut AVDictionary) ->
     c_int;
    pub fn av_find_program_from_stream(ic: *mut AVFormatContext,
                                       last: *mut AVProgram, s: c_int) ->
     *mut AVProgram;
    pub fn av_find_best_stream(ic: *mut AVFormatContext,
                               _type: Enum_AVMediaType,
                               wanted_stream_nb: c_int, related_stream: c_int,
                               decoder_ret: *mut *mut AVCodec, flags: c_int)
     -> c_int;
    pub fn av_read_packet(s: *mut AVFormatContext, pkt: *mut AVPacket) ->
     c_int;
    pub fn av_read_frame(s: *mut AVFormatContext, pkt: *mut AVPacket) ->
     c_int;
    pub fn av_seek_frame(s: *mut AVFormatContext, stream_index: c_int,
                         timestamp: int64_t, flags: c_int) -> c_int;
    pub fn avformat_seek_file(s: *mut AVFormatContext, stream_index: c_int,
                              min_ts: int64_t, ts: int64_t, max_ts: int64_t,
                              flags: c_int) -> c_int;
    pub fn av_read_play(s: *mut AVFormatContext) -> c_int;
    pub fn av_read_pause(s: *mut AVFormatContext) -> c_int;
    pub fn av_close_input_file(s: *mut AVFormatContext);
    pub fn avformat_close_input(s: *mut *mut AVFormatContext);
    pub fn av_new_stream(s: *mut AVFormatContext, id: c_int) -> *mut AVStream;
    pub fn av_set_pts_info(s: *mut AVStream, pts_wrap_bits: c_int,
                           pts_num: c_uint, pts_den: c_uint);
    pub fn avformat_write_header(s: *mut AVFormatContext,
                                 options: *mut *mut AVDictionary) -> c_int;
    pub fn av_write_frame(s: *mut AVFormatContext, pkt: *mut AVPacket) ->
     c_int;
    pub fn av_interleaved_write_frame(s: *mut AVFormatContext,
                                      pkt: *mut AVPacket) -> c_int;
    pub fn av_write_uncoded_frame(s: *mut AVFormatContext,
                                  stream_index: c_int, frame: *mut AVFrame) ->
     c_int;
    pub fn av_interleaved_write_uncoded_frame(s: *mut AVFormatContext,
                                              stream_index: c_int,
                                              frame: *mut AVFrame) -> c_int;
    pub fn av_write_uncoded_frame_query(s: *mut AVFormatContext,
                                        stream_index: c_int) -> c_int;
    pub fn av_write_trailer(s: *mut AVFormatContext) -> c_int;
    pub fn av_guess_format(short_name: *c_schar, filename: *c_schar,
                           mime_type: *c_schar) -> *mut AVOutputFormat;
    pub fn av_guess_codec(fmt: *mut AVOutputFormat, short_name: *c_schar,
                          filename: *c_schar, mime_type: *c_schar,
                          _type: Enum_AVMediaType) -> Enum_AVCodecID;
    pub fn av_get_output_timestamp(s: *mut Struct_AVFormatContext,
                                   stream: c_int, dts: *mut int64_t,
                                   wall: *mut int64_t) -> c_int;
    pub fn av_hex_dump(f: *mut FILE, buf: *uint8_t, size: c_int);
    pub fn av_hex_dump_log(avcl: *mut c_void, level: c_int, buf: *uint8_t,
                           size: c_int);
    pub fn av_pkt_dump2(f: *mut FILE, pkt: *mut AVPacket, dump_payload: c_int,
                        st: *mut AVStream);
    pub fn av_pkt_dump_log2(avcl: *mut c_void, level: c_int,
                            pkt: *mut AVPacket, dump_payload: c_int,
                            st: *mut AVStream);
    pub fn av_codec_get_id(tags: **Struct_AVCodecTag, tag: c_uint) ->
     Enum_AVCodecID;
    pub fn av_codec_get_tag(tags: **Struct_AVCodecTag, id: Enum_AVCodecID) ->
     c_uint;
    pub fn av_codec_get_tag2(tags: **Struct_AVCodecTag, id: Enum_AVCodecID,
                             tag: *mut c_uint) -> c_int;
    pub fn av_find_default_stream_index(s: *mut AVFormatContext) -> c_int;
    pub fn av_index_search_timestamp(st: *mut AVStream, timestamp: int64_t,
                                     flags: c_int) -> c_int;
    pub fn av_add_index_entry(st: *mut AVStream, pos: int64_t,
                              timestamp: int64_t, size: c_int,
                              distance: c_int, flags: c_int) -> c_int;
    pub fn av_url_split(proto: *mut c_schar, proto_size: c_int,
                        authorization: *mut c_schar,
                        authorization_size: c_int, hostname: *mut c_schar,
                        hostname_size: c_int, port_ptr: *mut c_int,
                        path: *mut c_schar, path_size: c_int, url: *c_schar);
    pub fn av_dump_format(ic: *mut AVFormatContext, index: c_int,
                          url: *c_schar, is_output: c_int);
    pub fn av_get_frame_filename(buf: *mut c_schar, buf_size: c_int,
                                 path: *c_schar, number: c_int) -> c_int;
    pub fn av_filename_number_test(filename: *c_schar) -> c_int;
    pub fn av_sdp_create(ac: c_void, n_files: c_int, buf: *mut c_schar,
                         size: c_int) -> c_int;
    pub fn av_match_ext(filename: *c_schar, extensions: *c_schar) -> c_int;
    pub fn avformat_query_codec(ofmt: *mut AVOutputFormat,
                                codec_id: Enum_AVCodecID,
                                std_compliance: c_int) -> c_int;
    pub fn avformat_get_riff_video_tags() -> *Struct_AVCodecTag;
    pub fn avformat_get_riff_audio_tags() -> *Struct_AVCodecTag;
    pub fn avformat_get_mov_video_tags() -> *Struct_AVCodecTag;
    pub fn avformat_get_mov_audio_tags() -> *Struct_AVCodecTag;
    pub fn av_guess_sample_aspect_ratio(format: *mut AVFormatContext,
                                        stream: *mut AVStream,
                                        frame: *mut AVFrame) -> AVRational;
    pub fn av_guess_frame_rate(ctx: *mut AVFormatContext,
                               stream: *mut AVStream, frame: *mut AVFrame) ->
     AVRational;
    pub fn avformat_match_stream_specifier(s: *mut AVFormatContext,
                                           st: *mut AVStream, spec: *c_schar)
     -> c_int;
    pub fn avformat_queue_attached_pictures(s: *mut AVFormatContext) -> c_int;
    pub fn swscale_version() -> c_uint;
    pub fn swscale_configuration() -> *c_schar;
    pub fn swscale_license() -> *c_schar;
    pub fn sws_getCoefficients(colorspace: c_int) -> *c_int;
    pub fn sws_isSupportedInput(pix_fmt: Enum_AVPixelFormat) -> c_int;
    pub fn sws_isSupportedOutput(pix_fmt: Enum_AVPixelFormat) -> c_int;
    pub fn sws_isSupportedEndiannessConversion(pix_fmt: Enum_AVPixelFormat) ->
     c_int;
    pub fn sws_alloc_context() -> *mut Struct_SwsContext;
    pub fn sws_init_context(sws_context: *mut Struct_SwsContext,
                            srcFilter: *mut SwsFilter,
                            dstFilter: *mut SwsFilter) -> c_int;
    pub fn sws_freeContext(swsContext: *mut Struct_SwsContext);
    pub fn sws_getContext(srcW: c_int, srcH: c_int,
                          srcFormat: Enum_AVPixelFormat, dstW: c_int,
                          dstH: c_int, dstFormat: Enum_AVPixelFormat,
                          flags: c_int, srcFilter: *mut SwsFilter,
                          dstFilter: *mut SwsFilter, param: *c_double) ->
     *mut Struct_SwsContext;
    pub fn sws_scale(c: *mut Struct_SwsContext, srcSlice: c_void,
                     srcStride: c_void, srcSliceY: c_int, srcSliceH: c_int,
                     dst: c_void, dstStride: c_void) -> c_int;
    pub fn sws_setColorspaceDetails(c: *mut Struct_SwsContext,
                                    inv_table: [c_int, ..4u], srcRange: c_int,
                                    table: [c_int, ..4u], dstRange: c_int,
                                    brightness: c_int, contrast: c_int,
                                    saturation: c_int) -> c_int;
    pub fn sws_getColorspaceDetails(c: *mut Struct_SwsContext,
                                    inv_table: *mut *mut c_int,
                                    srcRange: *mut c_int,
                                    table: *mut *mut c_int,
                                    dstRange: *mut c_int,
                                    brightness: *mut c_int,
                                    contrast: *mut c_int,
                                    saturation: *mut c_int) -> c_int;
    pub fn sws_allocVec(length: c_int) -> *mut SwsVector;
    pub fn sws_getGaussianVec(variance: c_double, quality: c_double) ->
     *mut SwsVector;
    pub fn sws_getConstVec(c: c_double, length: c_int) -> *mut SwsVector;
    pub fn sws_getIdentityVec() -> *mut SwsVector;
    pub fn sws_scaleVec(a: *mut SwsVector, scalar: c_double);
    pub fn sws_normalizeVec(a: *mut SwsVector, height: c_double);
    pub fn sws_convVec(a: *mut SwsVector, b: *mut SwsVector);
    pub fn sws_addVec(a: *mut SwsVector, b: *mut SwsVector);
    pub fn sws_subVec(a: *mut SwsVector, b: *mut SwsVector);
    pub fn sws_shiftVec(a: *mut SwsVector, shift: c_int);
    pub fn sws_cloneVec(a: *mut SwsVector) -> *mut SwsVector;
    pub fn sws_printVec2(a: *mut SwsVector, log_ctx: *mut AVClass,
                         log_level: c_int);
    pub fn sws_freeVec(a: *mut SwsVector);
    pub fn sws_getDefaultFilter(lumaGBlur: c_float, chromaGBlur: c_float,
                                lumaSharpen: c_float, chromaSharpen: c_float,
                                chromaHShift: c_float, chromaVShift: c_float,
                                verbose: c_int) -> *mut SwsFilter;
    pub fn sws_freeFilter(filter: *mut SwsFilter);
    pub fn sws_getCachedContext(context: *mut Struct_SwsContext, srcW: c_int,
                                srcH: c_int, srcFormat: Enum_AVPixelFormat,
                                dstW: c_int, dstH: c_int,
                                dstFormat: Enum_AVPixelFormat, flags: c_int,
                                srcFilter: *mut SwsFilter,
                                dstFilter: *mut SwsFilter, param: *c_double)
     -> *mut Struct_SwsContext;
    pub fn sws_convertPalette8ToPacked32(src: *uint8_t, dst: *mut uint8_t,
                                         num_pixels: c_int,
                                         palette: *uint8_t);
    pub fn sws_convertPalette8ToPacked24(src: *uint8_t, dst: *mut uint8_t,
                                         num_pixels: c_int,
                                         palette: *uint8_t);
    pub fn sws_get_class() -> *AVClass;
}
