/* automatically generated by rust-bindgen */
#![allow(dead_code, non_camel_case_types, uppercase_variables)]

use libc::*;
pub type __int128_t = c_void;
pub type __uint128_t = c_void;
pub type __builtin_va_list = [__va_list_tag, ..1u];
pub type __u_char = c_uchar;
pub type __u_short = c_ushort;
pub type __u_int = c_uint;
pub type __u_long = c_ulong;
pub type __int8_t = c_schar;
pub type __uint8_t = c_uchar;
pub type __int16_t = c_short;
pub type __uint16_t = c_ushort;
pub type __int32_t = c_int;
pub type __uint32_t = c_uint;
pub type __int64_t = c_long;
pub type __uint64_t = c_ulong;
pub type __quad_t = c_long;
pub type __u_quad_t = c_ulong;
pub type __dev_t = c_ulong;
pub type __uid_t = c_uint;
pub type __gid_t = c_uint;
pub type __ino_t = c_ulong;
pub type __ino64_t = c_ulong;
pub type __mode_t = c_uint;
pub type __nlink_t = c_ulong;
pub type __off_t = c_long;
pub type __off64_t = c_long;
pub type __pid_t = c_int;
pub struct __fsid_t {
    pub __val: [c_int, ..2u],
}
pub type __clock_t = c_long;
pub type __rlim_t = c_ulong;
pub type __rlim64_t = c_ulong;
pub type __id_t = c_uint;
pub type __time_t = c_long;
pub type __useconds_t = c_uint;
pub type __suseconds_t = c_long;
pub type __daddr_t = c_int;
pub type __key_t = c_int;
pub type __clockid_t = c_int;
pub type __timer_t = *mut c_void;
pub type __blksize_t = c_long;
pub type __blkcnt_t = c_long;
pub type __blkcnt64_t = c_long;
pub type __fsblkcnt_t = c_ulong;
pub type __fsblkcnt64_t = c_ulong;
pub type __fsfilcnt_t = c_ulong;
pub type __fsfilcnt64_t = c_ulong;
pub type __fsword_t = c_long;
pub type __ssize_t = c_long;
pub type __syscall_slong_t = c_long;
pub type __syscall_ulong_t = c_ulong;
pub type __loff_t = __off64_t;
pub type __qaddr_t = *mut __quad_t;
pub type __caddr_t = *mut c_schar;
pub type __intptr_t = c_long;
pub type __socklen_t = c_uint;
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type ino64_t = __ino64_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type off64_t = __off64_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type ssize_t = __ssize_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type time_t = __time_t;
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
pub type useconds_t = __useconds_t;
pub type suseconds_t = __suseconds_t;
pub type ptrdiff_t = c_long;
pub type size_t = c_ulong;
pub type wchar_t = c_int;
pub type ulong = c_ulong;
pub type ushort = c_ushort;
pub type _uint = c_uint;
pub type int8_t = c_schar;
pub type int16_t = c_short;
pub type int32_t = c_int;
pub type int64_t = c_long;
pub type u_int8_t = c_uchar;
pub type u_int16_t = c_ushort;
pub type u_int32_t = c_uint;
pub type u_int64_t = c_ulong;
pub type register_t = c_long;
pub type __sig_atomic_t = c_int;
pub struct __sigset_t {
    pub __val: [c_ulong, ..16u],
}
pub type sigset_t = __sigset_t;
pub struct Struct_timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
pub struct Struct_timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
pub type __fd_mask = c_long;
pub struct fd_set {
    pub fds_bits: [__fd_mask, ..16u],
}
pub type fd_mask = __fd_mask;
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type blkcnt64_t = __blkcnt64_t;
pub type fsblkcnt64_t = __fsblkcnt64_t;
pub type fsfilcnt64_t = __fsfilcnt64_t;
pub type pthread_t = c_ulong;
pub struct Union_pthread_attr_t {
    pub data: [u64, ..7u],
}
impl Union_pthread_attr_t {
    pub fn __size(&mut self) -> *mut [c_schar, ..56u] {
        unsafe { ::std::cast::transmute(self) }
    }
    pub fn __align(&mut self) -> *mut c_long {
        unsafe { ::std::cast::transmute(self) }
    }
}
pub type pthread_attr_t = Union_pthread_attr_t;
pub struct Struct___pthread_internal_list {
    pub __prev: *mut Struct___pthread_internal_list,
    pub __next: *mut Struct___pthread_internal_list,
}
pub type __pthread_list_t = Struct___pthread_internal_list;
pub struct Struct___pthread_mutex_s {
    pub __lock: c_int,
    pub __count: c_uint,
    pub __owner: c_int,
    pub __nusers: c_uint,
    pub __kind: c_int,
    pub __spins: c_short,
    pub __elision: c_short,
    pub __list: __pthread_list_t,
}
pub struct pthread_mutex_t {
    pub data: [u64, ..5u],
}
impl pthread_mutex_t {
    pub fn __data(&mut self) -> *mut Struct___pthread_mutex_s {
        unsafe { ::std::cast::transmute(self) }
    }
    pub fn __size(&mut self) -> *mut [c_schar, ..40u] {
        unsafe { ::std::cast::transmute(self) }
    }
    pub fn __align(&mut self) -> *mut c_long {
        unsafe { ::std::cast::transmute(self) }
    }
}
pub struct pthread_mutexattr_t {
    pub data: [u32, ..1u],
}
impl pthread_mutexattr_t {
    pub fn __size(&mut self) -> *mut [c_schar, ..4u] {
        unsafe { ::std::cast::transmute(self) }
    }
    pub fn __align(&mut self) -> *mut c_int {
        unsafe { ::std::cast::transmute(self) }
    }
}
pub struct Struct_Unnamed1 {
    pub __lock: c_int,
    pub __futex: c_uint,
    pub __total_seq: c_ulonglong,
    pub __wakeup_seq: c_ulonglong,
    pub __woken_seq: c_ulonglong,
    pub __mutex: *mut c_void,
    pub __nwaiters: c_uint,
    pub __broadcast_seq: c_uint,
}
pub struct pthread_cond_t {
    pub data: [u64, ..6u],
}
impl pthread_cond_t {
    pub fn __data(&mut self) -> *mut Struct_Unnamed1 {
        unsafe { ::std::cast::transmute(self) }
    }
    pub fn __size(&mut self) -> *mut [c_schar, ..48u] {
        unsafe { ::std::cast::transmute(self) }
    }
    pub fn __align(&mut self) -> *mut c_longlong {
        unsafe { ::std::cast::transmute(self) }
    }
}
pub struct pthread_condattr_t {
    pub data: [u32, ..1u],
}
impl pthread_condattr_t {
    pub fn __size(&mut self) -> *mut [c_schar, ..4u] {
        unsafe { ::std::cast::transmute(self) }
    }
    pub fn __align(&mut self) -> *mut c_int {
        unsafe { ::std::cast::transmute(self) }
    }
}
pub type pthread_key_t = c_uint;
pub type pthread_once_t = c_int;
pub struct Struct_Unnamed2 {
    pub __lock: c_int,
    pub __nr_readers: c_uint,
    pub __readers_wakeup: c_uint,
    pub __writer_wakeup: c_uint,
    pub __nr_readers_queued: c_uint,
    pub __nr_writers_queued: c_uint,
    pub __writer: c_int,
    pub __shared: c_int,
    pub __pad1: c_ulong,
    pub __pad2: c_ulong,
    pub __flags: c_uint,
}
pub struct pthread_rwlock_t {
    pub data: [u64, ..7u],
}
impl pthread_rwlock_t {
    pub fn __data(&mut self) -> *mut Struct_Unnamed2 {
        unsafe { ::std::cast::transmute(self) }
    }
    pub fn __size(&mut self) -> *mut [c_schar, ..56u] {
        unsafe { ::std::cast::transmute(self) }
    }
    pub fn __align(&mut self) -> *mut c_long {
        unsafe { ::std::cast::transmute(self) }
    }
}
pub struct pthread_rwlockattr_t {
    pub data: [u64, ..1u],
}
impl pthread_rwlockattr_t {
    pub fn __size(&mut self) -> *mut [c_schar, ..8u] {
        unsafe { ::std::cast::transmute(self) }
    }
    pub fn __align(&mut self) -> *mut c_long {
        unsafe { ::std::cast::transmute(self) }
    }
}
pub type pthread_spinlock_t = c_int;
pub struct pthread_barrier_t {
    pub data: [u64, ..4u],
}
impl pthread_barrier_t {
    pub fn __size(&mut self) -> *mut [c_schar, ..32u] {
        unsafe { ::std::cast::transmute(self) }
    }
    pub fn __align(&mut self) -> *mut c_long {
        unsafe { ::std::cast::transmute(self) }
    }
}
pub struct pthread_barrierattr_t {
    pub data: [u32, ..1u],
}
impl pthread_barrierattr_t {
    pub fn __size(&mut self) -> *mut [c_schar, ..4u] {
        unsafe { ::std::cast::transmute(self) }
    }
    pub fn __align(&mut self) -> *mut c_int {
        unsafe { ::std::cast::transmute(self) }
    }
}
pub type FILE = Struct__IO_FILE;
pub type __FILE = Struct__IO_FILE;
pub struct Union_Unnamed3 {
    pub data: [u32, ..1u],
}
impl Union_Unnamed3 {
    pub fn __wch(&mut self) -> *mut c_uint {
        unsafe { ::std::cast::transmute(self) }
    }
    pub fn __wchb(&mut self) -> *mut [c_schar, ..4u] {
        unsafe { ::std::cast::transmute(self) }
    }
}
pub struct __mbstate_t {
    pub __count: c_int,
    pub __value: Union_Unnamed3,
}
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub type Struct__IO_jump_t = c_void;
pub type _IO_lock_t = c_void;
pub struct Struct__IO_marker {
    pub _next: *mut Struct__IO_marker,
    pub _sbuf: *mut Struct__IO_FILE,
    pub _pos: c_int,
}
pub type Enum___codecvt_result = c_uint;
pub static __codecvt_ok: c_uint = 0;
pub static __codecvt_partial: c_uint = 1;
pub static __codecvt_error: c_uint = 2;
pub static __codecvt_noconv: c_uint = 3;
pub struct Struct__IO_FILE {
    pub _flags: c_int,
    pub _IO_read_ptr: *mut c_schar,
    pub _IO_read_end: *mut c_schar,
    pub _IO_read_base: *mut c_schar,
    pub _IO_write_base: *mut c_schar,
    pub _IO_write_ptr: *mut c_schar,
    pub _IO_write_end: *mut c_schar,
    pub _IO_buf_base: *mut c_schar,
    pub _IO_buf_end: *mut c_schar,
    pub _IO_save_base: *mut c_schar,
    pub _IO_backup_base: *mut c_schar,
    pub _IO_save_end: *mut c_schar,
    pub _markers: *mut Struct__IO_marker,
    pub _chain: *mut Struct__IO_FILE,
    pub _fileno: c_int,
    pub _flags2: c_int,
    pub _old_offset: __off_t,
    pub _cur_column: c_ushort,
    pub _vtable_offset: c_schar,
    pub _shortbuf: [c_schar, ..1u],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub __pad1: *mut c_void,
    pub __pad2: *mut c_void,
    pub __pad3: *mut c_void,
    pub __pad4: *mut c_void,
    pub __pad5: size_t,
    pub _mode: c_int,
    pub _unused2: [c_schar, ..20u],
}
pub type _IO_FILE = Struct__IO_FILE;
pub type Struct__IO_FILE_plus = c_void;
pub type __io_read_fn = c_void;
pub type __io_write_fn = c_void;
pub type __io_seek_fn = c_void;
pub type __io_close_fn = c_void;
pub type cookie_read_function_t = __io_read_fn;
pub type cookie_write_function_t = __io_write_fn;
pub type cookie_seek_function_t = __io_seek_fn;
pub type cookie_close_function_t = __io_close_fn;
pub struct _IO_cookie_io_functions_t {
    pub read: *mut ::std::option::Option<extern "C" fn
                                             (arg1: *mut c_void,
                                              arg2: *mut c_schar,
                                              arg3: size_t) -> __ssize_t>,
    pub write: *mut ::std::option::Option<extern "C" fn
                                              (arg1: *mut c_void,
                                               arg2: *c_schar, arg3: size_t)
                                              -> __ssize_t>,
    pub seek: *mut ::std::option::Option<extern "C" fn
                                             (arg1: *mut c_void,
                                              arg2: *mut __off64_t,
                                              arg3: c_int) -> c_int>,
    pub close: *mut ::std::option::Option<extern "C" fn(arg1: *mut c_void)
                                              -> c_int>,
}
pub type cookie_io_functions_t = _IO_cookie_io_functions_t;
pub type Struct__IO_cookie_file = c_void;
pub type fpos_t = _G_fpos_t;
pub type fpos64_t = _G_fpos64_t;
pub type Struct_obstack = c_void;
pub struct Union_wait {
    pub data: [u32, ..1u],
}
impl Union_wait {
    pub fn w_status(&mut self) -> *mut c_int {
        unsafe { ::std::cast::transmute(self) }
    }
    pub fn __wait_terminated(&mut self) -> *mut Struct_Unnamed4 {
        unsafe { ::std::cast::transmute(self) }
    }
    pub fn __wait_stopped(&mut self) -> *mut Struct_Unnamed5 {
        unsafe { ::std::cast::transmute(self) }
    }
}
pub struct Struct_Unnamed4 {
    pub __w_termsig: c_uint,
    pub __w_coredump: c_uint,
    pub __w_retcode: c_uint,
    pub unnamed_field1: c_uint,
}
pub struct Struct_Unnamed5 {
    pub __w_stopval: c_uint,
    pub __w_stopsig: c_uint,
    pub unnamed_field1: c_uint,
}
pub struct __WAIT_STATUS {
    pub data: [u64, ..1u],
}
impl __WAIT_STATUS {
    pub fn __uptr(&mut self) -> *mut *mut Union_wait {
        unsafe { ::std::cast::transmute(self) }
    }
    pub fn __iptr(&mut self) -> *mut *mut c_int {
        unsafe { ::std::cast::transmute(self) }
    }
}
pub struct div_t {
    pub quot: c_int,
    pub rem: c_int,
}
pub struct ldiv_t {
    pub quot: c_long,
    pub rem: c_long,
}
pub struct lldiv_t {
    pub quot: c_longlong,
    pub rem: c_longlong,
}
pub struct Struct___locale_struct {
    pub __locales: [*mut Struct___locale_data, ..13u],
    pub __ctype_b: *c_ushort,
    pub __ctype_tolower: *c_int,
    pub __ctype_toupper: *c_int,
    pub __names: [*c_schar, ..13u],
}
pub type Struct___locale_data = c_void;
pub type __locale_t = *mut Struct___locale_struct;
pub type locale_t = __locale_t;
pub struct Struct_random_data {
    pub fptr: *mut int32_t,
    pub rptr: *mut int32_t,
    pub state: *mut int32_t,
    pub rand_type: c_int,
    pub rand_deg: c_int,
    pub rand_sep: c_int,
    pub end_ptr: *mut int32_t,
}
pub struct Struct_drand48_data {
    pub __x: [c_ushort, ..3u],
    pub __old_x: [c_ushort, ..3u],
    pub __c: c_ushort,
    pub __init: c_ushort,
    pub __a: c_ulonglong,
}
pub type __compar_fn_t =
    ::std::option::Option<extern "C" fn(arg1: *c_void, arg2: *c_void)
                              -> c_int>;
pub type comparison_fn_t = __compar_fn_t;
pub type __compar_d_fn_t =
    ::std::option::Option<extern "C" fn
                              (arg1: *c_void, arg2: *c_void,
                               arg3: *mut c_void) -> c_int>;
pub type uint8_t = c_uchar;
pub type uint16_t = c_ushort;
pub type uint32_t = c_uint;
pub type uint64_t = c_ulong;
pub type int_least8_t = c_schar;
pub type int_least16_t = c_short;
pub type int_least32_t = c_int;
pub type int_least64_t = c_long;
pub type uint_least8_t = c_uchar;
pub type uint_least16_t = c_ushort;
pub type uint_least32_t = c_uint;
pub type uint_least64_t = c_ulong;
pub type int_fast8_t = c_schar;
pub type int_fast16_t = c_long;
pub type int_fast32_t = c_long;
pub type int_fast64_t = c_long;
pub type uint_fast8_t = c_uchar;
pub type uint_fast16_t = c_ulong;
pub type uint_fast32_t = c_ulong;
pub type uint_fast64_t = c_ulong;
pub type intptr_t = c_long;
pub type uintptr_t = c_ulong;
pub type intmax_t = c_long;
pub type uintmax_t = c_ulong;
pub type __gwchar_t = c_int;
pub struct imaxdiv_t {
    pub quot: c_long,
    pub rem: c_long,
}
pub type Enum_Unnamed6 = c_uint;
pub static _ISupper: c_uint = 256;
pub static _ISlower: c_uint = 512;
pub static _ISalpha: c_uint = 1024;
pub static _ISdigit: c_uint = 2048;
pub static _ISxdigit: c_uint = 4096;
pub static _ISspace: c_uint = 8192;
pub static _ISprint: c_uint = 16384;
pub static _ISgraph: c_uint = 32768;
pub static _ISblank: c_uint = 1;
pub static _IScntrl: c_uint = 2;
pub static _ISpunct: c_uint = 4;
pub static _ISalnum: c_uint = 8;
pub type iconv_t = *mut c_void;
pub type SDL_bool = c_uint;
pub static SDL_FALSE: c_uint = 0;
pub static SDL_TRUE: c_uint = 1;
pub type Sint8 = int8_t;
pub type Uint8 = uint8_t;
pub type Sint16 = int16_t;
pub type Uint16 = uint16_t;
pub type Sint32 = int32_t;
pub type Uint32 = uint32_t;
pub type Sint64 = int64_t;
pub type Uint64 = uint64_t;
pub type SDL_dummy_uint8 = [c_int, ..1u];
pub type SDL_dummy_sint8 = [c_int, ..1u];
pub type SDL_dummy_uint16 = [c_int, ..1u];
pub type SDL_dummy_sint16 = [c_int, ..1u];
pub type SDL_dummy_uint32 = [c_int, ..1u];
pub type SDL_dummy_sint32 = [c_int, ..1u];
pub type SDL_dummy_uint64 = [c_int, ..1u];
pub type SDL_dummy_sint64 = [c_int, ..1u];
pub type SDL_DUMMY_ENUM = c_uint;
pub static DUMMY_ENUM_VALUE: c_uint = 0;
pub type SDL_dummy_enum = [c_int, ..1u];
pub type SDL_errorcode = c_uint;
pub static SDL_ENOMEM: c_uint = 0;
pub static SDL_EFREAD: c_uint = 1;
pub static SDL_EFWRITE: c_uint = 2;
pub static SDL_EFSEEK: c_uint = 3;
pub static SDL_UNSUPPORTED: c_uint = 4;
pub static SDL_LASTERROR: c_uint = 5;
pub type Struct_SDL_mutex = c_void;
pub type SDL_mutex = Struct_SDL_mutex;
pub type Struct_SDL_semaphore = c_void;
pub type SDL_sem = Struct_SDL_semaphore;
pub type Struct_SDL_cond = c_void;
pub type SDL_cond = Struct_SDL_cond;
pub type Struct_SDL_Thread = c_void;
pub type SDL_Thread = Struct_SDL_Thread;
pub struct Struct_SDL_RWops {
    pub seek: ::std::option::Option<extern "C" fn
                                        (arg1: *mut Struct_SDL_RWops,
                                         arg2: c_int, arg3: c_int) -> c_int>,
    pub read: ::std::option::Option<extern "C" fn
                                        (arg1: *mut Struct_SDL_RWops,
                                         arg2: *mut c_void, arg3: c_int,
                                         arg4: c_int) -> c_int>,
    pub write: ::std::option::Option<extern "C" fn
                                         (arg1: *mut Struct_SDL_RWops,
                                          arg2: *c_void, arg3: c_int,
                                          arg4: c_int) -> c_int>,
    pub close: ::std::option::Option<extern "C" fn
                                         (arg1: *mut Struct_SDL_RWops)
                                         -> c_int>,
    pub _type: Uint32,
    pub hidden: Union_Unnamed7,
}
pub struct Union_Unnamed7 {
    pub data: [u64, ..3u],
}
impl Union_Unnamed7 {
    pub fn stdio(&mut self) -> *mut Struct_Unnamed8 {
        unsafe { ::std::cast::transmute(self) }
    }
    pub fn mem(&mut self) -> *mut Struct_Unnamed9 {
        unsafe { ::std::cast::transmute(self) }
    }
    pub fn unknown(&mut self) -> *mut Struct_Unnamed10 {
        unsafe { ::std::cast::transmute(self) }
    }
}
pub struct Struct_Unnamed8 {
    pub autoclose: c_int,
    pub fp: *mut FILE,
}
pub struct Struct_Unnamed9 {
    pub base: *mut Uint8,
    pub here: *mut Uint8,
    pub stop: *mut Uint8,
}
pub struct Struct_Unnamed10 {
    pub data1: *mut c_void,
}
pub type SDL_RWops = Struct_SDL_RWops;
pub struct Struct_SDL_AudioSpec {
    pub freq: c_int,
    pub format: Uint16,
    pub channels: Uint8,
    pub silence: Uint8,
    pub samples: Uint16,
    pub padding: Uint16,
    pub size: Uint32,
    pub callback: ::std::option::Option<extern "C" fn
                                            (arg1: *mut c_void,
                                             arg2: *mut Uint8, arg3: c_int)>,
    pub userdata: *mut c_void,
}
pub type SDL_AudioSpec = Struct_SDL_AudioSpec;
pub struct Struct_SDL_AudioCVT {
    pub needed: c_int,
    pub src_format: Uint16,
    pub dst_format: Uint16,
    pub rate_incr: c_double,
    pub buf: *mut Uint8,
    pub len: c_int,
    pub len_cvt: c_int,
    pub len_mult: c_int,
    pub len_ratio: c_double,
    pub filters: [::std::option::Option<extern "C" fn
                                            (arg1: *mut Struct_SDL_AudioCVT,
                                             arg2: Uint16)>, ..10u],
    pub filter_index: c_int,
}
pub type SDL_AudioCVT = Struct_SDL_AudioCVT;
pub type SDL_audiostatus = c_uint;
pub static SDL_AUDIO_STOPPED: c_uint = 0;
pub static SDL_AUDIO_PLAYING: c_uint = 1;
pub static SDL_AUDIO_PAUSED: c_uint = 2;
pub type CDstatus = c_int;
pub static CD_TRAYEMPTY: c_int = 0;
pub static CD_STOPPED: c_int = 1;
pub static CD_PLAYING: c_int = 2;
pub static CD_PAUSED: c_int = 3;
pub static CD_ERROR: c_int = -1;
pub struct Struct_SDL_CDtrack {
    pub id: Uint8,
    pub _type: Uint8,
    pub unused: Uint16,
    pub length: Uint32,
    pub offset: Uint32,
}
pub type SDL_CDtrack = Struct_SDL_CDtrack;
pub struct Struct_SDL_CD {
    pub id: c_int,
    pub status: CDstatus,
    pub numtracks: c_int,
    pub cur_track: c_int,
    pub cur_frame: c_int,
    pub track: [SDL_CDtrack, ..100u],
}
pub type SDL_CD = Struct_SDL_CD;
pub type SDLKey = c_uint;
pub static SDLK_UNKNOWN: c_uint = 0;
pub static SDLK_FIRST: c_uint = 0;
pub static SDLK_BACKSPACE: c_uint = 8;
pub static SDLK_TAB: c_uint = 9;
pub static SDLK_CLEAR: c_uint = 12;
pub static SDLK_RETURN: c_uint = 13;
pub static SDLK_PAUSE: c_uint = 19;
pub static SDLK_ESCAPE: c_uint = 27;
pub static SDLK_SPACE: c_uint = 32;
pub static SDLK_EXCLAIM: c_uint = 33;
pub static SDLK_QUOTEDBL: c_uint = 34;
pub static SDLK_HASH: c_uint = 35;
pub static SDLK_DOLLAR: c_uint = 36;
pub static SDLK_AMPERSAND: c_uint = 38;
pub static SDLK_QUOTE: c_uint = 39;
pub static SDLK_LEFTPAREN: c_uint = 40;
pub static SDLK_RIGHTPAREN: c_uint = 41;
pub static SDLK_ASTERISK: c_uint = 42;
pub static SDLK_PLUS: c_uint = 43;
pub static SDLK_COMMA: c_uint = 44;
pub static SDLK_MINUS: c_uint = 45;
pub static SDLK_PERIOD: c_uint = 46;
pub static SDLK_SLASH: c_uint = 47;
pub static SDLK_0: c_uint = 48;
pub static SDLK_1: c_uint = 49;
pub static SDLK_2: c_uint = 50;
pub static SDLK_3: c_uint = 51;
pub static SDLK_4: c_uint = 52;
pub static SDLK_5: c_uint = 53;
pub static SDLK_6: c_uint = 54;
pub static SDLK_7: c_uint = 55;
pub static SDLK_8: c_uint = 56;
pub static SDLK_9: c_uint = 57;
pub static SDLK_COLON: c_uint = 58;
pub static SDLK_SEMICOLON: c_uint = 59;
pub static SDLK_LESS: c_uint = 60;
pub static SDLK_EQUALS: c_uint = 61;
pub static SDLK_GREATER: c_uint = 62;
pub static SDLK_QUESTION: c_uint = 63;
pub static SDLK_AT: c_uint = 64;
pub static SDLK_LEFTBRACKET: c_uint = 91;
pub static SDLK_BACKSLASH: c_uint = 92;
pub static SDLK_RIGHTBRACKET: c_uint = 93;
pub static SDLK_CARET: c_uint = 94;
pub static SDLK_UNDERSCORE: c_uint = 95;
pub static SDLK_BACKQUOTE: c_uint = 96;
pub static SDLK_a: c_uint = 97;
pub static SDLK_b: c_uint = 98;
pub static SDLK_c: c_uint = 99;
pub static SDLK_d: c_uint = 100;
pub static SDLK_e: c_uint = 101;
pub static SDLK_f: c_uint = 102;
pub static SDLK_g: c_uint = 103;
pub static SDLK_h: c_uint = 104;
pub static SDLK_i: c_uint = 105;
pub static SDLK_j: c_uint = 106;
pub static SDLK_k: c_uint = 107;
pub static SDLK_l: c_uint = 108;
pub static SDLK_m: c_uint = 109;
pub static SDLK_n: c_uint = 110;
pub static SDLK_o: c_uint = 111;
pub static SDLK_p: c_uint = 112;
pub static SDLK_q: c_uint = 113;
pub static SDLK_r: c_uint = 114;
pub static SDLK_s: c_uint = 115;
pub static SDLK_t: c_uint = 116;
pub static SDLK_u: c_uint = 117;
pub static SDLK_v: c_uint = 118;
pub static SDLK_w: c_uint = 119;
pub static SDLK_x: c_uint = 120;
pub static SDLK_y: c_uint = 121;
pub static SDLK_z: c_uint = 122;
pub static SDLK_DELETE: c_uint = 127;
pub static SDLK_WORLD_0: c_uint = 160;
pub static SDLK_WORLD_1: c_uint = 161;
pub static SDLK_WORLD_2: c_uint = 162;
pub static SDLK_WORLD_3: c_uint = 163;
pub static SDLK_WORLD_4: c_uint = 164;
pub static SDLK_WORLD_5: c_uint = 165;
pub static SDLK_WORLD_6: c_uint = 166;
pub static SDLK_WORLD_7: c_uint = 167;
pub static SDLK_WORLD_8: c_uint = 168;
pub static SDLK_WORLD_9: c_uint = 169;
pub static SDLK_WORLD_10: c_uint = 170;
pub static SDLK_WORLD_11: c_uint = 171;
pub static SDLK_WORLD_12: c_uint = 172;
pub static SDLK_WORLD_13: c_uint = 173;
pub static SDLK_WORLD_14: c_uint = 174;
pub static SDLK_WORLD_15: c_uint = 175;
pub static SDLK_WORLD_16: c_uint = 176;
pub static SDLK_WORLD_17: c_uint = 177;
pub static SDLK_WORLD_18: c_uint = 178;
pub static SDLK_WORLD_19: c_uint = 179;
pub static SDLK_WORLD_20: c_uint = 180;
pub static SDLK_WORLD_21: c_uint = 181;
pub static SDLK_WORLD_22: c_uint = 182;
pub static SDLK_WORLD_23: c_uint = 183;
pub static SDLK_WORLD_24: c_uint = 184;
pub static SDLK_WORLD_25: c_uint = 185;
pub static SDLK_WORLD_26: c_uint = 186;
pub static SDLK_WORLD_27: c_uint = 187;
pub static SDLK_WORLD_28: c_uint = 188;
pub static SDLK_WORLD_29: c_uint = 189;
pub static SDLK_WORLD_30: c_uint = 190;
pub static SDLK_WORLD_31: c_uint = 191;
pub static SDLK_WORLD_32: c_uint = 192;
pub static SDLK_WORLD_33: c_uint = 193;
pub static SDLK_WORLD_34: c_uint = 194;
pub static SDLK_WORLD_35: c_uint = 195;
pub static SDLK_WORLD_36: c_uint = 196;
pub static SDLK_WORLD_37: c_uint = 197;
pub static SDLK_WORLD_38: c_uint = 198;
pub static SDLK_WORLD_39: c_uint = 199;
pub static SDLK_WORLD_40: c_uint = 200;
pub static SDLK_WORLD_41: c_uint = 201;
pub static SDLK_WORLD_42: c_uint = 202;
pub static SDLK_WORLD_43: c_uint = 203;
pub static SDLK_WORLD_44: c_uint = 204;
pub static SDLK_WORLD_45: c_uint = 205;
pub static SDLK_WORLD_46: c_uint = 206;
pub static SDLK_WORLD_47: c_uint = 207;
pub static SDLK_WORLD_48: c_uint = 208;
pub static SDLK_WORLD_49: c_uint = 209;
pub static SDLK_WORLD_50: c_uint = 210;
pub static SDLK_WORLD_51: c_uint = 211;
pub static SDLK_WORLD_52: c_uint = 212;
pub static SDLK_WORLD_53: c_uint = 213;
pub static SDLK_WORLD_54: c_uint = 214;
pub static SDLK_WORLD_55: c_uint = 215;
pub static SDLK_WORLD_56: c_uint = 216;
pub static SDLK_WORLD_57: c_uint = 217;
pub static SDLK_WORLD_58: c_uint = 218;
pub static SDLK_WORLD_59: c_uint = 219;
pub static SDLK_WORLD_60: c_uint = 220;
pub static SDLK_WORLD_61: c_uint = 221;
pub static SDLK_WORLD_62: c_uint = 222;
pub static SDLK_WORLD_63: c_uint = 223;
pub static SDLK_WORLD_64: c_uint = 224;
pub static SDLK_WORLD_65: c_uint = 225;
pub static SDLK_WORLD_66: c_uint = 226;
pub static SDLK_WORLD_67: c_uint = 227;
pub static SDLK_WORLD_68: c_uint = 228;
pub static SDLK_WORLD_69: c_uint = 229;
pub static SDLK_WORLD_70: c_uint = 230;
pub static SDLK_WORLD_71: c_uint = 231;
pub static SDLK_WORLD_72: c_uint = 232;
pub static SDLK_WORLD_73: c_uint = 233;
pub static SDLK_WORLD_74: c_uint = 234;
pub static SDLK_WORLD_75: c_uint = 235;
pub static SDLK_WORLD_76: c_uint = 236;
pub static SDLK_WORLD_77: c_uint = 237;
pub static SDLK_WORLD_78: c_uint = 238;
pub static SDLK_WORLD_79: c_uint = 239;
pub static SDLK_WORLD_80: c_uint = 240;
pub static SDLK_WORLD_81: c_uint = 241;
pub static SDLK_WORLD_82: c_uint = 242;
pub static SDLK_WORLD_83: c_uint = 243;
pub static SDLK_WORLD_84: c_uint = 244;
pub static SDLK_WORLD_85: c_uint = 245;
pub static SDLK_WORLD_86: c_uint = 246;
pub static SDLK_WORLD_87: c_uint = 247;
pub static SDLK_WORLD_88: c_uint = 248;
pub static SDLK_WORLD_89: c_uint = 249;
pub static SDLK_WORLD_90: c_uint = 250;
pub static SDLK_WORLD_91: c_uint = 251;
pub static SDLK_WORLD_92: c_uint = 252;
pub static SDLK_WORLD_93: c_uint = 253;
pub static SDLK_WORLD_94: c_uint = 254;
pub static SDLK_WORLD_95: c_uint = 255;
pub static SDLK_KP0: c_uint = 256;
pub static SDLK_KP1: c_uint = 257;
pub static SDLK_KP2: c_uint = 258;
pub static SDLK_KP3: c_uint = 259;
pub static SDLK_KP4: c_uint = 260;
pub static SDLK_KP5: c_uint = 261;
pub static SDLK_KP6: c_uint = 262;
pub static SDLK_KP7: c_uint = 263;
pub static SDLK_KP8: c_uint = 264;
pub static SDLK_KP9: c_uint = 265;
pub static SDLK_KP_PERIOD: c_uint = 266;
pub static SDLK_KP_DIVIDE: c_uint = 267;
pub static SDLK_KP_MULTIPLY: c_uint = 268;
pub static SDLK_KP_MINUS: c_uint = 269;
pub static SDLK_KP_PLUS: c_uint = 270;
pub static SDLK_KP_ENTER: c_uint = 271;
pub static SDLK_KP_EQUALS: c_uint = 272;
pub static SDLK_UP: c_uint = 273;
pub static SDLK_DOWN: c_uint = 274;
pub static SDLK_RIGHT: c_uint = 275;
pub static SDLK_LEFT: c_uint = 276;
pub static SDLK_INSERT: c_uint = 277;
pub static SDLK_HOME: c_uint = 278;
pub static SDLK_END: c_uint = 279;
pub static SDLK_PAGEUP: c_uint = 280;
pub static SDLK_PAGEDOWN: c_uint = 281;
pub static SDLK_F1: c_uint = 282;
pub static SDLK_F2: c_uint = 283;
pub static SDLK_F3: c_uint = 284;
pub static SDLK_F4: c_uint = 285;
pub static SDLK_F5: c_uint = 286;
pub static SDLK_F6: c_uint = 287;
pub static SDLK_F7: c_uint = 288;
pub static SDLK_F8: c_uint = 289;
pub static SDLK_F9: c_uint = 290;
pub static SDLK_F10: c_uint = 291;
pub static SDLK_F11: c_uint = 292;
pub static SDLK_F12: c_uint = 293;
pub static SDLK_F13: c_uint = 294;
pub static SDLK_F14: c_uint = 295;
pub static SDLK_F15: c_uint = 296;
pub static SDLK_NUMLOCK: c_uint = 300;
pub static SDLK_CAPSLOCK: c_uint = 301;
pub static SDLK_SCROLLOCK: c_uint = 302;
pub static SDLK_RSHIFT: c_uint = 303;
pub static SDLK_LSHIFT: c_uint = 304;
pub static SDLK_RCTRL: c_uint = 305;
pub static SDLK_LCTRL: c_uint = 306;
pub static SDLK_RALT: c_uint = 307;
pub static SDLK_LALT: c_uint = 308;
pub static SDLK_RMETA: c_uint = 309;
pub static SDLK_LMETA: c_uint = 310;
pub static SDLK_LSUPER: c_uint = 311;
pub static SDLK_RSUPER: c_uint = 312;
pub static SDLK_MODE: c_uint = 313;
pub static SDLK_COMPOSE: c_uint = 314;
pub static SDLK_HELP: c_uint = 315;
pub static SDLK_PRINT: c_uint = 316;
pub static SDLK_SYSREQ: c_uint = 317;
pub static SDLK_BREAK: c_uint = 318;
pub static SDLK_MENU: c_uint = 319;
pub static SDLK_POWER: c_uint = 320;
pub static SDLK_EURO: c_uint = 321;
pub static SDLK_UNDO: c_uint = 322;
pub static SDLK_LAST: c_uint = 323;
pub type SDLMod = c_uint;
pub static KMOD_NONE: c_uint = 0;
pub static KMOD_LSHIFT: c_uint = 1;
pub static KMOD_RSHIFT: c_uint = 2;
pub static KMOD_LCTRL: c_uint = 64;
pub static KMOD_RCTRL: c_uint = 128;
pub static KMOD_LALT: c_uint = 256;
pub static KMOD_RALT: c_uint = 512;
pub static KMOD_LMETA: c_uint = 1024;
pub static KMOD_RMETA: c_uint = 2048;
pub static KMOD_NUM: c_uint = 4096;
pub static KMOD_CAPS: c_uint = 8192;
pub static KMOD_MODE: c_uint = 16384;
pub static KMOD_RESERVED: c_uint = 32768;
pub struct Struct_SDL_keysym {
    pub scancode: Uint8,
    pub sym: SDLKey,
    pub _mod: SDLMod,
    pub unicode: Uint16,
}
pub type SDL_keysym = Struct_SDL_keysym;
pub struct Struct_SDL_Rect {
    pub x: Sint16,
    pub y: Sint16,
    pub w: Uint16,
    pub h: Uint16,
}
pub type SDL_Rect = Struct_SDL_Rect;
pub struct Struct_SDL_Color {
    pub r: Uint8,
    pub g: Uint8,
    pub b: Uint8,
    pub unused: Uint8,
}
pub type SDL_Color = Struct_SDL_Color;
pub struct Struct_SDL_Palette {
    pub ncolors: c_int,
    pub colors: *mut SDL_Color,
}
pub type SDL_Palette = Struct_SDL_Palette;
pub struct Struct_SDL_PixelFormat {
    pub palette: *mut SDL_Palette,
    pub BitsPerPixel: Uint8,
    pub BytesPerPixel: Uint8,
    pub Rloss: Uint8,
    pub Gloss: Uint8,
    pub Bloss: Uint8,
    pub Aloss: Uint8,
    pub Rshift: Uint8,
    pub Gshift: Uint8,
    pub Bshift: Uint8,
    pub Ashift: Uint8,
    pub Rmask: Uint32,
    pub Gmask: Uint32,
    pub Bmask: Uint32,
    pub Amask: Uint32,
    pub colorkey: Uint32,
    pub alpha: Uint8,
}
pub type SDL_PixelFormat = Struct_SDL_PixelFormat;
pub struct Struct_SDL_Surface {
    pub flags: Uint32,
    pub format: *mut SDL_PixelFormat,
    pub w: c_int,
    pub h: c_int,
    pub pitch: Uint16,
    pub pixels: *mut c_void,
    pub offset: c_int,
    pub hwdata: *mut Struct_private_hwdata,
    pub clip_rect: SDL_Rect,
    pub unused1: Uint32,
    pub locked: Uint32,
    pub map: *mut Struct_SDL_BlitMap,
    pub format_version: c_uint,
    pub refcount: c_int,
}
pub type Struct_private_hwdata = c_void;
pub type Struct_SDL_BlitMap = c_void;
pub type SDL_Surface = Struct_SDL_Surface;
pub type SDL_blit =
    ::std::option::Option<extern "C" fn
                              (arg1: *mut Struct_SDL_Surface,
                               arg2: *mut SDL_Rect,
                               arg3: *mut Struct_SDL_Surface,
                               arg4: *mut SDL_Rect) -> c_int>;
pub struct Struct_SDL_VideoInfo {
    pub hw_available: Uint32,
    pub wm_available: Uint32,
    pub UnusedBits1: Uint32,
    pub UnusedBits2: Uint32,
    pub blit_hw: Uint32,
    pub blit_hw_CC: Uint32,
    pub blit_hw_A: Uint32,
    pub blit_sw: Uint32,
    pub blit_sw_CC: Uint32,
    pub blit_sw_A: Uint32,
    pub blit_fill: Uint32,
    pub UnusedBits3: Uint32,
    pub video_mem: Uint32,
    pub vfmt: *mut SDL_PixelFormat,
    pub current_w: c_int,
    pub current_h: c_int,
}
pub type SDL_VideoInfo = Struct_SDL_VideoInfo;
pub struct Struct_SDL_Overlay {
    pub format: Uint32,
    pub w: c_int,
    pub h: c_int,
    pub planes: c_int,
    pub pitches: *mut Uint16,
    pub pixels: *mut *mut Uint8,
    pub hwfuncs: *mut Struct_private_yuvhwfuncs,
    pub hwdata: *mut Struct_private_yuvhwdata,
    pub hw_overlay: Uint32,
    pub UnusedBits: Uint32,
}
pub type Struct_private_yuvhwfuncs = c_void;
pub type Struct_private_yuvhwdata = c_void;
pub type SDL_Overlay = Struct_SDL_Overlay;
pub type SDL_GLattr = c_uint;
pub static SDL_GL_RED_SIZE: c_uint = 0;
pub static SDL_GL_GREEN_SIZE: c_uint = 1;
pub static SDL_GL_BLUE_SIZE: c_uint = 2;
pub static SDL_GL_ALPHA_SIZE: c_uint = 3;
pub static SDL_GL_BUFFER_SIZE: c_uint = 4;
pub static SDL_GL_DOUBLEBUFFER: c_uint = 5;
pub static SDL_GL_DEPTH_SIZE: c_uint = 6;
pub static SDL_GL_STENCIL_SIZE: c_uint = 7;
pub static SDL_GL_ACCUM_RED_SIZE: c_uint = 8;
pub static SDL_GL_ACCUM_GREEN_SIZE: c_uint = 9;
pub static SDL_GL_ACCUM_BLUE_SIZE: c_uint = 10;
pub static SDL_GL_ACCUM_ALPHA_SIZE: c_uint = 11;
pub static SDL_GL_STEREO: c_uint = 12;
pub static SDL_GL_MULTISAMPLEBUFFERS: c_uint = 13;
pub static SDL_GL_MULTISAMPLESAMPLES: c_uint = 14;
pub static SDL_GL_ACCELERATED_VISUAL: c_uint = 15;
pub static SDL_GL_SWAP_CONTROL: c_uint = 16;
pub type SDL_GrabMode = c_int;
pub static SDL_GRAB_QUERY: c_int = -1;
pub static SDL_GRAB_OFF: c_int = 0;
pub static SDL_GRAB_ON: c_int = 1;
pub static SDL_GRAB_FULLSCREEN: c_int = 2;
pub type Struct_WMcursor = c_void;
pub type WMcursor = Struct_WMcursor;
pub struct Struct_SDL_Cursor {
    pub area: SDL_Rect,
    pub hot_x: Sint16,
    pub hot_y: Sint16,
    pub data: *mut Uint8,
    pub mask: *mut Uint8,
    pub save: [*mut Uint8, ..2u],
    pub wm_cursor: *mut WMcursor,
}
pub type SDL_Cursor = Struct_SDL_Cursor;
pub type Struct__SDL_Joystick = c_void;
pub type SDL_Joystick = Struct__SDL_Joystick;
pub type SDL_EventType = c_uint;
pub static SDL_NOEVENT: c_uint = 0;
pub static SDL_ACTIVEEVENT: c_uint = 1;
pub static SDL_KEYDOWN: c_uint = 2;
pub static SDL_KEYUP: c_uint = 3;
pub static SDL_MOUSEMOTION: c_uint = 4;
pub static SDL_MOUSEBUTTONDOWN: c_uint = 5;
pub static SDL_MOUSEBUTTONUP: c_uint = 6;
pub static SDL_JOYAXISMOTION: c_uint = 7;
pub static SDL_JOYBALLMOTION: c_uint = 8;
pub static SDL_JOYHATMOTION: c_uint = 9;
pub static SDL_JOYBUTTONDOWN: c_uint = 10;
pub static SDL_JOYBUTTONUP: c_uint = 11;
pub static SDL_QUIT: c_uint = 12;
pub static SDL_SYSWMEVENT: c_uint = 13;
pub static SDL_EVENT_RESERVEDA: c_uint = 14;
pub static SDL_EVENT_RESERVEDB: c_uint = 15;
pub static SDL_VIDEORESIZE: c_uint = 16;
pub static SDL_VIDEOEXPOSE: c_uint = 17;
pub static SDL_EVENT_RESERVED2: c_uint = 18;
pub static SDL_EVENT_RESERVED3: c_uint = 19;
pub static SDL_EVENT_RESERVED4: c_uint = 20;
pub static SDL_EVENT_RESERVED5: c_uint = 21;
pub static SDL_EVENT_RESERVED6: c_uint = 22;
pub static SDL_EVENT_RESERVED7: c_uint = 23;
pub static SDL_USEREVENT: c_uint = 24;
pub static SDL_NUMEVENTS: c_uint = 32;
pub type SDL_EventMask = c_uint;
pub static SDL_ACTIVEEVENTMASK: c_uint = 2;
pub static SDL_KEYDOWNMASK: c_uint = 4;
pub static SDL_KEYUPMASK: c_uint = 8;
pub static SDL_KEYEVENTMASK: c_uint = 12;
pub static SDL_MOUSEMOTIONMASK: c_uint = 16;
pub static SDL_MOUSEBUTTONDOWNMASK: c_uint = 32;
pub static SDL_MOUSEBUTTONUPMASK: c_uint = 64;
pub static SDL_MOUSEEVENTMASK: c_uint = 112;
pub static SDL_JOYAXISMOTIONMASK: c_uint = 128;
pub static SDL_JOYBALLMOTIONMASK: c_uint = 256;
pub static SDL_JOYHATMOTIONMASK: c_uint = 512;
pub static SDL_JOYBUTTONDOWNMASK: c_uint = 1024;
pub static SDL_JOYBUTTONUPMASK: c_uint = 2048;
pub static SDL_JOYEVENTMASK: c_uint = 3968;
pub static SDL_VIDEORESIZEMASK: c_uint = 65536;
pub static SDL_VIDEOEXPOSEMASK: c_uint = 131072;
pub static SDL_QUITMASK: c_uint = 4096;
pub static SDL_SYSWMEVENTMASK: c_uint = 8192;
pub struct Struct_SDL_ActiveEvent {
    pub _type: Uint8,
    pub gain: Uint8,
    pub state: Uint8,
}
pub type SDL_ActiveEvent = Struct_SDL_ActiveEvent;
pub struct Struct_SDL_KeyboardEvent {
    pub _type: Uint8,
    pub which: Uint8,
    pub state: Uint8,
    pub keysym: SDL_keysym,
}
pub type SDL_KeyboardEvent = Struct_SDL_KeyboardEvent;
pub struct Struct_SDL_MouseMotionEvent {
    pub _type: Uint8,
    pub which: Uint8,
    pub state: Uint8,
    pub x: Uint16,
    pub y: Uint16,
    pub xrel: Sint16,
    pub yrel: Sint16,
}
pub type SDL_MouseMotionEvent = Struct_SDL_MouseMotionEvent;
pub struct Struct_SDL_MouseButtonEvent {
    pub _type: Uint8,
    pub which: Uint8,
    pub button: Uint8,
    pub state: Uint8,
    pub x: Uint16,
    pub y: Uint16,
}
pub type SDL_MouseButtonEvent = Struct_SDL_MouseButtonEvent;
pub struct Struct_SDL_JoyAxisEvent {
    pub _type: Uint8,
    pub which: Uint8,
    pub axis: Uint8,
    pub value: Sint16,
}
pub type SDL_JoyAxisEvent = Struct_SDL_JoyAxisEvent;
pub struct Struct_SDL_JoyBallEvent {
    pub _type: Uint8,
    pub which: Uint8,
    pub ball: Uint8,
    pub xrel: Sint16,
    pub yrel: Sint16,
}
pub type SDL_JoyBallEvent = Struct_SDL_JoyBallEvent;
pub struct Struct_SDL_JoyHatEvent {
    pub _type: Uint8,
    pub which: Uint8,
    pub hat: Uint8,
    pub value: Uint8,
}
pub type SDL_JoyHatEvent = Struct_SDL_JoyHatEvent;
pub struct Struct_SDL_JoyButtonEvent {
    pub _type: Uint8,
    pub which: Uint8,
    pub button: Uint8,
    pub state: Uint8,
}
pub type SDL_JoyButtonEvent = Struct_SDL_JoyButtonEvent;
pub struct Struct_SDL_ResizeEvent {
    pub _type: Uint8,
    pub w: c_int,
    pub h: c_int,
}
pub type SDL_ResizeEvent = Struct_SDL_ResizeEvent;
pub struct Struct_SDL_ExposeEvent {
    pub _type: Uint8,
}
pub type SDL_ExposeEvent = Struct_SDL_ExposeEvent;
pub struct Struct_SDL_QuitEvent {
    pub _type: Uint8,
}
pub type SDL_QuitEvent = Struct_SDL_QuitEvent;
pub struct Struct_SDL_UserEvent {
    pub _type: Uint8,
    pub code: c_int,
    pub data1: *mut c_void,
    pub data2: *mut c_void,
}
pub type SDL_UserEvent = Struct_SDL_UserEvent;
pub type Struct_SDL_SysWMmsg = c_void;
pub type SDL_SysWMmsg = Struct_SDL_SysWMmsg;
pub struct Struct_SDL_SysWMEvent {
    pub _type: Uint8,
    pub msg: *mut SDL_SysWMmsg,
}
pub type SDL_SysWMEvent = Struct_SDL_SysWMEvent;
pub struct Union_SDL_Event {
    pub data: [u64, ..3u],
}
impl Union_SDL_Event {
    pub fn _type(&mut self) -> *mut Uint8 {
        unsafe { ::std::cast::transmute(self) }
    }
    pub fn active(&mut self) -> *mut SDL_ActiveEvent {
        unsafe { ::std::cast::transmute(self) }
    }
    pub fn key(&mut self) -> *mut SDL_KeyboardEvent {
        unsafe { ::std::cast::transmute(self) }
    }
    pub fn motion(&mut self) -> *mut SDL_MouseMotionEvent {
        unsafe { ::std::cast::transmute(self) }
    }
    pub fn button(&mut self) -> *mut SDL_MouseButtonEvent {
        unsafe { ::std::cast::transmute(self) }
    }
    pub fn jaxis(&mut self) -> *mut SDL_JoyAxisEvent {
        unsafe { ::std::cast::transmute(self) }
    }
    pub fn jball(&mut self) -> *mut SDL_JoyBallEvent {
        unsafe { ::std::cast::transmute(self) }
    }
    pub fn jhat(&mut self) -> *mut SDL_JoyHatEvent {
        unsafe { ::std::cast::transmute(self) }
    }
    pub fn jbutton(&mut self) -> *mut SDL_JoyButtonEvent {
        unsafe { ::std::cast::transmute(self) }
    }
    pub fn resize(&mut self) -> *mut SDL_ResizeEvent {
        unsafe { ::std::cast::transmute(self) }
    }
    pub fn expose(&mut self) -> *mut SDL_ExposeEvent {
        unsafe { ::std::cast::transmute(self) }
    }
    pub fn quit(&mut self) -> *mut SDL_QuitEvent {
        unsafe { ::std::cast::transmute(self) }
    }
    pub fn user(&mut self) -> *mut SDL_UserEvent {
        unsafe { ::std::cast::transmute(self) }
    }
    pub fn syswm(&mut self) -> *mut SDL_SysWMEvent {
        unsafe { ::std::cast::transmute(self) }
    }
}
pub type SDL_Event = Union_SDL_Event;
pub type SDL_eventaction = c_uint;
pub static SDL_ADDEVENT: c_uint = 0;
pub static SDL_PEEKEVENT: c_uint = 1;
pub static SDL_GETEVENT: c_uint = 2;
pub type SDL_EventFilter =
    ::std::option::Option<extern "C" fn(arg1: *SDL_Event) -> c_int>;
pub type SDL_TimerCallback =
    ::std::option::Option<extern "C" fn(arg1: Uint32) -> Uint32>;
pub type SDL_NewTimerCallback =
    ::std::option::Option<extern "C" fn(arg1: Uint32, arg2: *mut c_void)
                              -> Uint32>;
pub type Struct__SDL_TimerID = c_void;
pub type SDL_TimerID = *mut Struct__SDL_TimerID;
pub struct Struct_SDL_version {
    pub major: Uint8,
    pub minor: Uint8,
    pub patch: Uint8,
}
pub type SDL_version = Struct_SDL_version;
pub type Struct__TTF_Font = c_void;
pub type TTF_Font = Struct__TTF_Font;
pub type __va_list_tag = Struct___va_list_tag;
pub struct Struct___va_list_tag {
    pub gp_offset: c_uint,
    pub fp_offset: c_uint,
    pub overflow_arg_area: *mut c_void,
    pub reg_save_area: *mut c_void,
}
extern "C" {
    pub static mut _IO_2_1_stdin_: Struct__IO_FILE_plus;
    pub static mut _IO_2_1_stdout_: Struct__IO_FILE_plus;
    pub static mut _IO_2_1_stderr_: Struct__IO_FILE_plus;
    pub static mut stdin: *mut Struct__IO_FILE;
    pub static mut stdout: *mut Struct__IO_FILE;
    pub static mut stderr: *mut Struct__IO_FILE;
    pub static mut sys_nerr: c_int;
    pub static mut sys_errlist: c_void;
    pub static mut _sys_nerr: c_int;
    pub static mut _sys_errlist: c_void;
    pub fn select(__nfds: c_int, __readfds: *mut fd_set,
                  __writefds: *mut fd_set, __exceptfds: *mut fd_set,
                  __timeout: *mut Struct_timeval) -> c_int;
    pub fn pselect(__nfds: c_int, __readfds: *mut fd_set,
                   __writefds: *mut fd_set, __exceptfds: *mut fd_set,
                   __timeout: *Struct_timespec, __sigmask: *__sigset_t) ->
     c_int;
    pub fn gnu_dev_major(__dev: c_ulonglong) -> c_uint;
    pub fn gnu_dev_minor(__dev: c_ulonglong) -> c_uint;
    pub fn gnu_dev_makedev(__major: c_uint, __minor: c_uint) -> c_ulonglong;
    pub fn _IO_cookie_init(__cfile: *mut Struct__IO_cookie_file,
                           __read_write: c_int, __cookie: *mut c_void,
                           __fns: _IO_cookie_io_functions_t);
    pub fn __underflow(arg1: *mut _IO_FILE) -> c_int;
    pub fn __uflow(arg1: *mut _IO_FILE) -> c_int;
    pub fn __overflow(arg1: *mut _IO_FILE, arg2: c_int) -> c_int;
    pub fn _IO_getc(__fp: *mut _IO_FILE) -> c_int;
    pub fn _IO_putc(__c: c_int, __fp: *mut _IO_FILE) -> c_int;
    pub fn _IO_feof(__fp: *mut _IO_FILE) -> c_int;
    pub fn _IO_ferror(__fp: *mut _IO_FILE) -> c_int;
    pub fn _IO_peekc_locked(__fp: *mut _IO_FILE) -> c_int;
    pub fn _IO_flockfile(arg1: *mut _IO_FILE);
    pub fn _IO_funlockfile(arg1: *mut _IO_FILE);
    pub fn _IO_ftrylockfile(arg1: *mut _IO_FILE) -> c_int;
    pub fn _IO_vfscanf(arg1: *mut _IO_FILE, arg2: *c_schar,
                       arg3: __gnuc_va_list, arg4: *mut c_int) -> c_int;
    pub fn _IO_vfprintf(arg1: *mut _IO_FILE, arg2: *c_schar,
                        arg3: __gnuc_va_list) -> c_int;
    pub fn _IO_padn(arg1: *mut _IO_FILE, arg2: c_int, arg3: __ssize_t) ->
     __ssize_t;
    pub fn _IO_sgetn(arg1: *mut _IO_FILE, arg2: *mut c_void, arg3: size_t) ->
     size_t;
    pub fn _IO_seekoff(arg1: *mut _IO_FILE, arg2: __off64_t, arg3: c_int,
                       arg4: c_int) -> __off64_t;
    pub fn _IO_seekpos(arg1: *mut _IO_FILE, arg2: __off64_t, arg3: c_int) ->
     __off64_t;
    pub fn _IO_free_backup_area(arg1: *mut _IO_FILE);
    pub fn remove(__filename: *c_schar) -> c_int;
    pub fn rename(__old: *c_schar, __new: *c_schar) -> c_int;
    pub fn renameat(__oldfd: c_int, __old: *c_schar, __newfd: c_int,
                    __new: *c_schar) -> c_int;
    pub fn tmpfile() -> *mut FILE;
    pub fn tmpfile64() -> *mut FILE;
    pub fn tmpnam(__s: *mut c_schar) -> *mut c_schar;
    pub fn tmpnam_r(__s: *mut c_schar) -> *mut c_schar;
    pub fn tempnam(__dir: *c_schar, __pfx: *c_schar) -> *mut c_schar;
    pub fn fclose(__stream: *mut FILE) -> c_int;
    pub fn fflush(__stream: *mut FILE) -> c_int;
    pub fn fflush_unlocked(__stream: *mut FILE) -> c_int;
    pub fn fcloseall() -> c_int;
    pub fn fopen(__filename: *c_schar, __modes: *c_schar) -> *mut FILE;
    pub fn freopen(__filename: *c_schar, __modes: *c_schar,
                   __stream: *mut FILE) -> *mut FILE;
    pub fn fopen64(__filename: *c_schar, __modes: *c_schar) -> *mut FILE;
    pub fn freopen64(__filename: *c_schar, __modes: *c_schar,
                     __stream: *mut FILE) -> *mut FILE;
    pub fn fdopen(__fd: c_int, __modes: *c_schar) -> *mut FILE;
    pub fn fopencookie(__magic_cookie: *mut c_void, __modes: *c_schar,
                       __io_funcs: _IO_cookie_io_functions_t) -> *mut FILE;
    pub fn fmemopen(__s: *mut c_void, __len: size_t, __modes: *c_schar) ->
     *mut FILE;
    pub fn open_memstream(__bufloc: *mut *mut c_schar, __sizeloc: *mut size_t)
     -> *mut FILE;
    pub fn setbuf(__stream: *mut FILE, __buf: *mut c_schar);
    pub fn setvbuf(__stream: *mut FILE, __buf: *mut c_schar, __modes: c_int,
                   __n: size_t) -> c_int;
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut c_schar,
                     __size: size_t);
    pub fn setlinebuf(__stream: *mut FILE);
    pub fn fprintf(__stream: *mut FILE, __format: *c_schar, ...) -> c_int;
    pub fn printf(__format: *c_schar, ...) -> c_int;
    pub fn sprintf(__s: *mut c_schar, __format: *c_schar, ...) -> c_int;
    pub fn vfprintf(__s: *mut FILE, __format: *c_schar, __arg: __gnuc_va_list)
     -> c_int;
    pub fn vprintf(__format: *c_schar, __arg: __gnuc_va_list) -> c_int;
    pub fn vsprintf(__s: *mut c_schar, __format: *c_schar,
                    __arg: __gnuc_va_list) -> c_int;
    pub fn snprintf(__s: *mut c_schar, __maxlen: size_t,
                    __format: *c_schar, ...) -> c_int;
    pub fn vsnprintf(__s: *mut c_schar, __maxlen: size_t, __format: *c_schar,
                     __arg: __gnuc_va_list) -> c_int;
    pub fn vasprintf(__ptr: *mut *mut c_schar, __f: *c_schar,
                     __arg: __gnuc_va_list) -> c_int;
    pub fn __asprintf(__ptr: *mut *mut c_schar, __fmt: *c_schar, ...) ->
     c_int;
    pub fn asprintf(__ptr: *mut *mut c_schar, __fmt: *c_schar, ...) -> c_int;
    pub fn vdprintf(__fd: c_int, __fmt: *c_schar, __arg: __gnuc_va_list) ->
     c_int;
    pub fn dprintf(__fd: c_int, __fmt: *c_schar, ...) -> c_int;
    pub fn fscanf(__stream: *mut FILE, __format: *c_schar, ...) -> c_int;
    pub fn scanf(__format: *c_schar, ...) -> c_int;
    pub fn sscanf(__s: *c_schar, __format: *c_schar, ...) -> c_int;
    pub fn vfscanf(__s: *mut FILE, __format: *c_schar, __arg: __gnuc_va_list)
     -> c_int;
    pub fn vscanf(__format: *c_schar, __arg: __gnuc_va_list) -> c_int;
    pub fn vsscanf(__s: *c_schar, __format: *c_schar, __arg: __gnuc_va_list)
     -> c_int;
    pub fn fgetc(__stream: *mut FILE) -> c_int;
    pub fn getc(__stream: *mut FILE) -> c_int;
    pub fn getchar() -> c_int;
    pub fn getc_unlocked(__stream: *mut FILE) -> c_int;
    pub fn getchar_unlocked() -> c_int;
    pub fn fgetc_unlocked(__stream: *mut FILE) -> c_int;
    pub fn fputc(__c: c_int, __stream: *mut FILE) -> c_int;
    pub fn putc(__c: c_int, __stream: *mut FILE) -> c_int;
    pub fn putchar(__c: c_int) -> c_int;
    pub fn fputc_unlocked(__c: c_int, __stream: *mut FILE) -> c_int;
    pub fn putc_unlocked(__c: c_int, __stream: *mut FILE) -> c_int;
    pub fn putchar_unlocked(__c: c_int) -> c_int;
    pub fn getw(__stream: *mut FILE) -> c_int;
    pub fn putw(__w: c_int, __stream: *mut FILE) -> c_int;
    pub fn fgets(__s: *mut c_schar, __n: c_int, __stream: *mut FILE) ->
     *mut c_schar;
    pub fn fgets_unlocked(__s: *mut c_schar, __n: c_int, __stream: *mut FILE)
     -> *mut c_schar;
    pub fn __getdelim(__lineptr: *mut *mut c_schar, __n: *mut size_t,
                      __delimiter: c_int, __stream: *mut FILE) -> __ssize_t;
    pub fn getdelim(__lineptr: *mut *mut c_schar, __n: *mut size_t,
                    __delimiter: c_int, __stream: *mut FILE) -> __ssize_t;
    pub fn getline(__lineptr: *mut *mut c_schar, __n: *mut size_t,
                   __stream: *mut FILE) -> __ssize_t;
    pub fn fputs(__s: *c_schar, __stream: *mut FILE) -> c_int;
    pub fn puts(__s: *c_schar) -> c_int;
    pub fn ungetc(__c: c_int, __stream: *mut FILE) -> c_int;
    pub fn fread(__ptr: *mut c_void, __size: size_t, __n: size_t,
                 __stream: *mut FILE) -> size_t;
    pub fn fwrite(__ptr: *c_void, __size: size_t, __n: size_t, __s: *mut FILE)
     -> size_t;
    pub fn fputs_unlocked(__s: *c_schar, __stream: *mut FILE) -> c_int;
    pub fn fread_unlocked(__ptr: *mut c_void, __size: size_t, __n: size_t,
                          __stream: *mut FILE) -> size_t;
    pub fn fwrite_unlocked(__ptr: *c_void, __size: size_t, __n: size_t,
                           __stream: *mut FILE) -> size_t;
    pub fn fseek(__stream: *mut FILE, __off: c_long, __whence: c_int) ->
     c_int;
    pub fn ftell(__stream: *mut FILE) -> c_long;
    pub fn rewind(__stream: *mut FILE);
    pub fn fseeko(__stream: *mut FILE, __off: __off_t, __whence: c_int) ->
     c_int;
    pub fn ftello(__stream: *mut FILE) -> __off_t;
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> c_int;
    pub fn fsetpos(__stream: *mut FILE, __pos: *fpos_t) -> c_int;
    pub fn fseeko64(__stream: *mut FILE, __off: __off64_t, __whence: c_int) ->
     c_int;
    pub fn ftello64(__stream: *mut FILE) -> __off64_t;
    pub fn fgetpos64(__stream: *mut FILE, __pos: *mut fpos64_t) -> c_int;
    pub fn fsetpos64(__stream: *mut FILE, __pos: *fpos64_t) -> c_int;
    pub fn clearerr(__stream: *mut FILE);
    pub fn feof(__stream: *mut FILE) -> c_int;
    pub fn ferror(__stream: *mut FILE) -> c_int;
    pub fn clearerr_unlocked(__stream: *mut FILE);
    pub fn feof_unlocked(__stream: *mut FILE) -> c_int;
    pub fn ferror_unlocked(__stream: *mut FILE) -> c_int;
    pub fn perror(__s: *c_schar);
    pub fn fileno(__stream: *mut FILE) -> c_int;
    pub fn fileno_unlocked(__stream: *mut FILE) -> c_int;
    pub fn popen(__command: *c_schar, __modes: *c_schar) -> *mut FILE;
    pub fn pclose(__stream: *mut FILE) -> c_int;
    pub fn ctermid(__s: *mut c_schar) -> *mut c_schar;
    pub fn cuserid(__s: *mut c_schar) -> *mut c_schar;
    pub fn obstack_printf(__obstack: *mut Struct_obstack,
                          __format: *c_schar, ...) -> c_int;
    pub fn obstack_vprintf(__obstack: *mut Struct_obstack, __format: *c_schar,
                           __args: __gnuc_va_list) -> c_int;
    pub fn flockfile(__stream: *mut FILE);
    pub fn ftrylockfile(__stream: *mut FILE) -> c_int;
    pub fn funlockfile(__stream: *mut FILE);
    pub fn __ctype_get_mb_cur_max() -> size_t;
    pub fn atof(__nptr: *c_schar) -> c_double;
    pub fn atoi(__nptr: *c_schar) -> c_int;
    pub fn atol(__nptr: *c_schar) -> c_long;
    pub fn atoll(__nptr: *c_schar) -> c_longlong;
    pub fn strtod(__nptr: *c_schar, __endptr: *mut *mut c_schar) -> c_double;
    pub fn strtof(__nptr: *c_schar, __endptr: *mut *mut c_schar) -> c_float;
    pub fn strtold(__nptr: *c_schar, __endptr: *mut *mut c_schar) -> c_double;
    pub fn strtol(__nptr: *c_schar, __endptr: *mut *mut c_schar,
                  __base: c_int) -> c_long;
    pub fn strtoul(__nptr: *c_schar, __endptr: *mut *mut c_schar,
                   __base: c_int) -> c_ulong;
    pub fn strtoq(__nptr: *c_schar, __endptr: *mut *mut c_schar,
                  __base: c_int) -> c_longlong;
    pub fn strtouq(__nptr: *c_schar, __endptr: *mut *mut c_schar,
                   __base: c_int) -> c_ulonglong;
    pub fn strtoll(__nptr: *c_schar, __endptr: *mut *mut c_schar,
                   __base: c_int) -> c_longlong;
    pub fn strtoull(__nptr: *c_schar, __endptr: *mut *mut c_schar,
                    __base: c_int) -> c_ulonglong;
    pub fn strtol_l(__nptr: *c_schar, __endptr: *mut *mut c_schar,
                    __base: c_int, __loc: __locale_t) -> c_long;
    pub fn strtoul_l(__nptr: *c_schar, __endptr: *mut *mut c_schar,
                     __base: c_int, __loc: __locale_t) -> c_ulong;
    pub fn strtoll_l(__nptr: *c_schar, __endptr: *mut *mut c_schar,
                     __base: c_int, __loc: __locale_t) -> c_longlong;
    pub fn strtoull_l(__nptr: *c_schar, __endptr: *mut *mut c_schar,
                      __base: c_int, __loc: __locale_t) -> c_ulonglong;
    pub fn strtod_l(__nptr: *c_schar, __endptr: *mut *mut c_schar,
                    __loc: __locale_t) -> c_double;
    pub fn strtof_l(__nptr: *c_schar, __endptr: *mut *mut c_schar,
                    __loc: __locale_t) -> c_float;
    pub fn strtold_l(__nptr: *c_schar, __endptr: *mut *mut c_schar,
                     __loc: __locale_t) -> c_double;
    pub fn l64a(__n: c_long) -> *mut c_schar;
    pub fn a64l(__s: *c_schar) -> c_long;
    pub fn random() -> c_long;
    pub fn srandom(__seed: c_uint);
    pub fn initstate(__seed: c_uint, __statebuf: *mut c_schar,
                     __statelen: size_t) -> *mut c_schar;
    pub fn setstate(__statebuf: *mut c_schar) -> *mut c_schar;
    pub fn random_r(__buf: *mut Struct_random_data, __result: *mut int32_t) ->
     c_int;
    pub fn srandom_r(__seed: c_uint, __buf: *mut Struct_random_data) -> c_int;
    pub fn initstate_r(__seed: c_uint, __statebuf: *mut c_schar,
                       __statelen: size_t, __buf: *mut Struct_random_data) ->
     c_int;
    pub fn setstate_r(__statebuf: *mut c_schar,
                      __buf: *mut Struct_random_data) -> c_int;
    pub fn rand() -> c_int;
    pub fn srand(__seed: c_uint);
    pub fn rand_r(__seed: *mut c_uint) -> c_int;
    pub fn drand48() -> c_double;
    pub fn erand48(__xsubi: [c_ushort, ..3u]) -> c_double;
    pub fn lrand48() -> c_long;
    pub fn nrand48(__xsubi: [c_ushort, ..3u]) -> c_long;
    pub fn mrand48() -> c_long;
    pub fn jrand48(__xsubi: [c_ushort, ..3u]) -> c_long;
    pub fn srand48(__seedval: c_long);
    pub fn seed48(__seed16v: [c_ushort, ..3u]) -> *mut c_ushort;
    pub fn lcong48(__param: [c_ushort, ..7u]);
    pub fn drand48_r(__buffer: *mut Struct_drand48_data,
                     __result: *mut c_double) -> c_int;
    pub fn erand48_r(__xsubi: [c_ushort, ..3u],
                     __buffer: *mut Struct_drand48_data,
                     __result: *mut c_double) -> c_int;
    pub fn lrand48_r(__buffer: *mut Struct_drand48_data,
                     __result: *mut c_long) -> c_int;
    pub fn nrand48_r(__xsubi: [c_ushort, ..3u],
                     __buffer: *mut Struct_drand48_data,
                     __result: *mut c_long) -> c_int;
    pub fn mrand48_r(__buffer: *mut Struct_drand48_data,
                     __result: *mut c_long) -> c_int;
    pub fn jrand48_r(__xsubi: [c_ushort, ..3u],
                     __buffer: *mut Struct_drand48_data,
                     __result: *mut c_long) -> c_int;
    pub fn srand48_r(__seedval: c_long, __buffer: *mut Struct_drand48_data) ->
     c_int;
    pub fn seed48_r(__seed16v: [c_ushort, ..3u],
                    __buffer: *mut Struct_drand48_data) -> c_int;
    pub fn lcong48_r(__param: [c_ushort, ..7u],
                     __buffer: *mut Struct_drand48_data) -> c_int;
    pub fn malloc(__size: size_t) -> *mut c_void;
    pub fn calloc(__nmemb: size_t, __size: size_t) -> *mut c_void;
    pub fn realloc(__ptr: *mut c_void, __size: size_t) -> *mut c_void;
    pub fn free(__ptr: *mut c_void);
    pub fn cfree(__ptr: *mut c_void);
    pub fn alloca(__size: size_t) -> *mut c_void;
    pub fn valloc(__size: size_t) -> *mut c_void;
    pub fn posix_memalign(__memptr: *mut *mut c_void, __alignment: size_t,
                          __size: size_t) -> c_int;
    pub fn aligned_alloc(__alignment: size_t, __size: size_t) -> *mut c_void;
    pub fn abort();
    pub fn atexit(__func: ::std::option::Option<extern "C" fn()>) -> c_int;
    pub fn at_quick_exit(__func: ::std::option::Option<extern "C" fn()>) ->
     c_int;
    pub fn on_exit(__func:
                       ::std::option::Option<extern "C" fn
                                                 (arg1: c_int,
                                                  arg2: *mut c_void)>,
                   __arg: *mut c_void) -> c_int;
    pub fn exit(__status: c_int);
    pub fn quick_exit(__status: c_int);
    pub fn _Exit(__status: c_int);
    pub fn getenv(__name: *c_schar) -> *mut c_schar;
    pub fn secure_getenv(__name: *c_schar) -> *mut c_schar;
    pub fn putenv(__string: *mut c_schar) -> c_int;
    pub fn setenv(__name: *c_schar, __value: *c_schar, __replace: c_int) ->
     c_int;
    pub fn unsetenv(__name: *c_schar) -> c_int;
    pub fn clearenv() -> c_int;
    pub fn mktemp(__template: *mut c_schar) -> *mut c_schar;
    pub fn mkstemp(__template: *mut c_schar) -> c_int;
    pub fn mkstemp64(__template: *mut c_schar) -> c_int;
    pub fn mkstemps(__template: *mut c_schar, __suffixlen: c_int) -> c_int;
    pub fn mkstemps64(__template: *mut c_schar, __suffixlen: c_int) -> c_int;
    pub fn mkdtemp(__template: *mut c_schar) -> *mut c_schar;
    pub fn mkostemp(__template: *mut c_schar, __flags: c_int) -> c_int;
    pub fn mkostemp64(__template: *mut c_schar, __flags: c_int) -> c_int;
    pub fn mkostemps(__template: *mut c_schar, __suffixlen: c_int,
                     __flags: c_int) -> c_int;
    pub fn mkostemps64(__template: *mut c_schar, __suffixlen: c_int,
                       __flags: c_int) -> c_int;
    pub fn system(__command: *c_schar) -> c_int;
    pub fn canonicalize_file_name(__name: *c_schar) -> *mut c_schar;
    pub fn realpath(__name: *c_schar, __resolved: *mut c_schar) ->
     *mut c_schar;
    pub fn bsearch(__key: *c_void, __base: *c_void, __nmemb: size_t,
                   __size: size_t, __compar: __compar_fn_t) -> *mut c_void;
    pub fn qsort(__base: *mut c_void, __nmemb: size_t, __size: size_t,
                 __compar: __compar_fn_t);
    pub fn qsort_r(__base: *mut c_void, __nmemb: size_t, __size: size_t,
                   __compar: __compar_d_fn_t, __arg: *mut c_void);
    pub fn abs(__x: c_int) -> c_int;
    pub fn labs(__x: c_long) -> c_long;
    pub fn llabs(__x: c_longlong) -> c_longlong;
    pub fn div(__numer: c_int, __denom: c_int) -> div_t;
    pub fn ldiv(__numer: c_long, __denom: c_long) -> ldiv_t;
    pub fn lldiv(__numer: c_longlong, __denom: c_longlong) -> lldiv_t;
    pub fn ecvt(__value: c_double, __ndigit: c_int, __decpt: *mut c_int,
                __sign: *mut c_int) -> *mut c_schar;
    pub fn fcvt(__value: c_double, __ndigit: c_int, __decpt: *mut c_int,
                __sign: *mut c_int) -> *mut c_schar;
    pub fn gcvt(__value: c_double, __ndigit: c_int, __buf: *mut c_schar) ->
     *mut c_schar;
    pub fn qecvt(__value: c_double, __ndigit: c_int, __decpt: *mut c_int,
                 __sign: *mut c_int) -> *mut c_schar;
    pub fn qfcvt(__value: c_double, __ndigit: c_int, __decpt: *mut c_int,
                 __sign: *mut c_int) -> *mut c_schar;
    pub fn qgcvt(__value: c_double, __ndigit: c_int, __buf: *mut c_schar) ->
     *mut c_schar;
    pub fn ecvt_r(__value: c_double, __ndigit: c_int, __decpt: *mut c_int,
                  __sign: *mut c_int, __buf: *mut c_schar, __len: size_t) ->
     c_int;
    pub fn fcvt_r(__value: c_double, __ndigit: c_int, __decpt: *mut c_int,
                  __sign: *mut c_int, __buf: *mut c_schar, __len: size_t) ->
     c_int;
    pub fn qecvt_r(__value: c_double, __ndigit: c_int, __decpt: *mut c_int,
                   __sign: *mut c_int, __buf: *mut c_schar, __len: size_t) ->
     c_int;
    pub fn qfcvt_r(__value: c_double, __ndigit: c_int, __decpt: *mut c_int,
                   __sign: *mut c_int, __buf: *mut c_schar, __len: size_t) ->
     c_int;
    pub fn mblen(__s: *c_schar, __n: size_t) -> c_int;
    pub fn mbtowc(__pwc: *mut wchar_t, __s: *c_schar, __n: size_t) -> c_int;
    pub fn wctomb(__s: *mut c_schar, __wchar: wchar_t) -> c_int;
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *c_schar, __n: size_t) ->
     size_t;
    pub fn wcstombs(__s: *mut c_schar, __pwcs: *wchar_t, __n: size_t) ->
     size_t;
    pub fn rpmatch(__response: *c_schar) -> c_int;
    pub fn getsubopt(__optionp: *mut *mut c_schar, __tokens: **mut c_schar,
                     __valuep: *mut *mut c_schar) -> c_int;
    pub fn setkey(__key: *c_schar);
    pub fn posix_openpt(__oflag: c_int) -> c_int;
    pub fn grantpt(__fd: c_int) -> c_int;
    pub fn unlockpt(__fd: c_int) -> c_int;
    pub fn ptsname(__fd: c_int) -> *mut c_schar;
    pub fn ptsname_r(__fd: c_int, __buf: *mut c_schar, __buflen: size_t) ->
     c_int;
    pub fn getpt() -> c_int;
    pub fn getloadavg(__loadavg: c_void, __nelem: c_int) -> c_int;
    pub fn memcpy(__dest: *mut c_void, __src: *c_void, __n: size_t) ->
     *mut c_void;
    pub fn memmove(__dest: *mut c_void, __src: *c_void, __n: size_t) ->
     *mut c_void;
    pub fn memccpy(__dest: *mut c_void, __src: *c_void, __c: c_int,
                   __n: size_t) -> *mut c_void;
    pub fn memset(__s: *mut c_void, __c: c_int, __n: size_t) -> *mut c_void;
    pub fn memcmp(__s1: *c_void, __s2: *c_void, __n: size_t) -> c_int;
    pub fn memchr(__s: *c_void, __c: c_int, __n: size_t) -> *mut c_void;
    pub fn rawmemchr(__s: *c_void, __c: c_int) -> *mut c_void;
    pub fn memrchr(__s: *c_void, __c: c_int, __n: size_t) -> *mut c_void;
    pub fn strcpy(__dest: *mut c_schar, __src: *c_schar) -> *mut c_schar;
    pub fn strncpy(__dest: *mut c_schar, __src: *c_schar, __n: size_t) ->
     *mut c_schar;
    pub fn strcat(__dest: *mut c_schar, __src: *c_schar) -> *mut c_schar;
    pub fn strncat(__dest: *mut c_schar, __src: *c_schar, __n: size_t) ->
     *mut c_schar;
    pub fn strcmp(__s1: *c_schar, __s2: *c_schar) -> c_int;
    pub fn strncmp(__s1: *c_schar, __s2: *c_schar, __n: size_t) -> c_int;
    pub fn strcoll(__s1: *c_schar, __s2: *c_schar) -> c_int;
    pub fn strxfrm(__dest: *mut c_schar, __src: *c_schar, __n: size_t) ->
     size_t;
    pub fn strcoll_l(__s1: *c_schar, __s2: *c_schar, __l: __locale_t) ->
     c_int;
    pub fn strxfrm_l(__dest: *mut c_schar, __src: *c_schar, __n: size_t,
                     __l: __locale_t) -> size_t;
    pub fn strdup(__s: *c_schar) -> *mut c_schar;
    pub fn strndup(__string: *c_schar, __n: size_t) -> *mut c_schar;
    pub fn strchr(__s: *c_schar, __c: c_int) -> *mut c_schar;
    pub fn strrchr(__s: *c_schar, __c: c_int) -> *mut c_schar;
    pub fn strchrnul(__s: *c_schar, __c: c_int) -> *mut c_schar;
    pub fn strcspn(__s: *c_schar, __reject: *c_schar) -> size_t;
    pub fn strspn(__s: *c_schar, __accept: *c_schar) -> size_t;
    pub fn strpbrk(__s: *c_schar, __accept: *c_schar) -> *mut c_schar;
    pub fn strstr(__haystack: *c_schar, __needle: *c_schar) -> *mut c_schar;
    pub fn strtok(__s: *mut c_schar, __delim: *c_schar) -> *mut c_schar;
    pub fn __strtok_r(__s: *mut c_schar, __delim: *c_schar,
                      __save_ptr: *mut *mut c_schar) -> *mut c_schar;
    pub fn strtok_r(__s: *mut c_schar, __delim: *c_schar,
                    __save_ptr: *mut *mut c_schar) -> *mut c_schar;
    pub fn strcasestr(__haystack: *c_schar, __needle: *c_schar) ->
     *mut c_schar;
    pub fn memmem(__haystack: *c_void, __haystacklen: size_t,
                  __needle: *c_void, __needlelen: size_t) -> *mut c_void;
    pub fn __mempcpy(__dest: *mut c_void, __src: *c_void, __n: size_t) ->
     *mut c_void;
    pub fn mempcpy(__dest: *mut c_void, __src: *c_void, __n: size_t) ->
     *mut c_void;
    pub fn strlen(__s: *c_schar) -> size_t;
    pub fn strnlen(__string: *c_schar, __maxlen: size_t) -> size_t;
    pub fn strerror(__errnum: c_int) -> *mut c_schar;
    pub fn strerror_r(__errnum: c_int, __buf: *mut c_schar, __buflen: size_t)
     -> *mut c_schar;
    pub fn strerror_l(__errnum: c_int, __l: __locale_t) -> *mut c_schar;
    pub fn __bzero(__s: *mut c_void, __n: size_t);
    pub fn bcopy(__src: *c_void, __dest: *mut c_void, __n: size_t);
    pub fn bzero(__s: *mut c_void, __n: size_t);
    pub fn bcmp(__s1: *c_void, __s2: *c_void, __n: size_t) -> c_int;
    pub fn index(__s: *c_schar, __c: c_int) -> *mut c_schar;
    pub fn rindex(__s: *c_schar, __c: c_int) -> *mut c_schar;
    pub fn ffs(__i: c_int) -> c_int;
    pub fn ffsl(__l: c_long) -> c_int;
    pub fn ffsll(__ll: c_longlong) -> c_int;
    pub fn strcasecmp(__s1: *c_schar, __s2: *c_schar) -> c_int;
    pub fn strncasecmp(__s1: *c_schar, __s2: *c_schar, __n: size_t) -> c_int;
    pub fn strcasecmp_l(__s1: *c_schar, __s2: *c_schar, __loc: __locale_t) ->
     c_int;
    pub fn strncasecmp_l(__s1: *c_schar, __s2: *c_schar, __n: size_t,
                         __loc: __locale_t) -> c_int;
    pub fn strsep(__stringp: *mut *mut c_schar, __delim: *c_schar) ->
     *mut c_schar;
    pub fn strsignal(__sig: c_int) -> *mut c_schar;
    pub fn __stpcpy(__dest: *mut c_schar, __src: *c_schar) -> *mut c_schar;
    pub fn stpcpy(__dest: *mut c_schar, __src: *c_schar) -> *mut c_schar;
    pub fn __stpncpy(__dest: *mut c_schar, __src: *c_schar, __n: size_t) ->
     *mut c_schar;
    pub fn stpncpy(__dest: *mut c_schar, __src: *c_schar, __n: size_t) ->
     *mut c_schar;
    pub fn strverscmp(__s1: *c_schar, __s2: *c_schar) -> c_int;
    pub fn strfry(__string: *mut c_schar) -> *mut c_schar;
    pub fn memfrob(__s: *mut c_void, __n: size_t) -> *mut c_void;
    pub fn basename(__filename: *c_schar) -> *mut c_schar;
    pub fn imaxabs(__n: intmax_t) -> intmax_t;
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
    pub fn strtoimax(__nptr: *c_schar, __endptr: *mut *mut c_schar,
                     __base: c_int) -> intmax_t;
    pub fn strtoumax(__nptr: *c_schar, __endptr: *mut *mut c_schar,
                     __base: c_int) -> uintmax_t;
    pub fn wcstoimax(__nptr: *__gwchar_t, __endptr: *mut *mut __gwchar_t,
                     __base: c_int) -> intmax_t;
    pub fn wcstoumax(__nptr: *__gwchar_t, __endptr: *mut *mut __gwchar_t,
                     __base: c_int) -> uintmax_t;
    pub fn __ctype_b_loc() -> *mut *c_ushort;
    pub fn __ctype_tolower_loc() -> *mut *__int32_t;
    pub fn __ctype_toupper_loc() -> *mut *__int32_t;
    pub fn isalnum(arg1: c_int) -> c_int;
    pub fn isalpha(arg1: c_int) -> c_int;
    pub fn iscntrl(arg1: c_int) -> c_int;
    pub fn isdigit(arg1: c_int) -> c_int;
    pub fn islower(arg1: c_int) -> c_int;
    pub fn isgraph(arg1: c_int) -> c_int;
    pub fn isprint(arg1: c_int) -> c_int;
    pub fn ispunct(arg1: c_int) -> c_int;
    pub fn isspace(arg1: c_int) -> c_int;
    pub fn isupper(arg1: c_int) -> c_int;
    pub fn isxdigit(arg1: c_int) -> c_int;
    pub fn tolower(__c: c_int) -> c_int;
    pub fn toupper(__c: c_int) -> c_int;
    pub fn isblank(arg1: c_int) -> c_int;
    pub fn isctype(__c: c_int, __mask: c_int) -> c_int;
    pub fn isascii(__c: c_int) -> c_int;
    pub fn toascii(__c: c_int) -> c_int;
    pub fn _toupper(arg1: c_int) -> c_int;
    pub fn _tolower(arg1: c_int) -> c_int;
    pub fn isalnum_l(arg1: c_int, arg2: __locale_t) -> c_int;
    pub fn isalpha_l(arg1: c_int, arg2: __locale_t) -> c_int;
    pub fn iscntrl_l(arg1: c_int, arg2: __locale_t) -> c_int;
    pub fn isdigit_l(arg1: c_int, arg2: __locale_t) -> c_int;
    pub fn islower_l(arg1: c_int, arg2: __locale_t) -> c_int;
    pub fn isgraph_l(arg1: c_int, arg2: __locale_t) -> c_int;
    pub fn isprint_l(arg1: c_int, arg2: __locale_t) -> c_int;
    pub fn ispunct_l(arg1: c_int, arg2: __locale_t) -> c_int;
    pub fn isspace_l(arg1: c_int, arg2: __locale_t) -> c_int;
    pub fn isupper_l(arg1: c_int, arg2: __locale_t) -> c_int;
    pub fn isxdigit_l(arg1: c_int, arg2: __locale_t) -> c_int;
    pub fn isblank_l(arg1: c_int, arg2: __locale_t) -> c_int;
    pub fn __tolower_l(__c: c_int, __l: __locale_t) -> c_int;
    pub fn tolower_l(__c: c_int, __l: __locale_t) -> c_int;
    pub fn __toupper_l(__c: c_int, __l: __locale_t) -> c_int;
    pub fn toupper_l(__c: c_int, __l: __locale_t) -> c_int;
    pub fn iconv_open(__tocode: *c_schar, __fromcode: *c_schar) -> iconv_t;
    pub fn iconv(__cd: iconv_t, __inbuf: *mut *mut c_schar,
                 __inbytesleft: *mut size_t, __outbuf: *mut *mut c_schar,
                 __outbytesleft: *mut size_t) -> size_t;
    pub fn iconv_close(__cd: iconv_t) -> c_int;
    pub fn SDL_revcpy(dst: *mut c_void, src: *c_void, len: size_t) ->
     *mut c_void;
    pub fn SDL_strlcpy(dst: *mut c_schar, src: *c_schar, maxlen: size_t) ->
     size_t;
    pub fn SDL_strlcat(dst: *mut c_schar, src: *c_schar, maxlen: size_t) ->
     size_t;
    pub fn SDL_strrev(string: *mut c_schar) -> *mut c_schar;
    pub fn SDL_strupr(string: *mut c_schar) -> *mut c_schar;
    pub fn SDL_strlwr(string: *mut c_schar) -> *mut c_schar;
    pub fn SDL_ltoa(value: c_long, string: *mut c_schar, radix: c_int) ->
     *mut c_schar;
    pub fn SDL_ultoa(value: c_ulong, string: *mut c_schar, radix: c_int) ->
     *mut c_schar;
    pub fn SDL_lltoa(value: Sint64, string: *mut c_schar, radix: c_int) ->
     *mut c_schar;
    pub fn SDL_ulltoa(value: Uint64, string: *mut c_schar, radix: c_int) ->
     *mut c_schar;
    pub fn SDL_iconv(cd: iconv_t, inbuf: *mut *c_schar,
                     inbytesleft: *mut size_t, outbuf: *mut *mut c_schar,
                     outbytesleft: *mut size_t) -> size_t;
    pub fn SDL_iconv_string(tocode: *c_schar, fromcode: *c_schar,
                            inbuf: *c_schar, inbytesleft: size_t) ->
     *mut c_schar;
    pub fn SDL_SetError(fmt: *c_schar, ...);
    pub fn SDL_GetError() -> *mut c_schar;
    pub fn SDL_ClearError();
    pub fn SDL_Error(code: SDL_errorcode);
    pub fn SDL_CreateMutex() -> *mut SDL_mutex;
    pub fn SDL_mutexP(mutex: *mut SDL_mutex) -> c_int;
    pub fn SDL_mutexV(mutex: *mut SDL_mutex) -> c_int;
    pub fn SDL_DestroyMutex(mutex: *mut SDL_mutex);
    pub fn SDL_CreateSemaphore(initial_value: Uint32) -> *mut SDL_sem;
    pub fn SDL_DestroySemaphore(sem: *mut SDL_sem);
    pub fn SDL_SemWait(sem: *mut SDL_sem) -> c_int;
    pub fn SDL_SemTryWait(sem: *mut SDL_sem) -> c_int;
    pub fn SDL_SemWaitTimeout(sem: *mut SDL_sem, ms: Uint32) -> c_int;
    pub fn SDL_SemPost(sem: *mut SDL_sem) -> c_int;
    pub fn SDL_SemValue(sem: *mut SDL_sem) -> Uint32;
    pub fn SDL_CreateCond() -> *mut SDL_cond;
    pub fn SDL_DestroyCond(cond: *mut SDL_cond);
    pub fn SDL_CondSignal(cond: *mut SDL_cond) -> c_int;
    pub fn SDL_CondBroadcast(cond: *mut SDL_cond) -> c_int;
    pub fn SDL_CondWait(cond: *mut SDL_cond, _mut: *mut SDL_mutex) -> c_int;
    pub fn SDL_CondWaitTimeout(cond: *mut SDL_cond, mutex: *mut SDL_mutex,
                               ms: Uint32) -> c_int;
    pub fn SDL_CreateThread(_fn:
                                ::std::option::Option<extern "C" fn
                                                          (arg1: *mut c_void)
                                                          -> c_int>,
                            data: *mut c_void) -> *mut SDL_Thread;
    pub fn SDL_ThreadID() -> Uint32;
    pub fn SDL_GetThreadID(thread: *mut SDL_Thread) -> Uint32;
    pub fn SDL_WaitThread(thread: *mut SDL_Thread, status: *mut c_int);
    pub fn SDL_KillThread(thread: *mut SDL_Thread);
    pub fn SDL_RWFromFile(file: *c_schar, mode: *c_schar) -> *mut SDL_RWops;
    pub fn SDL_RWFromFP(fp: *mut FILE, autoclose: c_int) -> *mut SDL_RWops;
    pub fn SDL_RWFromMem(mem: *mut c_void, size: c_int) -> *mut SDL_RWops;
    pub fn SDL_RWFromConstMem(mem: *c_void, size: c_int) -> *mut SDL_RWops;
    pub fn SDL_AllocRW() -> *mut SDL_RWops;
    pub fn SDL_FreeRW(area: *mut SDL_RWops);
    pub fn SDL_ReadLE16(src: *mut SDL_RWops) -> Uint16;
    pub fn SDL_ReadBE16(src: *mut SDL_RWops) -> Uint16;
    pub fn SDL_ReadLE32(src: *mut SDL_RWops) -> Uint32;
    pub fn SDL_ReadBE32(src: *mut SDL_RWops) -> Uint32;
    pub fn SDL_ReadLE64(src: *mut SDL_RWops) -> Uint64;
    pub fn SDL_ReadBE64(src: *mut SDL_RWops) -> Uint64;
    pub fn SDL_WriteLE16(dst: *mut SDL_RWops, value: Uint16) -> c_int;
    pub fn SDL_WriteBE16(dst: *mut SDL_RWops, value: Uint16) -> c_int;
    pub fn SDL_WriteLE32(dst: *mut SDL_RWops, value: Uint32) -> c_int;
    pub fn SDL_WriteBE32(dst: *mut SDL_RWops, value: Uint32) -> c_int;
    pub fn SDL_WriteLE64(dst: *mut SDL_RWops, value: Uint64) -> c_int;
    pub fn SDL_WriteBE64(dst: *mut SDL_RWops, value: Uint64) -> c_int;
    pub fn SDL_AudioInit(driver_name: *c_schar) -> c_int;
    pub fn SDL_AudioQuit();
    pub fn SDL_AudioDriverName(namebuf: *mut c_schar, maxlen: c_int) ->
     *mut c_schar;
    pub fn SDL_OpenAudio(desired: *mut SDL_AudioSpec,
                         obtained: *mut SDL_AudioSpec) -> c_int;
    pub fn SDL_GetAudioStatus() -> SDL_audiostatus;
    pub fn SDL_PauseAudio(pause_on: c_int);
    pub fn SDL_LoadWAV_RW(src: *mut SDL_RWops, freesrc: c_int,
                          spec: *mut SDL_AudioSpec,
                          audio_buf: *mut *mut Uint8, audio_len: *mut Uint32)
     -> *mut SDL_AudioSpec;
    pub fn SDL_FreeWAV(audio_buf: *mut Uint8);
    pub fn SDL_BuildAudioCVT(cvt: *mut SDL_AudioCVT, src_format: Uint16,
                             src_channels: Uint8, src_rate: c_int,
                             dst_format: Uint16, dst_channels: Uint8,
                             dst_rate: c_int) -> c_int;
    pub fn SDL_ConvertAudio(cvt: *mut SDL_AudioCVT) -> c_int;
    pub fn SDL_MixAudio(dst: *mut Uint8, src: *Uint8, len: Uint32,
                        volume: c_int);
    pub fn SDL_LockAudio();
    pub fn SDL_UnlockAudio();
    pub fn SDL_CloseAudio();
    pub fn SDL_CDNumDrives() -> c_int;
    pub fn SDL_CDName(drive: c_int) -> *c_schar;
    pub fn SDL_CDOpen(drive: c_int) -> *mut SDL_CD;
    pub fn SDL_CDStatus(cdrom: *mut SDL_CD) -> CDstatus;
    pub fn SDL_CDPlayTracks(cdrom: *mut SDL_CD, start_track: c_int,
                            start_frame: c_int, ntracks: c_int,
                            nframes: c_int) -> c_int;
    pub fn SDL_CDPlay(cdrom: *mut SDL_CD, start: c_int, length: c_int) ->
     c_int;
    pub fn SDL_CDPause(cdrom: *mut SDL_CD) -> c_int;
    pub fn SDL_CDResume(cdrom: *mut SDL_CD) -> c_int;
    pub fn SDL_CDStop(cdrom: *mut SDL_CD) -> c_int;
    pub fn SDL_CDEject(cdrom: *mut SDL_CD) -> c_int;
    pub fn SDL_CDClose(cdrom: *mut SDL_CD);
    pub fn SDL_HasRDTSC() -> SDL_bool;
    pub fn SDL_HasMMX() -> SDL_bool;
    pub fn SDL_HasMMXExt() -> SDL_bool;
    pub fn SDL_Has3DNow() -> SDL_bool;
    pub fn SDL_Has3DNowExt() -> SDL_bool;
    pub fn SDL_HasSSE() -> SDL_bool;
    pub fn SDL_HasSSE2() -> SDL_bool;
    pub fn SDL_HasAltiVec() -> SDL_bool;
    pub fn SDL_GetAppState() -> Uint8;
    pub fn SDL_EnableUNICODE(enable: c_int) -> c_int;
    pub fn SDL_EnableKeyRepeat(delay: c_int, interval: c_int) -> c_int;
    pub fn SDL_GetKeyRepeat(delay: *mut c_int, interval: *mut c_int);
    pub fn SDL_GetKeyState(numkeys: *mut c_int) -> *mut Uint8;
    pub fn SDL_GetModState() -> SDLMod;
    pub fn SDL_SetModState(modstate: SDLMod);
    pub fn SDL_GetKeyName(key: SDLKey) -> *mut c_schar;
    pub fn SDL_VideoInit(driver_name: *c_schar, flags: Uint32) -> c_int;
    pub fn SDL_VideoQuit();
    pub fn SDL_VideoDriverName(namebuf: *mut c_schar, maxlen: c_int) ->
     *mut c_schar;
    pub fn SDL_GetVideoSurface() -> *mut SDL_Surface;
    pub fn SDL_GetVideoInfo() -> *SDL_VideoInfo;
    pub fn SDL_VideoModeOK(width: c_int, height: c_int, bpp: c_int,
                           flags: Uint32) -> c_int;
    pub fn SDL_ListModes(format: *mut SDL_PixelFormat, flags: Uint32) ->
     *mut *mut SDL_Rect;
    pub fn SDL_SetVideoMode(width: c_int, height: c_int, bpp: c_int,
                            flags: Uint32) -> *mut SDL_Surface;
    pub fn SDL_UpdateRects(screen: *mut SDL_Surface, numrects: c_int,
                           rects: *mut SDL_Rect);
    pub fn SDL_UpdateRect(screen: *mut SDL_Surface, x: Sint32, y: Sint32,
                          w: Uint32, h: Uint32);
    pub fn SDL_Flip(screen: *mut SDL_Surface) -> c_int;
    pub fn SDL_SetGamma(red: c_float, green: c_float, blue: c_float) -> c_int;
    pub fn SDL_SetGammaRamp(red: *Uint16, green: *Uint16, blue: *Uint16) ->
     c_int;
    pub fn SDL_GetGammaRamp(red: *mut Uint16, green: *mut Uint16,
                            blue: *mut Uint16) -> c_int;
    pub fn SDL_SetColors(surface: *mut SDL_Surface, colors: *mut SDL_Color,
                         firstcolor: c_int, ncolors: c_int) -> c_int;
    pub fn SDL_SetPalette(surface: *mut SDL_Surface, flags: c_int,
                          colors: *mut SDL_Color, firstcolor: c_int,
                          ncolors: c_int) -> c_int;
    pub fn SDL_MapRGB(format: *SDL_PixelFormat, r: Uint8, g: Uint8, b: Uint8)
     -> Uint32;
    pub fn SDL_MapRGBA(format: *SDL_PixelFormat, r: Uint8, g: Uint8, b: Uint8,
                       a: Uint8) -> Uint32;
    pub fn SDL_GetRGB(pixel: Uint32, fmt: *SDL_PixelFormat, r: *mut Uint8,
                      g: *mut Uint8, b: *mut Uint8);
    pub fn SDL_GetRGBA(pixel: Uint32, fmt: *SDL_PixelFormat, r: *mut Uint8,
                       g: *mut Uint8, b: *mut Uint8, a: *mut Uint8);
    pub fn SDL_CreateRGBSurface(flags: Uint32, width: c_int, height: c_int,
                                depth: c_int, Rmask: Uint32, Gmask: Uint32,
                                Bmask: Uint32, Amask: Uint32) ->
     *mut SDL_Surface;
    pub fn SDL_CreateRGBSurfaceFrom(pixels: *mut c_void, width: c_int,
                                    height: c_int, depth: c_int, pitch: c_int,
                                    Rmask: Uint32, Gmask: Uint32,
                                    Bmask: Uint32, Amask: Uint32) ->
     *mut SDL_Surface;
    pub fn SDL_FreeSurface(surface: *mut SDL_Surface);
    pub fn SDL_LockSurface(surface: *mut SDL_Surface) -> c_int;
    pub fn SDL_UnlockSurface(surface: *mut SDL_Surface);
    pub fn SDL_LoadBMP_RW(src: *mut SDL_RWops, freesrc: c_int) ->
     *mut SDL_Surface;
    pub fn SDL_SaveBMP_RW(surface: *mut SDL_Surface, dst: *mut SDL_RWops,
                          freedst: c_int) -> c_int;
    pub fn SDL_SetColorKey(surface: *mut SDL_Surface, flag: Uint32,
                           key: Uint32) -> c_int;
    pub fn SDL_SetAlpha(surface: *mut SDL_Surface, flag: Uint32, alpha: Uint8)
     -> c_int;
    pub fn SDL_SetClipRect(surface: *mut SDL_Surface, rect: *SDL_Rect) ->
     SDL_bool;
    pub fn SDL_GetClipRect(surface: *mut SDL_Surface, rect: *mut SDL_Rect);
    pub fn SDL_ConvertSurface(src: *mut SDL_Surface,
                              fmt: *mut SDL_PixelFormat, flags: Uint32) ->
     *mut SDL_Surface;
    pub fn SDL_UpperBlit(src: *mut SDL_Surface, srcrect: *mut SDL_Rect,
                         dst: *mut SDL_Surface, dstrect: *mut SDL_Rect) ->
     c_int;
    pub fn SDL_LowerBlit(src: *mut SDL_Surface, srcrect: *mut SDL_Rect,
                         dst: *mut SDL_Surface, dstrect: *mut SDL_Rect) ->
     c_int;
    pub fn SDL_FillRect(dst: *mut SDL_Surface, dstrect: *mut SDL_Rect,
                        color: Uint32) -> c_int;
    pub fn SDL_DisplayFormat(surface: *mut SDL_Surface) -> *mut SDL_Surface;
    pub fn SDL_DisplayFormatAlpha(surface: *mut SDL_Surface) ->
     *mut SDL_Surface;
    pub fn SDL_CreateYUVOverlay(width: c_int, height: c_int, format: Uint32,
                                display: *mut SDL_Surface) ->
     *mut SDL_Overlay;
    pub fn SDL_LockYUVOverlay(overlay: *mut SDL_Overlay) -> c_int;
    pub fn SDL_UnlockYUVOverlay(overlay: *mut SDL_Overlay);
    pub fn SDL_DisplayYUVOverlay(overlay: *mut SDL_Overlay,
                                 dstrect: *mut SDL_Rect) -> c_int;
    pub fn SDL_FreeYUVOverlay(overlay: *mut SDL_Overlay);
    pub fn SDL_GL_LoadLibrary(path: *c_schar) -> c_int;
    pub fn SDL_GL_GetProcAddress(_proc: *c_schar) -> *mut c_void;
    pub fn SDL_GL_SetAttribute(attr: SDL_GLattr, value: c_int) -> c_int;
    pub fn SDL_GL_GetAttribute(attr: SDL_GLattr, value: *mut c_int) -> c_int;
    pub fn SDL_GL_SwapBuffers();
    pub fn SDL_GL_UpdateRects(numrects: c_int, rects: *mut SDL_Rect);
    pub fn SDL_GL_Lock();
    pub fn SDL_GL_Unlock();
    pub fn SDL_WM_SetCaption(title: *c_schar, icon: *c_schar);
    pub fn SDL_WM_GetCaption(title: *mut *mut c_schar,
                             icon: *mut *mut c_schar);
    pub fn SDL_WM_SetIcon(icon: *mut SDL_Surface, mask: *mut Uint8);
    pub fn SDL_WM_IconifyWindow() -> c_int;
    pub fn SDL_WM_ToggleFullScreen(surface: *mut SDL_Surface) -> c_int;
    pub fn SDL_WM_GrabInput(mode: SDL_GrabMode) -> SDL_GrabMode;
    pub fn SDL_SoftStretch(src: *mut SDL_Surface, srcrect: *mut SDL_Rect,
                           dst: *mut SDL_Surface, dstrect: *mut SDL_Rect) ->
     c_int;
    pub fn SDL_GetMouseState(x: *mut c_int, y: *mut c_int) -> Uint8;
    pub fn SDL_GetRelativeMouseState(x: *mut c_int, y: *mut c_int) -> Uint8;
    pub fn SDL_WarpMouse(x: Uint16, y: Uint16);
    pub fn SDL_CreateCursor(data: *mut Uint8, mask: *mut Uint8, w: c_int,
                            h: c_int, hot_x: c_int, hot_y: c_int) ->
     *mut SDL_Cursor;
    pub fn SDL_SetCursor(cursor: *mut SDL_Cursor);
    pub fn SDL_GetCursor() -> *mut SDL_Cursor;
    pub fn SDL_FreeCursor(cursor: *mut SDL_Cursor);
    pub fn SDL_ShowCursor(toggle: c_int) -> c_int;
    pub fn SDL_NumJoysticks() -> c_int;
    pub fn SDL_JoystickName(device_index: c_int) -> *c_schar;
    pub fn SDL_JoystickOpen(device_index: c_int) -> *mut SDL_Joystick;
    pub fn SDL_JoystickOpened(device_index: c_int) -> c_int;
    pub fn SDL_JoystickIndex(joystick: *mut SDL_Joystick) -> c_int;
    pub fn SDL_JoystickNumAxes(joystick: *mut SDL_Joystick) -> c_int;
    pub fn SDL_JoystickNumBalls(joystick: *mut SDL_Joystick) -> c_int;
    pub fn SDL_JoystickNumHats(joystick: *mut SDL_Joystick) -> c_int;
    pub fn SDL_JoystickNumButtons(joystick: *mut SDL_Joystick) -> c_int;
    pub fn SDL_JoystickUpdate();
    pub fn SDL_JoystickEventState(state: c_int) -> c_int;
    pub fn SDL_JoystickGetAxis(joystick: *mut SDL_Joystick, axis: c_int) ->
     Sint16;
    pub fn SDL_JoystickGetHat(joystick: *mut SDL_Joystick, hat: c_int) ->
     Uint8;
    pub fn SDL_JoystickGetBall(joystick: *mut SDL_Joystick, ball: c_int,
                               dx: *mut c_int, dy: *mut c_int) -> c_int;
    pub fn SDL_JoystickGetButton(joystick: *mut SDL_Joystick, button: c_int)
     -> Uint8;
    pub fn SDL_JoystickClose(joystick: *mut SDL_Joystick);
    pub fn SDL_PumpEvents();
    pub fn SDL_PeepEvents(events: *mut SDL_Event, numevents: c_int,
                          action: SDL_eventaction, mask: Uint32) -> c_int;
    pub fn SDL_PollEvent(event: *mut SDL_Event) -> c_int;
    pub fn SDL_WaitEvent(event: *mut SDL_Event) -> c_int;
    pub fn SDL_PushEvent(event: *mut SDL_Event) -> c_int;
    pub fn SDL_SetEventFilter(filter: SDL_EventFilter);
    pub fn SDL_GetEventFilter() -> SDL_EventFilter;
    pub fn SDL_EventState(_type: Uint8, state: c_int) -> Uint8;
    pub fn SDL_LoadObject(sofile: *c_schar) -> *mut c_void;
    pub fn SDL_LoadFunction(handle: *mut c_void, name: *c_schar) ->
     *mut c_void;
    pub fn SDL_UnloadObject(handle: *mut c_void);
    pub fn SDL_GetTicks() -> Uint32;
    pub fn SDL_Delay(ms: Uint32);
    pub fn SDL_SetTimer(interval: Uint32, callback: SDL_TimerCallback) ->
     c_int;
    pub fn SDL_AddTimer(interval: Uint32, callback: SDL_NewTimerCallback,
                        param: *mut c_void) -> SDL_TimerID;
    pub fn SDL_RemoveTimer(t: SDL_TimerID) -> SDL_bool;
    pub fn SDL_Linked_Version() -> *SDL_version;
    pub fn SDL_Init(flags: Uint32) -> c_int;
    pub fn SDL_InitSubSystem(flags: Uint32) -> c_int;
    pub fn SDL_QuitSubSystem(flags: Uint32);
    pub fn SDL_WasInit(flags: Uint32) -> Uint32;
    pub fn SDL_Quit();
    pub fn TTF_Linked_Version() -> *SDL_version;
    pub fn TTF_ByteSwappedUNICODE(swapped: c_int);
    pub fn TTF_Init() -> c_int;
    pub fn TTF_OpenFont(file: *c_schar, ptsize: c_int) -> *mut TTF_Font;
    pub fn TTF_OpenFontIndex(file: *c_schar, ptsize: c_int, index: c_long) ->
     *mut TTF_Font;
    pub fn TTF_OpenFontRW(src: *mut SDL_RWops, freesrc: c_int, ptsize: c_int)
     -> *mut TTF_Font;
    pub fn TTF_OpenFontIndexRW(src: *mut SDL_RWops, freesrc: c_int,
                               ptsize: c_int, index: c_long) -> *mut TTF_Font;
    pub fn TTF_GetFontStyle(font: *TTF_Font) -> c_int;
    pub fn TTF_SetFontStyle(font: *mut TTF_Font, style: c_int);
    pub fn TTF_GetFontOutline(font: *TTF_Font) -> c_int;
    pub fn TTF_SetFontOutline(font: *mut TTF_Font, outline: c_int);
    pub fn TTF_GetFontHinting(font: *TTF_Font) -> c_int;
    pub fn TTF_SetFontHinting(font: *mut TTF_Font, hinting: c_int);
    pub fn TTF_FontHeight(font: *TTF_Font) -> c_int;
    pub fn TTF_FontAscent(font: *TTF_Font) -> c_int;
    pub fn TTF_FontDescent(font: *TTF_Font) -> c_int;
    pub fn TTF_FontLineSkip(font: *TTF_Font) -> c_int;
    pub fn TTF_GetFontKerning(font: *TTF_Font) -> c_int;
    pub fn TTF_SetFontKerning(font: *mut TTF_Font, allowed: c_int);
    pub fn TTF_FontFaces(font: *TTF_Font) -> c_long;
    pub fn TTF_FontFaceIsFixedWidth(font: *TTF_Font) -> c_int;
    pub fn TTF_FontFaceFamilyName(font: *TTF_Font) -> *mut c_schar;
    pub fn TTF_FontFaceStyleName(font: *TTF_Font) -> *mut c_schar;
    pub fn TTF_GlyphIsProvided(font: *TTF_Font, ch: Uint16) -> c_int;
    pub fn TTF_GlyphMetrics(font: *mut TTF_Font, ch: Uint16, minx: *mut c_int,
                            maxx: *mut c_int, miny: *mut c_int,
                            maxy: *mut c_int, advance: *mut c_int) -> c_int;
    pub fn TTF_SizeText(font: *mut TTF_Font, text: *c_schar, w: *mut c_int,
                        h: *mut c_int) -> c_int;
    pub fn TTF_SizeUTF8(font: *mut TTF_Font, text: *c_schar, w: *mut c_int,
                        h: *mut c_int) -> c_int;
    pub fn TTF_SizeUNICODE(font: *mut TTF_Font, text: *Uint16, w: *mut c_int,
                           h: *mut c_int) -> c_int;
    pub fn TTF_RenderText_Solid(font: *mut TTF_Font, text: *c_schar,
                                fg: SDL_Color) -> *mut SDL_Surface;
    pub fn TTF_RenderUTF8_Solid(font: *mut TTF_Font, text: *c_schar,
                                fg: SDL_Color) -> *mut SDL_Surface;
    pub fn TTF_RenderUNICODE_Solid(font: *mut TTF_Font, text: *Uint16,
                                   fg: SDL_Color) -> *mut SDL_Surface;
    pub fn TTF_RenderGlyph_Solid(font: *mut TTF_Font, ch: Uint16,
                                 fg: SDL_Color) -> *mut SDL_Surface;
    pub fn TTF_RenderText_Shaded(font: *mut TTF_Font, text: *c_schar,
                                 fg: SDL_Color, bg: SDL_Color) ->
     *mut SDL_Surface;
    pub fn TTF_RenderUTF8_Shaded(font: *mut TTF_Font, text: *c_schar,
                                 fg: SDL_Color, bg: SDL_Color) ->
     *mut SDL_Surface;
    pub fn TTF_RenderUNICODE_Shaded(font: *mut TTF_Font, text: *Uint16,
                                    fg: SDL_Color, bg: SDL_Color) ->
     *mut SDL_Surface;
    pub fn TTF_RenderGlyph_Shaded(font: *mut TTF_Font, ch: Uint16,
                                  fg: SDL_Color, bg: SDL_Color) ->
     *mut SDL_Surface;
    pub fn TTF_RenderText_Blended(font: *mut TTF_Font, text: *c_schar,
                                  fg: SDL_Color) -> *mut SDL_Surface;
    pub fn TTF_RenderUTF8_Blended(font: *mut TTF_Font, text: *c_schar,
                                  fg: SDL_Color) -> *mut SDL_Surface;
    pub fn TTF_RenderUNICODE_Blended(font: *mut TTF_Font, text: *Uint16,
                                     fg: SDL_Color) -> *mut SDL_Surface;
    pub fn TTF_RenderGlyph_Blended(font: *mut TTF_Font, ch: Uint16,
                                   fg: SDL_Color) -> *mut SDL_Surface;
    pub fn TTF_CloseFont(font: *mut TTF_Font);
    pub fn TTF_Quit();
    pub fn TTF_WasInit() -> c_int;
    pub fn TTF_GetFontKerningSize(font: *mut TTF_Font, prev_index: c_int,
                                  index: c_int) -> c_int;
}
